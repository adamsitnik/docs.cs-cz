---
title: 'Doba života objektu: Jak objekty jsou vytvořeny a zničen (Visual Basic)'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: dc05b3acda5183ddc9a7c0bdddf08a3934c298f6
ms.sourcegitcommit: facefcacd7ae2e5645e463bc841df213c505ffd4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/05/2019
ms.locfileid: "55738913"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="6e9f4-102">Doba života objektu: Jak objekty jsou vytvořeny a zničen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6e9f4-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>
<span data-ttu-id="6e9f4-103">Instance třídy objektu, je vytvořen pomocí `New` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="6e9f4-104">Inicializace úlohy často je nutné provádět na nové objekty před jejich použití.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="6e9f4-105">Běžné úlohy inicializace zahrnují otevírání souborů, připojení k databázím a čtení hodnoty z klíče registru.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="6e9f4-106">Visual Basic řídí Inicializace nové objekty pomocí procedury volané *konstruktory* (speciální metody, které umožňují kontrolu nad inicializace).</span><span class="sxs-lookup"><span data-stu-id="6e9f4-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>  
  
 <span data-ttu-id="6e9f4-107">Objekt odešel oboru, se uvolní modulem common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="6e9f4-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="6e9f4-108">Visual Basic určuje verzi systémové prostředky pomocí procedury volané *destruktory*.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="6e9f4-109">Konstruktory a destruktory společně, podporu vytváření knihoven tříd robustní a předvídatelné.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>  
  
## <a name="using-constructors-and-destructors"></a><span data-ttu-id="6e9f4-110">Použití konstruktorů a destruktorů</span><span class="sxs-lookup"><span data-stu-id="6e9f4-110">Using Constructors and Destructors</span></span>  
 <span data-ttu-id="6e9f4-111">Konstruktory a destruktory řídí vytváření a ničení objektů.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="6e9f4-112">`Sub New` a `Sub Finalize` procedury v jazyce Visual Basic, inicializovat a zničit objekty; nahrazují `Class_Initialize` a `Class_Terminate` metod používaných v jazyce Visual Basic 6.0 a starší verze.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>  
  
### <a name="sub-new"></a><span data-ttu-id="6e9f4-113">Nový Sub</span><span class="sxs-lookup"><span data-stu-id="6e9f4-113">Sub New</span></span>  
 <span data-ttu-id="6e9f4-114">`Sub New` Konstruktor lze spustit pouze jednou při vytvoření třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="6e9f4-115">Nelze ji vyvolat explicitně kdekoli jinak než v prvním řádku kódu z jiného konstruktoru ze stejné třídy nebo z odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="6e9f4-116">Kromě toho kód v `Sub New` metoda vždy spouští před ostatním kódem ve třídě.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] <span data-ttu-id="6e9f4-117">a novějších verzích implicitně vytvářet `Sub New` konstruktor v době běhu, pokud nejsou explicitně definovány `Sub New` postup pro třídu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-117">and later versions implicitly create a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>  
  
 <span data-ttu-id="6e9f4-118">Pokud chcete vytvořit konstruktor pro třídu, vytvořte proceduru s názvem `Sub New` kdekoli v definici třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="6e9f4-119">Vytvoření konstruktoru s parametry, zadejte názvy a datové typy argumentů, které mají `Sub New` stejně jako byste měli zadat argumenty pro všechny procedury, stejně jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>  
  
 [!code-vb[VbVbalrOOP#42](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)]  
  
 <span data-ttu-id="6e9f4-120">Konstruktory jsou často přetížené, stejně jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-120">Constructors are frequently overloaded, as in the following code:</span></span>  
  
 [!code-vb[VbVbalrOOP#116](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)]  
  
 <span data-ttu-id="6e9f4-121">Při definování třídy odvozené z jiné třídy první řádek konstruktor musí být volání konstruktoru základní třídy, pokud má základní třída přístupný konstruktor, který nepřijímá žádné parametry.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="6e9f4-122">Volání na základní třídu, která obsahuje konstruktoru výše, například by `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="6e9f4-123">V opačném případě `MyBase.New` je volitelný, a modul runtime jazyka Visual Basic volá implicitně.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>  
  
 <span data-ttu-id="6e9f4-124">Když napíšete kód volání konstruktoru nadřazeného objektu, můžete přidat žádný další inicializační kód `Sub New` postup.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="6e9f4-125">`Sub New` může přijímat argumenty při volání jako parametry konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="6e9f4-126">Tyto parametry jsou předány z procedury volání konstruktoru, například `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>  
  
### <a name="sub-finalize"></a><span data-ttu-id="6e9f4-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="6e9f4-127">Sub Finalize</span></span>  
 <span data-ttu-id="6e9f4-128">Před uvolněním objekty, budou automaticky volá modul CLR `Finalize` metody pro objekty, které definují `Sub Finalize` postup.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="6e9f4-129">`Finalize` Metoda může obsahovat kód, který potřebuje provést, těsně před plánovaným začátkem objekt je zničen, jako je například kód pro zavření souborů a ukládání informací o stavu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="6e9f4-130">Je mírné snížení výkonu pro provedení `Sub Finalize`, takže byste měli definovat `Sub Finalize` metodu pouze v případě, že je potřeba explicitně uvolnit objekty.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e9f4-131">Uvolňování paměti v CLR nepodporuje (a nelze) vyřadit *nespravované objekty*, objekty, které operační systém spustí přímo, mimo prostředí modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="6e9f4-132">Je to proto, že různé nespravované objekty musí být odstraněny různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="6e9f4-133">Informace o nejsou přímo spojené s neřízeným objektem; je nutné ji najít v dokumentaci k objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="6e9f4-134">Třída, která používá nespravované objekty musí uvolnit z nich v jeho `Finalize` metoda.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>  
  
 <span data-ttu-id="6e9f4-135">`Finalize` Destruktor je chráněná metoda, kterou lze volat pouze z třídy, které patří do nebo z odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="6e9f4-136">Systémová volání `Finalize` automaticky při objekt je zničen, takže byste neměli volat explicitně `Finalize` z mimo odvozené třídy `Finalize` implementace.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>  
  
 <span data-ttu-id="6e9f4-137">Na rozdíl od `Class_Terminate`, která se spustí poté, co objekt je nastavena na hodnotu nothing, obvykle dochází ke zpoždění mezi když objekt Vyskočení a při volání jazyka Visual Basic `Finalize` destruktor.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] <span data-ttu-id="6e9f4-138">a novějších verzích povolit pro druhý typ destruktor, <xref:System.IDisposable.Dispose%2A>, kterou můžete kdykoli a uvolnit tak prostředky explicitně volat.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-138">and later versions allow for a second kind of destructor, <xref:System.IDisposable.Dispose%2A>, which can be explicitly called at any time to immediately release resources.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e9f4-139">A `Finalize` destruktoru by neměla vyvolávat výjimky, protože nemůže být zpracovány aplikací a může způsobit ukončení aplikace.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>  
  
### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="6e9f4-140">Přiřazení nových a dokončení metody fungují v hierarchii tříd</span><span class="sxs-lookup"><span data-stu-id="6e9f4-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>  
 <span data-ttu-id="6e9f4-141">Pokaždé, když je vytvořena instance třídy, se pokusí spustit proceduru s názvem common language runtime (CLR) `New`, pokud existuje v tomto objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="6e9f4-142">`New` je typ procedura volána `constructor` , který slouží k inicializaci nové objekty před provedením jakýkoli jiný kód v objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="6e9f4-143">A `New` konstruktor lze použít k otevírání souborů, připojit se k nim, inicializovat proměnné a postará o další úlohy, které je potřeba provést před použitím objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>  
  
 <span data-ttu-id="6e9f4-144">Když je vytvořena instance odvozené třídy, `Sub New` konstruktor základní třídy, spustí nejprve, za nímž následuje konstruktory v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="6e9f4-145">Je to způsobeno první řádek kódu v `Sub New` konstruktor používá syntaxi `MyBase.New()`volat konstruktor třídy přímo nad sám v hierarchii tříd.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="6e9f4-146">`Sub New` Pak volání konstruktoru pro každou třídu v hierarchii tříd do konstruktoru pro dosažení základní třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="6e9f4-147">V tu chvíli se kód v konstruktoru pro základní třídu spustí, za nímž následuje kód v jednotlivých konstruktor všechny odvozené třídy a poslední spuštění kódu v nejvíce odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>  
  
 <span data-ttu-id="6e9f4-148">![Konstruktory a dědičnost](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif "vaConstructorsInheritance")</span><span class="sxs-lookup"><span data-stu-id="6e9f4-148">![Constructors and Inheritance](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif "vaConstructorsInheritance")</span></span>  
  
 <span data-ttu-id="6e9f4-149">Pokud objekt je už nepotřebujete, kterou volá CLR <xref:System.Object.Finalize%2A> metodu pro tento objekt před uvolněním paměti.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="6e9f4-150"><xref:System.Object.Finalize%2A> Metoda je volána `destructor` protože provádí úlohy čištění, jako je například ukládání informací o stavu, zavírání souborů a připojení k databázím a dalších úlohách, které je třeba provést před uvolněním objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>  
  
 <span data-ttu-id="6e9f4-151">![Constructors Inheritance2](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif "vaConstructorsInheritance_2")</span><span class="sxs-lookup"><span data-stu-id="6e9f4-151">![Constructors Inheritance2](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif "vaConstructorsInheritance_2")</span></span>  
  
## <a name="idisposable-interface"></a><span data-ttu-id="6e9f4-152">Rozhraní IDisposable</span><span class="sxs-lookup"><span data-stu-id="6e9f4-152">IDisposable Interface</span></span>  
 <span data-ttu-id="6e9f4-153">Instance třídy často řídit prostředky, které nejsou spravované přes modul CLR, jako jsou popisovače Windows a připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="6e9f4-154">Tyto prostředky musí být odstraněny v `Finalize` metoda třídy, tak, aby se bude vydána při zničení objektu pomocí systému uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="6e9f4-155">Ale systému uvolňování paměti odstraní objekty pouze v případě, že modul CLR vyžaduje další volné paměti.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="6e9f4-156">To znamená, že prostředky nesmí uvolnit dokud dlouho po objekt dostane mimo rozsah.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>  
  
 <span data-ttu-id="6e9f4-157">K doplnění uvolňování paměti, můžete své třídy poskytují mechanismus pro aktivně spravovat systémové prostředky, pokud je implementovat <xref:System.IDisposable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="6e9f4-158"><xref:System.IDisposable> má jednu metodu <xref:System.IDisposable.Dispose%2A>, kteří klienti by měly volat po dokončení používání objektu.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="6e9f4-159">Můžete použít <xref:System.IDisposable.Dispose%2A> metoda okamžitě uvolnění prostředků a provádět úlohy, jako je zavření souborů a připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="6e9f4-160">Na rozdíl od `Finalize` destruktor, <xref:System.IDisposable.Dispose%2A> metoda není volána automaticky.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="6e9f4-161">Klienti třídy nutné explicitně volat <xref:System.IDisposable.Dispose%2A> Pokud chcete okamžitě uvolnit prostředky.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>  
  
### <a name="implementing-idisposable"></a><span data-ttu-id="6e9f4-162">Implementace rozhraní IDisposable</span><span class="sxs-lookup"><span data-stu-id="6e9f4-162">Implementing IDisposable</span></span>  
 <span data-ttu-id="6e9f4-163">Třídu, která implementuje <xref:System.IDisposable> rozhraní by měl obsahovat tyto části kódu:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>  
  
-   <span data-ttu-id="6e9f4-164">Pole pro udržování přehledu o, zda byl uvolněn objekt:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-164">A field for keeping track of whether the object has been disposed:</span></span>  
  
    ```  
    Protected disposed As Boolean = False  
    ```  
  
-   <span data-ttu-id="6e9f4-165">Přetížení <xref:System.IDisposable.Dispose%2A> , který uvolní prostředky třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="6e9f4-166">Tato metoda by měla být volány <xref:System.IDisposable.Dispose%2A> a `Finalize` metody základní třídy:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>  
  
    ```  
    Protected Overridable Sub Dispose(ByVal disposing As Boolean)  
        If Not Me.disposed Then  
            If disposing Then  
                ' Insert code to free managed resources.  
            End If  
            ' Insert code to free unmanaged resources.  
        End If  
        Me.disposed = True  
    End Sub  
    ```  
  
-   <span data-ttu-id="6e9f4-167">Implementace <xref:System.IDisposable.Dispose%2A> , který obsahuje pouze následující kód:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>  
  
    ```  
    Public Sub Dispose() Implements IDisposable.Dispose  
        Dispose(True)  
        GC.SuppressFinalize(Me)  
    End Sub  
    ```  
  
-   <span data-ttu-id="6e9f4-168">Přepsání `Finalize` metodu, která obsahuje pouze následující kód:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-168">An override of the `Finalize` method that contains only the following code:</span></span>  
  
    ```  
    Protected Overrides Sub Finalize()  
        Dispose(False)  
        MyBase.Finalize()  
    End Sub  
    ```  
  
### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="6e9f4-169">Odvozování z třídy, která implementuje rozhraní IDisposable</span><span class="sxs-lookup"><span data-stu-id="6e9f4-169">Deriving from a Class that Implements IDisposable</span></span>  
 <span data-ttu-id="6e9f4-170">Třída, která je odvozena ze základní třídy, která implementuje <xref:System.IDisposable> rozhraní není nutné přepsat libovolnou metodu základní, pokud používá další prostředky, které je potřeba se dá uvolnit.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="6e9f4-171">V takovém případě by měly přepsat odvozené třídy základní třídy `Dispose(disposing)` metoda k uvolnění prostředků odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="6e9f4-172">Toto přepsání musí volat základní třídy `Dispose(disposing)` metody.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-172">This override must call the base class's `Dispose(disposing)` method.</span></span>  
  
```  
Protected Overrides Sub Dispose(ByVal disposing As Boolean)  
    If Not Me.disposed Then  
        If disposing Then  
            ' Insert code to free managed resources.  
        End If  
        ' Insert code to free unmanaged resources.  
    End If  
    MyBase.Dispose(disposing)  
End Sub  
```  
  
 <span data-ttu-id="6e9f4-173">Odvozená třída nesmí přepsat základní třídy <xref:System.IDisposable.Dispose%2A> a `Finalize` metody.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="6e9f4-174">Pokud tyto metody jsou volány z instance odvozené třídy, implementaci základní třídy tyto metody volat přepsání odvozené třídě `Dispose(disposing)` metody.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>  
  
## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="6e9f4-175">Uvolňování paměti a Finalize – destruktor</span><span class="sxs-lookup"><span data-stu-id="6e9f4-175">Garbage Collection and the Finalize Destructor</span></span>  
 <span data-ttu-id="6e9f4-176">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Používá *uvolňování paměti odkaz trasování* systému pravidelně uvolnit nevyužité prostředky.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-176">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="6e9f4-177">Visual Basic 6.0 a starší používala jiný systém volá *počítání odkazů* ke správě prostředků.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="6e9f4-178">I když oba systémy automaticky provádí stejnou funkci, existuje několik důležitých rozdílů.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>  
  
 <span data-ttu-id="6e9f4-179">Modul CLR pravidelně zničí objekty, když systém zjistí, že tyto objekty už nejsou potřeba.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="6e9f4-180">Objekty jsou uvolní rychleji, když jsou systémové prostředky v krátkých dodávek a méně často jinak.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="6e9f4-181">Zpoždění mezi když objekt Vyskočení a kdy ho CLR uvolní znamená, že na rozdíl od s objekty v jazyce Visual Basic verze 6.0 a starší, nelze určit přesně když bude objekt zničen.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="6e9f4-182">V takové situaci objekty mají často *Nedeterministický životnost*.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="6e9f4-183">Ve většině případů není deterministický životnost nezmění jak psát aplikace, za předpokladu, nezapomeňte, že `Finalize` – destruktor nemusí spustit okamžitě, pokud objekt ztratí oboru.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>  
  
 <span data-ttu-id="6e9f4-184">Další rozdíl mezi systémy uvolnění paměti zahrnuje použití `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="6e9f4-185">Výhod počítání referencí v jazyce Visual Basic verze 6.0 a starší, někdy programátoři přiřazené `Nothing` objektu proměnné k uvolnění odkazy na tyto proměnné uchovávat.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="6e9f4-186">Pokud je proměnná uložena poslední odkaz na objekt, objektu prostředky byly vydány okamžitě.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="6e9f4-187">V pozdějších verzích jazyka Visual Basic zatímco můžou nastat případy, ve kterých je tento postup hodnotný, provádění se nikdy způsobí, že odkazovaného objektu k uvolnění její prostředky okamžitě.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="6e9f4-188">K uvolnění prostředků okamžitě, použijte objektu <xref:System.IDisposable.Dispose%2A> metodu, pokud je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="6e9f4-189">Jenom byste měli nastavit proměnnou na `Nothing` je, když je jeho životnost dlouho relativní k době systému uvolňování paměti používá ke zjišťování osamocených objektů.</span><span class="sxs-lookup"><span data-stu-id="6e9f4-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6e9f4-190">Viz také:</span><span class="sxs-lookup"><span data-stu-id="6e9f4-190">See also</span></span>
- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="6e9f4-191">[Inicializace a ukončování komponent](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="6e9f4-191">[Initialization and Termination of Components](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="6e9f4-192">Operátor New</span><span class="sxs-lookup"><span data-stu-id="6e9f4-192">New Operator</span></span>](../../../../visual-basic/language-reference/operators/new-operator.md)
- [<span data-ttu-id="6e9f4-193">Vymazání nespravovaných prostředků</span><span class="sxs-lookup"><span data-stu-id="6e9f4-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="6e9f4-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="6e9f4-194">Nothing</span></span>](../../../../visual-basic/language-reference/nothing.md)
