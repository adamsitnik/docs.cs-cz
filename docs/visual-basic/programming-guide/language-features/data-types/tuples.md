---
title: Řazené kolekce členů v jazyce Visual Basic
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: 146e9c2360cea153d2f487769d5b983516861e8d
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54694724"
---
# <a name="tuples-visual-basic"></a><span data-ttu-id="d5d49-102">Řazené kolekce členů (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="d5d49-102">Tuples (Visual Basic)</span></span>

<span data-ttu-id="d5d49-103">Počínaje rokem 2017 jazyka Visual Basic, jazyka Visual Basic nabízí vestavěnou podporu pro řazené kolekce členů, díky vytváření řazených kolekcí členů a přístupu k prvkům jednodušší řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-103">Starting with Visual Basic 2017, the Visual Basic language offers built-in support for tuples that makes creating tuples and accessing the elements of tuples easier.</span></span> <span data-ttu-id="d5d49-104">Řazená kolekce členů je odlehčené datová struktura, která má určitý počet a pořadí hodnot.</span><span class="sxs-lookup"><span data-stu-id="d5d49-104">A tuple is a light-weight data structure that has a specific number and sequence of values.</span></span> <span data-ttu-id="d5d49-105">Při vytváření instance řazené kolekce členů, můžete definovat počtu a typu dat každé hodnoty (nebo element).</span><span class="sxs-lookup"><span data-stu-id="d5d49-105">When you instantiate the tuple, you define the number and the data type of each value (or element).</span></span> <span data-ttu-id="d5d49-106">Například 2 řazené kolekce členů (nebo dvojice) obsahuje dva elementy.</span><span class="sxs-lookup"><span data-stu-id="d5d49-106">For example, a 2-tuple (or pair) has two elements.</span></span> <span data-ttu-id="d5d49-107">Může být první `Boolean` hodnoty, zatímco druhá je `String`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-107">The first might be a `Boolean` value, while the second is a `String`.</span></span> <span data-ttu-id="d5d49-108">Protože řazených kolekcí členů usnadňují uložení více hodnot v jednom objektu, často se používají jako jednoduchý způsob, jak vrátit více hodnot z metody.</span><span class="sxs-lookup"><span data-stu-id="d5d49-108">Because tuples make it easy to store multiple values in a single object, they are often used as a lightweight way to return multiple values from a method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d5d49-109">Podpora řazené kolekce členů vyžaduje <xref:System.ValueTuple> typu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-109">Tuple support requires the <xref:System.ValueTuple> type.</span></span> <span data-ttu-id="d5d49-110">Pokud není nainstalované rozhraní .NET Framework 4.7, je nutné přidat balíček NuGet `System.ValueTuple`, která je dostupná v galerii NuGet.</span><span class="sxs-lookup"><span data-stu-id="d5d49-110">If the .NET Framework 4.7 is not installed, you must add the NuGet package `System.ValueTuple`, which is available on the NuGet Gallery.</span></span> <span data-ttu-id="d5d49-111">Bez tohoto balíčku můžete obdržet chybu kompilace podobný "Předdefinovaný typ 'ValueTuple(Of,,,)' není definován ani importován."</span><span class="sxs-lookup"><span data-stu-id="d5d49-111">Without this package, you may get a compilation error similar to, "Predefined type 'ValueTuple(Of,,,)' is not defined or imported."</span></span>

## <a name="instantiating-and-using-a-tuple"></a><span data-ttu-id="d5d49-112">Vytváření instancí a použití řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="d5d49-112">Instantiating and using a tuple</span></span>

<span data-ttu-id="d5d49-113">Řazená kolekce členů instance uzavřením jeho závorky zasílání rychlých zpráv hodnot oddělených čárkami.</span><span class="sxs-lookup"><span data-stu-id="d5d49-113">You instantiate a tuple by enclosing its comma-delimited values im parentheses.</span></span> <span data-ttu-id="d5d49-114">Každá z těchto hodnot se pak stane polem řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-114">Each of those values then becomes a field of the tuple.</span></span> <span data-ttu-id="d5d49-115">Například následující kód definuje triple (nebo 3 řazené kolekce členů) s `Date` jako první hodnota, `String` jako jeho druhé a `Boolean` jako jeho třetí.</span><span class="sxs-lookup"><span data-stu-id="d5d49-115">For example, the following code defines a triple (or 3-tuple) with a `Date` as its first value, a `String` as its second, and a `Boolean` as its third.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

<span data-ttu-id="d5d49-116">Ve výchozím nastavení, název každé pole v řazené kolekce členů se skládá z řetězce `Item` spolu s pole založen na jedničce pozici v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-116">By default, the name of each field in a tuple consists of the string `Item` along with the field's one-based position in the tuple.</span></span> <span data-ttu-id="d5d49-117">Pro tento 3-řazené kolekce členů `Date` pole je `Item1`, `String` pole je `Item2`a `Boolean` pole je `Item3`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-117">For this 3-tuple, the `Date` field is `Item1`, the `String` field is `Item2`, and the `Boolean` field is `Item3`.</span></span> <span data-ttu-id="d5d49-118">Následující příklad zobrazí hodnoty polí řazené kolekce členů v předchozí řádek kódu</span><span class="sxs-lookup"><span data-stu-id="d5d49-118">The following example displays the values of fields of the tuple instantiated in the previous line of code</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

<span data-ttu-id="d5d49-119">Čtení a zápis; jsou pole řazená kolekce členů jazyka Visual Basic poté, co jste se vytvořit instanci řazené kolekce členů, můžete její hodnoty upravit.</span><span class="sxs-lookup"><span data-stu-id="d5d49-119">The fields of a Visual Basic tuple are read-write; after you've instantiated a tuple, you can modify its values.</span></span> <span data-ttu-id="d5d49-120">Následující příklad upraví dva ze tří polí řazené kolekce členů v předchozím příkladu vytvoří a zobrazí výsledek.</span><span class="sxs-lookup"><span data-stu-id="d5d49-120">The following example modifies two of the three fields of the tuple created in the previous example and displays the result.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a><span data-ttu-id="d5d49-121">Vytváření instancí a použití pojmenované řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="d5d49-121">Instantiating and using a named tuple</span></span>

<span data-ttu-id="d5d49-122">Místo používání výchozích názvů polí se řazená kolekce členů, můžete vytvořit instanci *řazené kolekce členů s názvem* přiřazením vlastní názvy prvků řazené.</span><span class="sxs-lookup"><span data-stu-id="d5d49-122">Rather than using default names for a tuple's fields, you can instantiate a *named tuple* by assigning your own names to the tuple's elements.</span></span> <span data-ttu-id="d5d49-123">Řazené pole lze poté přistupovat podle jejich přiřazené názvů *nebo* podle jejich výchozími názvy.</span><span class="sxs-lookup"><span data-stu-id="d5d49-123">The tuple's fields can then be accessed by their assigned names *or* by their default names.</span></span> <span data-ttu-id="d5d49-124">Následující příklad vytvoří instanci stejného 3-řazené kolekce členů jako dříve, s tím rozdílem, že explicitně názvy první pole `EventDate`, druhý `Name`a třetí `IsHoliday`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-124">The following example instantiates the same 3-tuple as previously, except that it explicitly names the first field `EventDate`, the second `Name`, and the third `IsHoliday`.</span></span> <span data-ttu-id="d5d49-125">Potom zobrazí hodnoty polí, upraví je a znovu zobrazí hodnoty polí.</span><span class="sxs-lookup"><span data-stu-id="d5d49-125">It then displays the field values, modifies them, and displays the field values again.</span></span>

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a><span data-ttu-id="d5d49-126">Názvy elementů řazené kolekce členů odvozeného</span><span class="sxs-lookup"><span data-stu-id="d5d49-126">Inferred tuple element names</span></span>

<span data-ttu-id="d5d49-127">Od verze 15.3 jazyka Visual Basic, Visual Basic lze odvodit názvy prvků řazené kolekce členů. není nutné je explicitně přiřadit.</span><span class="sxs-lookup"><span data-stu-id="d5d49-127">Starting with Visual Basic 15.3, Visual Basic can infer the names of tuple elements; you do not have to assign them explicitly.</span></span> <span data-ttu-id="d5d49-128">Názvy odvozené řazené kolekce členů jsou užitečné při inicializaci řazenou kolekci členů ze skupiny proměnných, a chcete, aby název elementu řazené kolekce členů bude stejný jako název proměnné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-128">Inferred tuple names are useful when you initialize a tuple from a set of variables, and you want the tuple element name to be the same as the variable name.</span></span> 

<span data-ttu-id="d5d49-129">Následující příklad vytvoří `stateInfo` řazené kolekce členů, která obsahuje tři explicitně pojmenované elementy, `state`, `stateName`, a `capital`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-129">The following example creates a `stateInfo` tuple that contains three explicitly named elements, `state`, `stateName`, and `capital`.</span></span> <span data-ttu-id="d5d49-130">Všimněte si, že názvů elementů, příkaz inicializace řazené kolekce členů jednoduše přiřadí pojmenované elementy hodnoty proměnných identicky pojmenovanou.</span><span class="sxs-lookup"><span data-stu-id="d5d49-130">Note that, in naming the elements, the tuple initialization statement simply assigns the named elements the values of the identically named variables.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]
 
<span data-ttu-id="d5d49-131">Protože elementy a proměnné mají stejný název, Visual Basic kompilátor může odvodit názvy polí, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="d5d49-131">Because elements and variables have the same name, the Visual Basic compiler can infer the names of the fields, as the following example shows.</span></span>

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="d5d49-132">Povolit názvy elementů řazené kolekce členů odvozené, je nutné definovat verzi kompilátoru jazyka Visual Basic pro použití v projektu jazyka Visual Basic (\*.vbproj) souboru:</span><span class="sxs-lookup"><span data-stu-id="d5d49-132">To enable inferred tuple element names, you must define the version of the Visual Basic compiler to use in your Visual Basic project (\*.vbproj) file:</span></span> 

```xml 
<PropertyGroup> 
  <LangVersion>15.3</LangVersion> 
</PropertyGroup> 
```

<span data-ttu-id="d5d49-133">Číslo verze může být jakékoli verzi kompilátoru jazyka Visual Basic od verze 15.3.</span><span class="sxs-lookup"><span data-stu-id="d5d49-133">The version number can be any version of the Visual Basic compiler starting with 15.3.</span></span> <span data-ttu-id="d5d49-134">Místo pevného kódování specifické verzi kompilátoru, můžete také zadat "Poslední zálohy" jako hodnotu `LangVersion` ke kompilaci v nejnovější verzi kompilátoru jazyka Visual Basic, který je nainstalovaný ve vašem systému.</span><span class="sxs-lookup"><span data-stu-id="d5d49-134">Rather than hard-coding a specific compiler version, you can also specify "Latest" as the value of `LangVersion` to compile with the most recent version of the Visual Basic compiler installed on your system.</span></span>

<span data-ttu-id="d5d49-135">Další informace najdete v tématu [nastavení verze jazyka Visual Basic](../../../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="d5d49-135">For more information, see [setting the Visual Basic language version](../../../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="d5d49-136">V některých případech kompilátor jazyka Visual Basic nelze odvodit název elementu řazené kolekce členů z názvu Release candidate a pole řazené kolekce členů může být odkazováno pouze pomocí jeho výchozí název, například `Item1`, `Item2`atd. Zde jsou některé z nich:</span><span class="sxs-lookup"><span data-stu-id="d5d49-136">In some cases, the Visual Basic compiler cannot infer the tuple element name from the candidate name, and the tuple field can only be referenced using its default name, such as `Item1`, `Item2`, etc. These include:</span></span>

- <span data-ttu-id="d5d49-137">Název Release candidate je stejný jako název člena řazené kolekce členů jako `Item3`, `Rest`, nebo `ToString`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-137">The candidate name is the same as the name of a tuple member, such as `Item3`, `Rest`, or `ToString`.</span></span>

- <span data-ttu-id="d5d49-138">Název Release candidate je duplicitní v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-138">The candidate name is duplicated in the tuple.</span></span>
 
<span data-ttu-id="d5d49-139">Po odvození název pole selže, Visual Basic nevygeneruje chybu kompilátoru, ani je výjimka vyvolána v době běhu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-139">When field name inference fails, Visual Basic does not generate a compiler error, nor is an exception thrown at runtime.</span></span> <span data-ttu-id="d5d49-140">Místo toho pole řazené kolekce členů musí být referencován předdefinované názvy, například `Item1` a `Item2`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-140">Instead, tuple fields must be referenced by their predefined names, such as `Item1` and `Item2`.</span></span> 
  
## <a name="tuples-versus-structures"></a><span data-ttu-id="d5d49-141">Řazených kolekcí členů a struktury</span><span class="sxs-lookup"><span data-stu-id="d5d49-141">Tuples versus structures</span></span>

<span data-ttu-id="d5d49-142">Řazená kolekce členů jazyka Visual Basic je hodnotový typ, který je instance jednoho z **System.ValueTuple** obecných typů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-142">A Visual Basic tuple is a value type that is an instance of one of the a **System.ValueTuple** generic types.</span></span> <span data-ttu-id="d5d49-143">Například `holiday` řazené kolekce členů definované v předchozím příkladu je instance <xref:System.ValueTuple%603> struktury.</span><span class="sxs-lookup"><span data-stu-id="d5d49-143">For example, the `holiday` tuple defined in the previous example is an instance of the <xref:System.ValueTuple%603> structure.</span></span> <span data-ttu-id="d5d49-144">To je navržena jako jednoduchý kontejner pro data.</span><span class="sxs-lookup"><span data-stu-id="d5d49-144">It is designed to be a lightweight container for data.</span></span> <span data-ttu-id="d5d49-145">Protože řazené kolekce členů, zaměřuje na snadno vytvořit objekt s více datovými položkami, chybí některé z funkcí, které může mít vlastní struktury.</span><span class="sxs-lookup"><span data-stu-id="d5d49-145">Since the tuple aims to make it easy to create an object with multiple data items, it lacks some of the features that a custom structure might have.</span></span> <span data-ttu-id="d5d49-146">Zde jsou některé z nich:</span><span class="sxs-lookup"><span data-stu-id="d5d49-146">These include:</span></span>

- <span data-ttu-id="d5d49-147">Vlastní členy.</span><span class="sxs-lookup"><span data-stu-id="d5d49-147">Custom members.</span></span> <span data-ttu-id="d5d49-148">Nelze definovat vlastní vlastnosti, metody nebo události pro řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-148">You cannot define your own properties, methods, or events for a tuple.</span></span>

- <span data-ttu-id="d5d49-149">Ověření.</span><span class="sxs-lookup"><span data-stu-id="d5d49-149">Validation.</span></span> <span data-ttu-id="d5d49-150">Nelze ověřit data přiřazeny k polím.</span><span class="sxs-lookup"><span data-stu-id="d5d49-150">You cannot validate the data assigned to fields.</span></span>

- <span data-ttu-id="d5d49-151">Neměnnost.</span><span class="sxs-lookup"><span data-stu-id="d5d49-151">Immutability.</span></span> <span data-ttu-id="d5d49-152">Řazené kolekce členů jazyka Visual Basic jsou měnitelné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-152">Visual Basic tuples are mutable.</span></span> <span data-ttu-id="d5d49-153">Naproti tomu vlastní struktury umožňuje řídit, jestli je instance proměnlivé nebo neměnné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-153">In contrast, a custom structure allows you to control whether an instance is mutable or immutable.</span></span>

<span data-ttu-id="d5d49-154">Pokud vlastními členy, vlastnost a pole ověření nebo neměnnosti jsou důležité, abyste používali jazyka Visual Basic [struktura](../../../language-reference/statements/structure-statement.md) příkaz k definování vlastní hodnotového typu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-154">If custom members, property and field validation, or immutability are important, you should use the Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) statement to define a custom value type.</span></span>

<span data-ttu-id="d5d49-155">Řazená kolekce členů jazyka Visual Basic dědí členy jeho **typu ValueTuple** typu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-155">A Visual Basic tuple does inherit the members of its **ValueTuple** type.</span></span> <span data-ttu-id="d5d49-156">Kromě polí patří mezi ně následující metody:</span><span class="sxs-lookup"><span data-stu-id="d5d49-156">In addition to its fields, these include the following methods:</span></span>

| <span data-ttu-id="d5d49-157">Člen</span><span class="sxs-lookup"><span data-stu-id="d5d49-157">Member</span></span> | <span data-ttu-id="d5d49-158">Popis</span><span class="sxs-lookup"><span data-stu-id="d5d49-158">Description</span></span> |
| ---|---|
| <span data-ttu-id="d5d49-159">CompareTo</span><span class="sxs-lookup"><span data-stu-id="d5d49-159">CompareTo</span></span> | <span data-ttu-id="d5d49-160">Porovná aktuální řazenou kolekci členů na jiné řazené kolekce členů se stejný počet prvků.</span><span class="sxs-lookup"><span data-stu-id="d5d49-160">Compares the current tuple to another tuple with the same number of elements.</span></span> |
| <span data-ttu-id="d5d49-161">Je rovno</span><span class="sxs-lookup"><span data-stu-id="d5d49-161">Equals</span></span> | <span data-ttu-id="d5d49-162">Určuje, zda se k jinému řazené kolekce členů nebo objekt rovná aktuální řazenou kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-162">Determines whether the current tuple is equal to another tuple or object.</span></span> |
| <span data-ttu-id="d5d49-163">GetHashCode</span><span class="sxs-lookup"><span data-stu-id="d5d49-163">GetHashCode</span></span> | <span data-ttu-id="d5d49-164">Vypočítá kód hash pro aktuální instanci.</span><span class="sxs-lookup"><span data-stu-id="d5d49-164">Calculates the hash code for the current instance.</span></span> |
| <span data-ttu-id="d5d49-165">ToString</span><span class="sxs-lookup"><span data-stu-id="d5d49-165">ToString</span></span> | <span data-ttu-id="d5d49-166">Vrátí řetězcovou reprezentaci této řazené kolekce členů, který má podobu `(Item1, Item2...)`, kde `Item1` a `Item2` představují hodnoty řazené pole.</span><span class="sxs-lookup"><span data-stu-id="d5d49-166">Returns the string representation of this tuple, which takes the form `(Item1, Item2...)`, where `Item1` and `Item2` represent the values of the tuple's fields.</span></span> |

<span data-ttu-id="d5d49-167">Kromě toho **typu ValueTuple** typy implementovat <xref:System.Collections.IStructuralComparable> a <xref:System.Collections.IStructuralEquatable> rozhraní, které umožňují definovat komparátory zákazníka.</span><span class="sxs-lookup"><span data-stu-id="d5d49-167">In addition, the **ValueTuple** types implement <xref:System.Collections.IStructuralComparable> and <xref:System.Collections.IStructuralEquatable> interfaces, which allow you to define customer comparers.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="d5d49-168">Přiřazení a řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="d5d49-168">Assignment and tuples</span></span>

<span data-ttu-id="d5d49-169">Visual Basic podporuje přiřazení mezi typy řazené kolekce členů, které mají stejný počet polí.</span><span class="sxs-lookup"><span data-stu-id="d5d49-169">Visual Basic supports assignment between tuple types that have the same number of fields.</span></span> <span data-ttu-id="d5d49-170">Typy pole lze převést, pokud platí jedna z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="d5d49-170">The field types can be converted if one of the following is true:</span></span>

- <span data-ttu-id="d5d49-171">Zdrojové a cílové pole je stejného typu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-171">The source and target field are of the same type.</span></span>

- <span data-ttu-id="d5d49-172">Rozšiřující (nebo implicitní) převod zdrojového typu na cílový typ je definován.</span><span class="sxs-lookup"><span data-stu-id="d5d49-172">A widening (or implicit) conversion of the source type to the target type is defined.</span></span> 

- <span data-ttu-id="d5d49-173">`Option Strict` je `On`, a převod zužující (nebo explicitní) typem zdroje na cílový typ je definován.</span><span class="sxs-lookup"><span data-stu-id="d5d49-173">`Option Strict` is `On`, and a narrowing (or explicit) conversion of the source type to the target type is defined.</span></span> <span data-ttu-id="d5d49-174">Tento převod může vyvolat výjimku, pokud zdrojová hodnota je mimo rozsah cílového typu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-174">This conversion can throw an exception if the source value is outside the range of the target type.</span></span>

<span data-ttu-id="d5d49-175">Ostatní převody, které nejsou považované za pro přiřazení.</span><span class="sxs-lookup"><span data-stu-id="d5d49-175">Other conversions are not considered for assignments.</span></span> <span data-ttu-id="d5d49-176">Pojďme se podívat na typy přiřazení, které jsou povolené mezi typy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-176">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="d5d49-177">Vezměte v úvahu tyto proměnné, používat v následujících příkladech:</span><span class="sxs-lookup"><span data-stu-id="d5d49-177">Consider these variables used in the following examples:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

<span data-ttu-id="d5d49-178">První dvě proměnné `unnamed` a `anonymous`, nemají sémantické názvy, které jsou k dispozici pro pole.</span><span class="sxs-lookup"><span data-stu-id="d5d49-178">The first two variables, `unnamed` and `anonymous`, do not have semantic names provided for the fields.</span></span> <span data-ttu-id="d5d49-179">Jejich názvy polí jsou výchozí `Item1` a `Item2`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-179">Their field names are the default `Item1` and `Item2`.</span></span> <span data-ttu-id="d5d49-180">Poslední dvě proměnné, `named` a `differentName` mají názvy sémantické pole.</span><span class="sxs-lookup"><span data-stu-id="d5d49-180">The last two variables, `named` and `differentName` have semantic field names.</span></span> <span data-ttu-id="d5d49-181">Všimněte si, že tyto dvě řazené kolekce členů mají různé názvy polí.</span><span class="sxs-lookup"><span data-stu-id="d5d49-181">Note that these two tuples have different names for the fields.</span></span>

<span data-ttu-id="d5d49-182">Všechny čtyři tyto řazených kolekcí členů mají stejný počet polí (dále jako "Arita") a typy těchto polí jsou identické.</span><span class="sxs-lookup"><span data-stu-id="d5d49-182">All four of these tuples have the same number of fields (referred to as 'arity'), and the types of those fields are identical.</span></span> <span data-ttu-id="d5d49-183">Proto všechny tato přiřazení práce:</span><span class="sxs-lookup"><span data-stu-id="d5d49-183">Therefore, all of these assignments work:</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

<span data-ttu-id="d5d49-184">Všimněte si, že nejsou přiřazeny názvy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-184">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="d5d49-185">Hodnoty polí jsou přiřazeny následující pořadí polí v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-185">The values of the fields are assigned following the order of the fields in the tuple.</span></span>

<span data-ttu-id="d5d49-186">Konečně si všimněte, že můžeme přiřadit `named` řazená kolekce členů k `conversion` řazené kolekce členů, i v případě, první pole `named` je `Integer`a na první pole `conversion` je `Long`.</span><span class="sxs-lookup"><span data-stu-id="d5d49-186">Finally, notice that we can assign the `named` tuple to the `conversion` tuple, even though the first field of `named` is an `Integer`, and the first field of `conversion` is a `Long`.</span></span> <span data-ttu-id="d5d49-187">Toto přiřazení bude úspěšné, protože převod `Integer` k `Long` je rozšiřující převod.</span><span class="sxs-lookup"><span data-stu-id="d5d49-187">This assignment succeeds because converting an `Integer` to a `Long` is a widening conversion.</span></span>

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

<span data-ttu-id="d5d49-188">Řazené kolekce členů s různými počty polí nejsou přiřadit:</span><span class="sxs-lookup"><span data-stu-id="d5d49-188">Tuples with different numbers of fields are not assignable:</span></span>

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="d5d49-189">Řazené kolekce členů jako návratové hodnoty metod</span><span class="sxs-lookup"><span data-stu-id="d5d49-189">Tuples as method return values</span></span>

<span data-ttu-id="d5d49-190">Metoda může vrátit pouze jednu hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-190">A method can return only a single value.</span></span> <span data-ttu-id="d5d49-191">Často ale chcete volání metody vrátí více hodnot.</span><span class="sxs-lookup"><span data-stu-id="d5d49-191">Frequently, though, you'd like a method call to return multiple values.</span></span> <span data-ttu-id="d5d49-192">Toto omezení vyřešit několika způsoby:</span><span class="sxs-lookup"><span data-stu-id="d5d49-192">There are several ways to work around this limitation:</span></span>

- <span data-ttu-id="d5d49-193">Můžete vytvořit vlastní třídu nebo strukturu, jejíž vlastnosti nebo pole představují hodnoty vrácený metodou.</span><span class="sxs-lookup"><span data-stu-id="d5d49-193">You can create a custom class or structure whose properties or fields represent values returned by the method.</span></span> <span data-ttu-id="d5d49-194">Proto je těžký řešení; vyžaduje, že definujete vlastní typ, jehož jediným účelem je k načtení hodnoty z volání metody.</span><span class="sxs-lookup"><span data-stu-id="d5d49-194">Thus is a heavyweight solution; it requires that you define a custom type whose only purpose is to retrieve values from a method call.</span></span>

- <span data-ttu-id="d5d49-195">Můžete vracet jedinou hodnotu z metody a vrátit zbývající hodnoty byly předány podle odkazu na metodu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-195">You can return a single value from the method, and return the remaining values by passing them by reference to the method.</span></span> <span data-ttu-id="d5d49-196">To zahrnuje vytvoření instance proměnné a rizika nechtěném přepsání hodnotu proměnné, která se předávají odkazem režii.</span><span class="sxs-lookup"><span data-stu-id="d5d49-196">This involves the overhead of instantiating a variable and risks inadvertently overwriting the value of the variable that you pass by reference.</span></span>

- <span data-ttu-id="d5d49-197">Můžete použít řazenou kolekci členů, které poskytuje jednoduché řešení, které načítají více návratových hodnot.</span><span class="sxs-lookup"><span data-stu-id="d5d49-197">You can use a tuple, which provides a lightweight solution to retrieving multiple return values.</span></span>

<span data-ttu-id="d5d49-198">Například **TryParse** metody v rozhraní .NET vrátit `Boolean` hodnotu, která určuje, zda operace analýzy proběhla úspěšně.</span><span class="sxs-lookup"><span data-stu-id="d5d49-198">For example, the **TryParse** methods in .NET return a `Boolean` value that indicates whether the parsing operation succeeded.</span></span> <span data-ttu-id="d5d49-199">Výsledek operace analýzy je vrácen do proměnné předány podle odkazu na metodu.</span><span class="sxs-lookup"><span data-stu-id="d5d49-199">The result of the parsing operation is returned in a variable passed by reference to the method.</span></span> <span data-ttu-id="d5d49-200">Za normálních okolností volání metody analýzy jako <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> vypadá podobně jako následující:</span><span class="sxs-lookup"><span data-stu-id="d5d49-200">Normally, a call to the a parsing method such as <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> looks like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

<span data-ttu-id="d5d49-201">My jsme zabalte volání do vrátit řazené kolekce členů z operace analýzy <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> metoda v naší metodě.</span><span class="sxs-lookup"><span data-stu-id="d5d49-201">We can return a tuple from the parsing operation if we wrap the call to the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method in our own method.</span></span> <span data-ttu-id="d5d49-202">V následujícím příkladu `NumericLibrary.ParseInteger` volání <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> metodu a vrátí pojmenované řazené kolekce členů se dvěma elementy.</span><span class="sxs-lookup"><span data-stu-id="d5d49-202">In the following example, `NumericLibrary.ParseInteger` calls the <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> method and returns a named tuple with two elements.</span></span> 

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="d5d49-203">Pak můžete volat metodu s kódem, jako je následující:</span><span class="sxs-lookup"><span data-stu-id="d5d49-203">You can then call the method with code like the following:</span></span>

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a><span data-ttu-id="d5d49-204">Visual Basic řazených kolekcí členů a řazenými kolekcemi členů v rozhraní .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d5d49-204">Visual Basic tuples and tuples in the .NET Framework</span></span>

<span data-ttu-id="d5d49-205">Řazená kolekce členů jazyka Visual Basic je instance jednoho z **System.ValueTuple** obecné typy, které byly zavedeny v rozhraní .NET Framework 4.7.</span><span class="sxs-lookup"><span data-stu-id="d5d49-205">A Visual Basic tuple is an instance of one of the **System.ValueTuple** generic types, which were introduced in the .NET Framework 4.7.</span></span> <span data-ttu-id="d5d49-206">Rozhraní .NET Framework obsahuje také sadu obecného **System.Tuple** třídy.</span><span class="sxs-lookup"><span data-stu-id="d5d49-206">The .NET Framework also includes a set of generic **System.Tuple** classes.</span></span> <span data-ttu-id="d5d49-207">Tyto třídy, ale liší od řazených kolekcí členů jazyka Visual Basic a **System.ValueTuple** obecné typy v několika způsoby:</span><span class="sxs-lookup"><span data-stu-id="d5d49-207">These classes, however, differ from Visual Basic tuples and the **System.ValueTuple** generic types in a number of ways:</span></span>

- <span data-ttu-id="d5d49-208">Prvky **řazené kolekce členů** třídy jsou vlastnosti s názvem `Item1`, `Item2`, a tak dále.</span><span class="sxs-lookup"><span data-stu-id="d5d49-208">The elements of the **Tuple** classes are properties named `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="d5d49-209">V jazyce Visual Basic řazených kolekcí členů a **typu ValueTuple** typy elementů řazené kolekce členů jsou pole.</span><span class="sxs-lookup"><span data-stu-id="d5d49-209">In Visual Basic tuples and the **ValueTuple** types, tuple elements are fields.</span></span>

- <span data-ttu-id="d5d49-210">Elementy nelze přiřadit smysluplné názvy **řazené kolekce členů** instance nebo **typu ValueTuple** instance.</span><span class="sxs-lookup"><span data-stu-id="d5d49-210">You cannot assign meaningful names to the elements of a **Tuple** instance or of a **ValueTuple** instance.</span></span> <span data-ttu-id="d5d49-211">Visual Basic umožňuje přiřadit názvy, které sdělit význam pole.</span><span class="sxs-lookup"><span data-stu-id="d5d49-211">Visual Basic allows you to assign names that communicate the meaning of the fields.</span></span>

- <span data-ttu-id="d5d49-212">Vlastnosti **řazené kolekce členů** instance jsou jen pro čtení; řazené kolekce členů jsou neměnné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-212">The properties of a **Tuple** instance are read-only; the tuples are immutable.</span></span> <span data-ttu-id="d5d49-213">V jazyce Visual Basic řazených kolekcí členů a **typu ValueTuple** typy, pole řazené kolekce členů jsou pro čtení i zápis; řazené kolekce členů jsou měnitelné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-213">In Visual Basic tuples and the **ValueTuple** types, tuple fields are read-write; the tuples are mutable.</span></span>

- <span data-ttu-id="d5d49-214">Obecné **řazené kolekce členů** typy jsou typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-214">The generic **Tuple** types are reference types.</span></span> <span data-ttu-id="d5d49-215">Použití těchto **řazené kolekce členů** typy znamená, že přidělování objektů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-215">Using these **Tuple** types means allocating objects.</span></span> <span data-ttu-id="d5d49-216">V horké cesty to může být měřitelný dopad na výkon vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="d5d49-216">On hot paths, this can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="d5d49-217">Visual Basic řazených kolekcí členů a **typu ValueTuple** typy jsou typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="d5d49-217">Visual Basic tuples and the **ValueTuple** types are value types.</span></span>

<span data-ttu-id="d5d49-218">Rozšiřující metody v <xref:System.TupleExtensions> třídy usnadňují převod mezi řazenými kolekcemi členů jazyka Visual Basic a .NET **řazené kolekce členů** objekty.</span><span class="sxs-lookup"><span data-stu-id="d5d49-218">Extension methods in the <xref:System.TupleExtensions> class make it easy to convert between Visual Basic tuples and .NET **Tuple** objects.</span></span> <span data-ttu-id="d5d49-219">**ToTuple** metoda převede řazené kolekce členů jazyka Visual Basic .NET **řazené kolekce členů** objektu a **ToValueTuple** metoda převede .NET **řazené kolekce členů** objekt řazené kolekce členů jazyka Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="d5d49-219">The **ToTuple** method converts a Visual Basic tuple to a .NET **Tuple** object, and the **ToValueTuple** method converts a .NET **Tuple** object to a Visual Basic tuple.</span></span>

<span data-ttu-id="d5d49-220">Následující příklad vytvoří řazenou kolekci členů, převede ho na .NET **řazené kolekce členů** objektu a převede ho zpátky do jazyka Visual Basic řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="d5d49-220">The following example creates a tuple, converts it to a .NET **Tuple** object, and converts it back to a Visual Basic tuple.</span></span> <span data-ttu-id="d5d49-221">Příklad poté porovnává této řazené kolekce členů s původní, abyste zajistili, že jsou shodné.</span><span class="sxs-lookup"><span data-stu-id="d5d49-221">The example then compares this tuple with the original one to ensure that they are equal.</span></span>

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a><span data-ttu-id="d5d49-222">Viz také:</span><span class="sxs-lookup"><span data-stu-id="d5d49-222">See also</span></span>

- [<span data-ttu-id="d5d49-223">Referenční příručka jazyka Visual Basic</span><span class="sxs-lookup"><span data-stu-id="d5d49-223">Visual Basic Language Reference</span></span>](index.md)
