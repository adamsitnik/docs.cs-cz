---
title: Základy výrazů dotazů (LINQ v JAZYKU C#)
description: Představuje koncepty související s výrazy dotazu
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 96ef75fe702e60eaa38acef77a73a5ea7f2076f4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/23/2019
ms.locfileid: "61688602"
---
# <a name="query-expression-basics"></a><span data-ttu-id="e0eef-103">Základy výrazů dotazů</span><span class="sxs-lookup"><span data-stu-id="e0eef-103">Query expression basics</span></span>

<span data-ttu-id="e0eef-104">Tento článek představuje základní koncepty související s výrazy dotazů v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="e0eef-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="e0eef-105">Co je dotaz a co to dělá?</span><span class="sxs-lookup"><span data-stu-id="e0eef-105">What is a query and what does it do?</span></span>

<span data-ttu-id="e0eef-106">A *dotazu* je sada instrukcí, které popisují, jaká data pro načtení do daného zdroje dat (nebo zdroje) a jaké tvar a organizaci by měl mít vrácená data.</span><span class="sxs-lookup"><span data-stu-id="e0eef-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="e0eef-107">Dotaz se liší od výsledky, které vytvoří.</span><span class="sxs-lookup"><span data-stu-id="e0eef-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="e0eef-108">Obecně platí zdroj dat je logicky uspořádaná jako sekvenci prvků stejného typu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="e0eef-109">Například tabulky databáze SQL obsahuje posloupnosti řádků.</span><span class="sxs-lookup"><span data-stu-id="e0eef-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="e0eef-110">V souboru XML je "sekvence" elementů XML (i když tyto funkce jsou uspořádané hierarchicky ve stromové struktuře).</span><span class="sxs-lookup"><span data-stu-id="e0eef-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="e0eef-111">Kolekci v paměť obsahuje pouze sekvenci objektů.</span><span class="sxs-lookup"><span data-stu-id="e0eef-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="e0eef-112">Z hlediska aplikace konkrétní typ a strukturu původní zdroj dat není důležité.</span><span class="sxs-lookup"><span data-stu-id="e0eef-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="e0eef-113">Aplikace vždy zobrazí zdroj dat jako <xref:System.Collections.Generic.IEnumerable%601> nebo <xref:System.Linq.IQueryable%601> kolekce.</span><span class="sxs-lookup"><span data-stu-id="e0eef-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="e0eef-114">Například v technologii LINQ to XML, zdrojová data jsou dostupná jako `IEnumerable` \< <xref:System.Xml.Linq.XElement>>.</span><span class="sxs-lookup"><span data-stu-id="e0eef-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="e0eef-115">Zadaný této zdrojové sekvence, dotaz může proveďte jednu z tři věci:</span><span class="sxs-lookup"><span data-stu-id="e0eef-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="e0eef-116">Načtení podmnožiny prvků k vytvoření nového pořadí beze změny jednotlivé prvky.</span><span class="sxs-lookup"><span data-stu-id="e0eef-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="e0eef-117">Dotaz může pak řazení nebo seskupení vrácené posloupnosti různými způsoby, jak je znázorněno v následujícím příkladu (Předpokládejme `scores` je `int[]`):</span><span class="sxs-lookup"><span data-stu-id="e0eef-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="e0eef-118">Načíst řadu prvků, jako v předchozím příkladu, ale transformují je na nový typ objektu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="e0eef-119">Například dotaz může načíst pouze poslední názvy z určité záznamy o zákaznících ve zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="e0eef-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="e0eef-120">Nebo může načíst úplný záznam a pak přes ni vytvořit jiného typu objektů v paměti do mezipaměti nebo dokonce data XML před generováním pořadí konečný výsledek.</span><span class="sxs-lookup"><span data-stu-id="e0eef-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="e0eef-121">Následující příklad ukazuje projekce ze `int` k `string`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="e0eef-122">Všimněte si nového typu `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="e0eef-123">Načtěte hodnotu singleton zdrojových dat, jako například:</span><span class="sxs-lookup"><span data-stu-id="e0eef-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="e0eef-124">Počet prvků, které splňují určité podmínky.</span><span class="sxs-lookup"><span data-stu-id="e0eef-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="e0eef-125">Prvek, který má nejvyšší či nejnižší hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="e0eef-126">První prvek, který odpovídá podmínce nebo součet konkrétní hodnoty v zadané sadě prvků.</span><span class="sxs-lookup"><span data-stu-id="e0eef-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="e0eef-127">Například následující dotaz vrátí počet skóre větší než 80 z `scores` celočíselné pole:</span><span class="sxs-lookup"><span data-stu-id="e0eef-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="e0eef-128">V předchozím příkladu, Všimněte si použití závorek okolo výrazu dotazu před voláním `Count` metody.</span><span class="sxs-lookup"><span data-stu-id="e0eef-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="e0eef-129">To lze vyjádřit pomocí nové proměnné k ukládání konkrétních výsledků.</span><span class="sxs-lookup"><span data-stu-id="e0eef-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="e0eef-130">Tato technika je lépe čitelný, protože udržuje odděleně od dotaz, který ukládá výsledek proměnné, která ukládá dotaz.</span><span class="sxs-lookup"><span data-stu-id="e0eef-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="e0eef-131">V předchozím příkladu je dotaz proveden při volání funkce `Count`, protože `Count` musí iteraci přes výsledky, aby bylo možné zjistit počet prvků vrácených `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="e0eef-132">Co je výraz dotazu?</span><span class="sxs-lookup"><span data-stu-id="e0eef-132">What is a query expression?</span></span>

<span data-ttu-id="e0eef-133">A *výrazu dotazu* je dotaz vyjádřené v syntaxi dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="e0eef-134">Výraz dotazu je typů prvotřídní jazykové konstrukce.</span><span class="sxs-lookup"><span data-stu-id="e0eef-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="e0eef-135">Je stejně jako libovolný jiný výraz a je možné v libovolném kontextu, ve kterém je platný výraz jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="e0eef-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="e0eef-136">Výraz dotazu obsahuje sadu klauzulí napsané v deklarativní syntaxe podobně jako SQL nebo výraz XQuery.</span><span class="sxs-lookup"><span data-stu-id="e0eef-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="e0eef-137">Každou klauzuli zase obsahuje jeden nebo více výrazy jazyka C# a tyto výrazy mohou sami být výrazu dotazu nebo obsahovat výraz dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="e0eef-138">Výraz dotazu musí začínat [z](../language-reference/keywords/from-clause.md) klauzule a musí končit [vyberte](../language-reference/keywords/select-clause.md) nebo [skupiny](../language-reference/keywords/group-clause.md) klauzuli.</span><span class="sxs-lookup"><span data-stu-id="e0eef-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="e0eef-139">Mezi první `from` klauzule a poslední `select` nebo `group` klauzule, může obsahovat jeden nebo více z těchto klauzulí volitelné: [kde](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [spojení ](../language-reference/keywords/join-clause.md), [nechat](../language-reference/keywords/let-clause.md) a dokonce i další [z](../language-reference/keywords/from-clause.md) klauzule.</span><span class="sxs-lookup"><span data-stu-id="e0eef-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="e0eef-140">Můžete také použít [do](../language-reference/keywords/into.md) – klíčové slovo umožňující výsledek `join` nebo `group` klauzuli, která bude sloužit jako zdroj pro další klauzule dotazu ve stejném výrazu dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="e0eef-141">Proměnné dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-141">Query variable</span></span>

<span data-ttu-id="e0eef-142">V technologii LINQ, proměnná dotazu je jakákoli proměnná, která ukládá *dotazu* místo *výsledky* dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="e0eef-143">Přesněji řečeno, proměnná dotazu je vždy Výčtový typ, který vytvoří řadu prvků, když ho je procházena `foreach` příkazu nebo přímého volání jeho `IEnumerator.MoveNext` metoda.</span><span class="sxs-lookup"><span data-stu-id="e0eef-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="e0eef-144">Následující příklad kódu ukazuje výraz jednoduchý dotaz s jedním zdrojem dat, jednu klauzuli filtrování, jednu klauzuli pořadí a žádná transformace zdrojové elementy.</span><span class="sxs-lookup"><span data-stu-id="e0eef-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="e0eef-145">`select` Končí klauzule dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="e0eef-146">V předchozím příkladu `scoreQuery` je *proměnné dotazu* které se někdy označuje jako jenom *dotazu*.</span><span class="sxs-lookup"><span data-stu-id="e0eef-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="e0eef-147">Ukládá žádná data skutečný výsledek, který je vytvořen v proměnné dotazu `foreach` smyčky.</span><span class="sxs-lookup"><span data-stu-id="e0eef-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="e0eef-148">A když `foreach` spuštění příkazů výsledky dotazu nevrací prostřednictvím proměnné dotazu `scoreQuery`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="e0eef-149">Místo toho jsou vráceny prostřednictvím proměnné iterace `testScore`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="e0eef-150">`scoreQuery` Proměnnou můžete provést iteraci za sekundu `foreach` smyčky.</span><span class="sxs-lookup"><span data-stu-id="e0eef-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="e0eef-151">To se vytvářejí stejné výsledky, tak dlouho, dokud ho ani zdroj dat byl změněn.</span><span class="sxs-lookup"><span data-stu-id="e0eef-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="e0eef-152">Proměnné dotazu může uložit dotaz, který je vyjádřena v syntaxi dotazu nebo syntaxe využívající metody nebo kombinaci obojího.</span><span class="sxs-lookup"><span data-stu-id="e0eef-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="e0eef-153">V následujících příkladech obě `queryMajorCities` a `queryMajorCities2` jsou proměnné dotazu:</span><span class="sxs-lookup"><span data-stu-id="e0eef-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="e0eef-154">Na druhé straně následující dva příklady ukazovat proměnné, které nejsou proměnné dotazu, i když každá je inicializován pomocí dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="e0eef-155">Nejsou se proměnné dotazu, protože jsou v nich uložené výsledky:</span><span class="sxs-lookup"><span data-stu-id="e0eef-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="e0eef-156">Další informace o různých způsobech rychlé dotazy, naleznete v tématu [syntaxe využívající dotazy a syntaxe využívající metody v LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="e0eef-157">Explicitní a implicitní zadáním proměnné dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="e0eef-158">Tato dokumentace obvykle poskytuje explicitní typ proměnné dotazu chcete-li zobrazit typ vztahu mezi proměnné dotazu a [klauzule select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="e0eef-159">Ale můžete také použít [var](../language-reference/keywords/var.md) – klíčové slovo, abyste instruovali kompilátor k odvození typu proměnné dotazu (nebo jakoukoli jinou místní proměnnou) v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="e0eef-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="e0eef-160">Například příklad dotazu, které se zobrazilo dříve v tomto tématu se dají vyjádřit také pomocí implicitního zápisu:</span><span class="sxs-lookup"><span data-stu-id="e0eef-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="e0eef-161">Další informace najdete v tématu [implicitně typované lokální proměnné](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) a [vztahy typů v LINQ dotaz operace](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="e0eef-162">Spuštění výrazu dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-162">Starting a query expression</span></span>

<span data-ttu-id="e0eef-163">Výraz dotazu musí začínat `from` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="e0eef-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="e0eef-164">Určuje zdroj dat spolu s proměnnou rozsahu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="e0eef-165">Proměnná rozsahu představuje každý prvek po sobě jdoucích ze zdrojové sekvence, jak procházet řízený zdrojové sekvence.</span><span class="sxs-lookup"><span data-stu-id="e0eef-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="e0eef-166">Proměnná rozsahu je silně typováno podle typu ve zdroji dat prvků.</span><span class="sxs-lookup"><span data-stu-id="e0eef-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="e0eef-167">V následujícím příkladu protože `countries` je pole `Country` objekty, proměnná rozsahu je také zadán jako `Country`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="e0eef-168">Vzhledem k tomu, že proměnná rozsahu je silně typováno, můžete použít operátor tečky pro přístup k libovolné dostupné členy typu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="e0eef-169">Proměnná rozsahu je v oboru, dokud nebude ukončen dotaz středníkem nebo s *pokračování* klauzuli.</span><span class="sxs-lookup"><span data-stu-id="e0eef-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="e0eef-170">Výraz dotazu může obsahovat více `from` klauzule.</span><span class="sxs-lookup"><span data-stu-id="e0eef-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="e0eef-171">Pomocí dalších `from` klauzule pokud každý prvek ve zdrojové sekvenci je samotný soubor, nebo obsahuje kolekci.</span><span class="sxs-lookup"><span data-stu-id="e0eef-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="e0eef-172">Například předpokládejme, že máte kolekci `Country` objektů, z nichž každý obsahuje kolekci `City` objektů s názvem `Cities`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="e0eef-173">Dotaz `City` objekty v každém `Country`, použijte dva `from` klauzule, jak je znázorněno zde:</span><span class="sxs-lookup"><span data-stu-id="e0eef-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="e0eef-174">Další informace najdete v tématu [klauzule from](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="e0eef-175">Ukončení výrazu dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-175">Ending a query expression</span></span>

<span data-ttu-id="e0eef-176">Buď musí končit výrazu dotazu `group` klauzule nebo `select` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="e0eef-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="e0eef-177">group – klauzule</span><span class="sxs-lookup"><span data-stu-id="e0eef-177">group clause</span></span>

<span data-ttu-id="e0eef-178">Použití `group` klauzule, která vytvoří posloupnost skupiny uspořádané podle klíče, který zadáte.</span><span class="sxs-lookup"><span data-stu-id="e0eef-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="e0eef-179">Klíč může být libovolného datového typu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-179">The key can be any data type.</span></span> <span data-ttu-id="e0eef-180">Například následující dotaz vytvoří posloupnost skupiny, která obsahuje jeden nebo více `Country` objekty a jehož klíč je `char` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="e0eef-181">Další informace o seskupování najdete v tématu [group – klauzule](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="e0eef-182">select – klauzule (C#)</span><span class="sxs-lookup"><span data-stu-id="e0eef-182">select clause</span></span>

<span data-ttu-id="e0eef-183">Použití `select` klauzule, která vytvoří všechny ostatní typy pořadí.</span><span class="sxs-lookup"><span data-stu-id="e0eef-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="e0eef-184">Jednoduchý `select` klauzule generuje pouze sekvenci objektů stejného typu jako objekty, které jsou obsaženy ve zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="e0eef-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="e0eef-185">V tomto příkladu zdroj dat obsahuje `Country` objekty.</span><span class="sxs-lookup"><span data-stu-id="e0eef-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="e0eef-186">`orderby` Klauzule právě Seřadí prvky do nového pořadí a `select` klauzule generuje sekvenci uspořádaný `Country` objekty.</span><span class="sxs-lookup"><span data-stu-id="e0eef-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="e0eef-187">`select` Klauzule je možné získat zdrojová data sekvencí nových typů.</span><span class="sxs-lookup"><span data-stu-id="e0eef-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="e0eef-188">Je také název této transformace *projekce*.</span><span class="sxs-lookup"><span data-stu-id="e0eef-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="e0eef-189">V následujícím příkladu `select` klauzule *projekty* sekvenci anonymních typů, která obsahuje pouze podmnožinu polí v původní elementu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="e0eef-190">Všimněte si, že nové objekty jsou inicializovány pomocí inicializátoru objektu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="e0eef-191">Další informace o tom, jak, který `select` klauzuli lze použít transformují zdrojová data, přečtěte si téma [klauzule select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="e0eef-192">Pokračování s "do"</span><span class="sxs-lookup"><span data-stu-id="e0eef-192">Continuations with "into"</span></span>

<span data-ttu-id="e0eef-193">Můžete použít `into` – klíčové slovo v `select` nebo `group` klauzule vytvořit dočasné identifikátor, který ukládá dotaz.</span><span class="sxs-lookup"><span data-stu-id="e0eef-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="e0eef-194">To proveďte, když musíte provádět operace dalších dotazů na dotazu po seskupení nebo vyberte operaci.</span><span class="sxs-lookup"><span data-stu-id="e0eef-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="e0eef-195">V následujícím příkladu `countries` se seskupí podle naplnění oblastí 10 milionů.</span><span class="sxs-lookup"><span data-stu-id="e0eef-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="e0eef-196">Poté, co tyto skupiny jsou vytvořené, další klauzule filtru některé skupiny a pak řazení skupin ve vzestupném pořadí.</span><span class="sxs-lookup"><span data-stu-id="e0eef-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="e0eef-197">K provedení dalších operací, pokračování reprezentována `countryGroup` je povinný.</span><span class="sxs-lookup"><span data-stu-id="e0eef-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="e0eef-198">Další informace najdete v tématu [do](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="e0eef-199">Filtrování, řazení a propojení</span><span class="sxs-lookup"><span data-stu-id="e0eef-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="e0eef-200">Mezi počáteční `from` klauzule a konec `select` nebo `group` klauzule, všechny ostatní klauzule (`where`, `join`, `orderby`, `from`, `let`) jsou volitelné.</span><span class="sxs-lookup"><span data-stu-id="e0eef-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="e0eef-201">Libovolné volitelné klauzule lze nula doby nebo více než jednou v textu dotazu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="e0eef-202">where – klauzule</span><span class="sxs-lookup"><span data-stu-id="e0eef-202">where clause</span></span>

<span data-ttu-id="e0eef-203">Použití `where` klauzule můžete filtrovat prvky ze zdroje dat založené na jeden nebo více výrazů predikátu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="e0eef-204">`where` Klauzule v následujícím příkladu má jeden predikát s dvě podmínky.</span><span class="sxs-lookup"><span data-stu-id="e0eef-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="e0eef-205">Další informace najdete v tématu [kde klauzule](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="e0eef-206">orderby – klauzule</span><span class="sxs-lookup"><span data-stu-id="e0eef-206">orderby clause</span></span>

<span data-ttu-id="e0eef-207">Použití `orderby` klauzule seřadit výsledky ve vzestupném nebo sestupném pořadí.</span><span class="sxs-lookup"><span data-stu-id="e0eef-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="e0eef-208">Můžete také určit pořadí řazení sekundární.</span><span class="sxs-lookup"><span data-stu-id="e0eef-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="e0eef-209">Následující příklad provede primární řazení `country` objektů pomocí `Area` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="e0eef-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="e0eef-210">Pak pomocí provádí sekundární řazení `Population` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="e0eef-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="e0eef-211">`ascending` – Klíčové slovo je volitelné, je výchozí pořadí řazení, pokud není zadána žádná objednávka.</span><span class="sxs-lookup"><span data-stu-id="e0eef-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="e0eef-212">Další informace najdete v tématu [klauzule orderby](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="e0eef-213">join – klauzule</span><span class="sxs-lookup"><span data-stu-id="e0eef-213">join clause</span></span>

<span data-ttu-id="e0eef-214">Použití `join` klauzuli spojení a/nebo zkombinovat prvky z jednoho zdroje dat s prvky z jiného zdroje dat založené na porovnání rovnosti mezi klíči zadaného v jednotlivých prvcích.</span><span class="sxs-lookup"><span data-stu-id="e0eef-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="e0eef-215">V technologii LINQ spojení operace provádějí v pořadí, jehož prvky jsou různé typy objektů.</span><span class="sxs-lookup"><span data-stu-id="e0eef-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="e0eef-216">Po připojení dvou sekvencí, je nutné použít `select` nebo `group` příkaz a zadejte které elementy pro ukládání do výstupní sekvenci.</span><span class="sxs-lookup"><span data-stu-id="e0eef-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="e0eef-217">Anonymního typu můžete použít také ke sloučení vlastnosti ze všech sad přidružených elementů do nový typ pro výstupní sekvenci.</span><span class="sxs-lookup"><span data-stu-id="e0eef-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="e0eef-218">V následujícím příkladu `prod` objekty, jejichž `Category` vlastnost odpovídá jednomu z kategorií v `categories` pole řetězců.</span><span class="sxs-lookup"><span data-stu-id="e0eef-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="e0eef-219">Produkty jehož `Category` neodpovídá libovolný řetězec v `categories` , budou odfiltrovány. `select` Příkaz projekty nového typu, jehož vlastnosti pocházejí z obou `cat` a `prod`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="e0eef-220">Spojení skupiny můžete také provádět pomocí ukládání výsledků `join` operace do dočasné proměnné s použitím [do](../language-reference/keywords/into.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="e0eef-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="e0eef-221">Další informace najdete v tématu [klauzule join](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="e0eef-222">let – klauzule</span><span class="sxs-lookup"><span data-stu-id="e0eef-222">let clause</span></span> 

<span data-ttu-id="e0eef-223">Použití `let` klauzule, která uloží výsledek výrazu, jako je například volání metody v nové proměnné rozsahu.</span><span class="sxs-lookup"><span data-stu-id="e0eef-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="e0eef-224">V následujícím příkladu proměnná rozsahu `firstName` ukládá první prvek pole řetězců, které vrací `Split`.</span><span class="sxs-lookup"><span data-stu-id="e0eef-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="e0eef-225">Další informace najdete v tématu [let – klauzule](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="e0eef-226">Poddotazy ve výrazu dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-226">Subqueries in a query expression</span></span>

<span data-ttu-id="e0eef-227">Klauzule dotazu mohou obsahovat výraz dotazu, který se někdy označuje jako *poddotaz*.</span><span class="sxs-lookup"><span data-stu-id="e0eef-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="e0eef-228">Každý poddotaz spustí vlastní `from` klauzuli, která není nutně cesta ke stejnému zdroji dat v prvním `from` klauzuli.</span><span class="sxs-lookup"><span data-stu-id="e0eef-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="e0eef-229">Například následující dotaz ukazuje výraz dotazu, který se používá v příkazu select k načtení výsledků operace seskupení.</span><span class="sxs-lookup"><span data-stu-id="e0eef-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="e0eef-230">Další informace najdete v tématu [postupy: provádění poddotazů na operace seskupení](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="e0eef-230">For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e0eef-231">Viz také:</span><span class="sxs-lookup"><span data-stu-id="e0eef-231">See also</span></span>

- [<span data-ttu-id="e0eef-232">Průvodce programovacího jazyka C#</span><span class="sxs-lookup"><span data-stu-id="e0eef-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="e0eef-233">LINQ (Language Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="e0eef-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="e0eef-234">Klíčová slova dotazu (LINQ)</span><span class="sxs-lookup"><span data-stu-id="e0eef-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="e0eef-235">Přehled standardních operátorů dotazu</span><span class="sxs-lookup"><span data-stu-id="e0eef-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
