---
title: Zahození – C# Průvodce
description: Popisuje C#podporu pro zahození, které jsou nepřiřazené, hodíelné proměnné a způsoby, jak je možné je použít.
ms.technology: csharp-fundamentals
ms.date: 07/21/2017
ms.openlocfilehash: a76e7fc13f92ec0de87153bb35eb3924bb317616
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/30/2019
ms.locfileid: "73100642"
---
# <a name="discards---c-guide"></a><span data-ttu-id="f33b7-103">Zahození – C# Průvodce</span><span class="sxs-lookup"><span data-stu-id="f33b7-103">Discards - C# Guide</span></span>

<span data-ttu-id="f33b7-104">Počínaje C# 7,0 C# podporuje zahození, což jsou dočasné a fiktivní proměnné, které jsou záměrně nepoužívané v kódu aplikace.</span><span class="sxs-lookup"><span data-stu-id="f33b7-104">Starting with C# 7.0, C# supports discards, which are temporary, dummy variables that are intentionally unused in application code.</span></span> <span data-ttu-id="f33b7-105">Zahození jsou ekvivalentní nepřiřazeným proměnným; nemají hodnotu.</span><span class="sxs-lookup"><span data-stu-id="f33b7-105">Discards are equivalent to unassigned variables; they do not have a value.</span></span> <span data-ttu-id="f33b7-106">Vzhledem k tomu, že existuje pouze jedna proměnná zahození a tato proměnná nesmí být přidělena jako úložiště, zrušení zahození může snížit přidělení paměti.</span><span class="sxs-lookup"><span data-stu-id="f33b7-106">Because there is only a single discard variable, and that variable may not even be allocated storage, discards can reduce memory allocations.</span></span> <span data-ttu-id="f33b7-107">Vzhledem k tomu, že záměr vašeho kódu je jasný, zvyšují jeho čitelnost a udržovatelnost.</span><span class="sxs-lookup"><span data-stu-id="f33b7-107">Because they make the intent of your code clear, they enhance its readability and maintainability.</span></span>

<span data-ttu-id="f33b7-108">Označíte, že proměnná je zahozena přiřazením podtržítka (`_`) jako názvu.</span><span class="sxs-lookup"><span data-stu-id="f33b7-108">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="f33b7-109">Například následující volání metody vrací 3-Tuple, ve kterém jsou první a druhé hodnoty zahozeny a *oblast* je dřív deklarovaná proměnná, která má být nastavena na odpovídající třetí komponentu vrácenou *GetCityInformation*:</span><span class="sxs-lookup"><span data-stu-id="f33b7-109">For example, the following method call returns a 3-tuple in which the first and second values are discards and *area* is a previously declared variable to be set to the corresponding third component returned by *GetCityInformation*:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="f33b7-110">V C# rámci přiřazení v následujících kontextech jsou zahozena 7,0:</span><span class="sxs-lookup"><span data-stu-id="f33b7-110">In C# 7.0, discards are supported in assignments in the following contexts:</span></span>

- <span data-ttu-id="f33b7-111">Řazená kolekce členů a [dekonstrukce](deconstruct.md)objektu.</span><span class="sxs-lookup"><span data-stu-id="f33b7-111">Tuple and object [deconstruction](deconstruct.md).</span></span>
- <span data-ttu-id="f33b7-112">Porovnávání vzorů s [je](language-reference/keywords/is.md) a [Switch](language-reference/keywords/switch.md).</span><span class="sxs-lookup"><span data-stu-id="f33b7-112">Pattern matching with [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md).</span></span>
- <span data-ttu-id="f33b7-113">Volá metody s parametry `out`.</span><span class="sxs-lookup"><span data-stu-id="f33b7-113">Calls to methods with `out` parameters.</span></span>
- <span data-ttu-id="f33b7-114">Samostatný `_`, pokud není v oboru žádné `_`.</span><span class="sxs-lookup"><span data-stu-id="f33b7-114">A standalone `_` when no `_` is in scope.</span></span>

<span data-ttu-id="f33b7-115">Pokud je `_` platným zahozením, pokus o načtení jeho hodnoty nebo jeho použití v operaci přiřazení generuje chybu kompilátoru CS0301, název\_v aktuálním kontextu neexistuje.</span><span class="sxs-lookup"><span data-stu-id="f33b7-115">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' does not exist in the current context".</span></span> <span data-ttu-id="f33b7-116">Důvodem je to, že `_` nemá přiřazenou hodnotu a nemusí být ani přiřazeno umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="f33b7-116">This is because `_` is not assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="f33b7-117">Pokud se jednalo o skutečnou proměnnou, nemůžete zahodit více než jednu hodnotu, protože předchozí příklad proběhl.</span><span class="sxs-lookup"><span data-stu-id="f33b7-117">If it were an actual variable, you could not discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="f33b7-118">Tuple a dekonstrukce objektu</span><span class="sxs-lookup"><span data-stu-id="f33b7-118">Tuple and object deconstruction</span></span>

<span data-ttu-id="f33b7-119">Zahození jsou zvláště užitečné při práci s řazenými kolekcemi členů, když kód aplikace používá některé prvky řazené kolekce členů, ale ignoruje jiné.</span><span class="sxs-lookup"><span data-stu-id="f33b7-119">Discards are particularly useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="f33b7-120">Například následující metoda `QueryCityDataForYears` vrátí 6-řazené kolekce členů s názvem města, jeho oblastí, rokem, populacem města pro daný rok, druhým rokem a plněním města pro daný druhý rok.</span><span class="sxs-lookup"><span data-stu-id="f33b7-120">For example, the following `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="f33b7-121">V tomto příkladu se zobrazuje změna populace mezi těmito dvěma roky.</span><span class="sxs-lookup"><span data-stu-id="f33b7-121">The example shows the change in population between those two years.</span></span> <span data-ttu-id="f33b7-122">Z dat, která jsou k dispozici v rámci řazené kolekce členů, jsme nevěděli s oblastí město a znali jsme název města a dvě datum v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="f33b7-122">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="f33b7-123">V důsledku toho se zajímá jenom o dvě hodnoty populace uložené v řazené kolekci členů a můžou své zbývající hodnoty zpracovat jako zahozené.</span><span class="sxs-lookup"><span data-stu-id="f33b7-123">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

<span data-ttu-id="f33b7-124">Další informace o dekonstrukci řazených kolekcí členů pomocí výmětů naleznete v tématu [dekonstrukce řazených kolekcí členů a dalších typů](deconstruct.md#deconstructing-tuple-elements-with-discards).</span><span class="sxs-lookup"><span data-stu-id="f33b7-124">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="f33b7-125">Metoda `Deconstruct` třídy, struktury nebo rozhraní také umožňuje načíst a dekonstruovat konkrétní sadu dat z objektu.</span><span class="sxs-lookup"><span data-stu-id="f33b7-125">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="f33b7-126">Pokud vás zajímá, že pracujete jenom s podmnožinou dekonstruovaných hodnot, můžete zahození použít.</span><span class="sxs-lookup"><span data-stu-id="f33b7-126">You can use discards when you are interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="f33b7-127">Následující příklad dekonstruuje objekt `Person` do čtyř řetězců (křestní jméno a příjmení, město a stav), ale zahodí příjmení a stav.</span><span class="sxs-lookup"><span data-stu-id="f33b7-127">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs)]

<span data-ttu-id="f33b7-128">Další informace o dekonstrukci uživatelsky definovaných typů pomocí zahození naleznete v tématu [dekonstrukce řazených kolekcí členů a dalších typů](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span><span class="sxs-lookup"><span data-stu-id="f33b7-128">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch-and-is"></a><span data-ttu-id="f33b7-129">Porovnávání vzorů s `switch` a `is`</span><span class="sxs-lookup"><span data-stu-id="f33b7-129">Pattern matching with `switch` and `is`</span></span>

<span data-ttu-id="f33b7-130">*Vzor zahození* lze použít při porovnávání vzorů s klíčovým slovem [is](language-reference/keywords/is.md) a [Switch](language-reference/keywords/switch.md) .</span><span class="sxs-lookup"><span data-stu-id="f33b7-130">The *discard pattern* can be used in pattern matching with the [is](language-reference/keywords/is.md) and [switch](language-reference/keywords/switch.md) keywords.</span></span> <span data-ttu-id="f33b7-131">Každý výraz vždy odpovídá vzoru zahození.</span><span class="sxs-lookup"><span data-stu-id="f33b7-131">Every expression always matches the discard pattern.</span></span>

<span data-ttu-id="f33b7-132">Následující příklad definuje metodu `ProvidesFormatInfo`, [která používá příkazy, k určení](language-reference/keywords/is.md) , zda objekt poskytuje <xref:System.IFormatProvider> implementaci a testuje, zda je objekt `null`.</span><span class="sxs-lookup"><span data-stu-id="f33b7-132">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="f33b7-133">Používá také vzor zahození pro zpracování objektů jiného typu, které nejsou null.</span><span class="sxs-lookup"><span data-stu-id="f33b7-133">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

[!code-csharp[discard-pattern](../../samples/snippets/csharp/programming-guide/discards/discard-pattern2.cs)]

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="f33b7-134">Volání metod s výstupními parametry</span><span class="sxs-lookup"><span data-stu-id="f33b7-134">Calls to methods with out parameters</span></span>

<span data-ttu-id="f33b7-135">Při volání metody `Deconstruct` pro dekonstrukci uživatelsky definovaného typu (instance třídy, struktury nebo rozhraní) můžete zahodit hodnoty jednotlivých argumentů `out`.</span><span class="sxs-lookup"><span data-stu-id="f33b7-135">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="f33b7-136">Ale při volání libovolné metody s parametrem out můžete také zahodit hodnotu `out` argumenty.</span><span class="sxs-lookup"><span data-stu-id="f33b7-136">But you can also discard the value of `out` arguments when calling any method with an out parameter.</span></span>

<span data-ttu-id="f33b7-137">Následující příklad volá metodu [DateTime. TryParse (String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) k určení, zda řetězcové vyjádření data je platné v aktuální jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="f33b7-137">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="f33b7-138">Vzhledem k tomu, že se jedná o příklad pouze při ověřování řetězce data a nikoli při jeho analýze pro extrakci data, argument `out` metody je zahození.</span><span class="sxs-lookup"><span data-stu-id="f33b7-138">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

[!code-csharp[discard-with-out](../../samples/snippets/csharp/programming-guide/discards/discard-out1.cs)]

## <a name="a-standalone-discard"></a><span data-ttu-id="f33b7-139">Samostatné zahození</span><span class="sxs-lookup"><span data-stu-id="f33b7-139">A standalone discard</span></span>

<span data-ttu-id="f33b7-140">Samostatné zahození můžete použít k označení všech proměnných, které se rozhodnete ignorovat.</span><span class="sxs-lookup"><span data-stu-id="f33b7-140">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="f33b7-141">Následující příklad používá samostatné zahození pro ignorování objektu <xref:System.Threading.Tasks.Task> vráceného asynchronní operací.</span><span class="sxs-lookup"><span data-stu-id="f33b7-141">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="f33b7-142">To má dopad na potlačení výjimky, kterou operace vyvolá, protože se chystá její dokončení.</span><span class="sxs-lookup"><span data-stu-id="f33b7-142">This has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span>

[!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard1.cs)]

<span data-ttu-id="f33b7-143">Všimněte si, že `_` je také platný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="f33b7-143">Note that `_` is also a valid identifier.</span></span> <span data-ttu-id="f33b7-144">Pokud se používá mimo podporovaný kontext, `_` se považuje za zahození, ale jako platnou proměnnou.</span><span class="sxs-lookup"><span data-stu-id="f33b7-144">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="f33b7-145">Pokud je v oboru již identifikátor s názvem `_`, použití `_` jako samostatné zahození může mít za následek:</span><span class="sxs-lookup"><span data-stu-id="f33b7-145">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="f33b7-146">Náhodné úpravy hodnoty proměnné `_` v oboru přiřazením hodnoty zamýšleného zahození.</span><span class="sxs-lookup"><span data-stu-id="f33b7-146">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="f33b7-147">Příklad:</span><span class="sxs-lookup"><span data-stu-id="f33b7-147">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#1)]

- <span data-ttu-id="f33b7-148">Chyba kompilátoru pro porušení bezpečnosti typů.</span><span class="sxs-lookup"><span data-stu-id="f33b7-148">A compiler error for violating type safety.</span></span> <span data-ttu-id="f33b7-149">Příklad:</span><span class="sxs-lookup"><span data-stu-id="f33b7-149">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#2)]

- <span data-ttu-id="f33b7-150">Chyba kompilátoru CS0136, v tomto oboru nelze deklarovat místní nebo parametr s názvem\_, protože tento název se používá v nadřazeném místním oboru pro definování místní proměnné nebo parametru.</span><span class="sxs-lookup"><span data-stu-id="f33b7-150">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="f33b7-151">Příklad:</span><span class="sxs-lookup"><span data-stu-id="f33b7-151">For example:</span></span>

   [!code-csharp[standalone-discard](../../samples/snippets/csharp/programming-guide/discards/standalone-discard2.cs#3)]

## <a name="see-also"></a><span data-ttu-id="f33b7-152">Viz také:</span><span class="sxs-lookup"><span data-stu-id="f33b7-152">See also</span></span>

- [<span data-ttu-id="f33b7-153">Dekonstrukce řazených kolekcí členů a dalších typů</span><span class="sxs-lookup"><span data-stu-id="f33b7-153">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="f33b7-154">`is` – klíčové slovo</span><span class="sxs-lookup"><span data-stu-id="f33b7-154">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="f33b7-155">`switch` – klíčové slovo</span><span class="sxs-lookup"><span data-stu-id="f33b7-155">`switch` keyword</span></span>](language-reference/keywords/switch.md)
