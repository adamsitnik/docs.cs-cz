### YamlMime:Tutorial
title: <span data-ttu-id="f1a51-101">Prozkoumejte C# 6 C# – C# Interaktivní kurz</span><span class="sxs-lookup"><span data-stu-id="f1a51-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: Prozkoumat C# 6 – vyzkoušení nových funkcí v C# 6 interaktivních pomocí prohlížeče
  description: V tomto kurzu použijete prohlížeč k prozkoumání C# 6 interaktivně. Prozkoumáte novou idiomy, kterou můžete použít s C# 6, která umožní přesnější a čitelný kód.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: e1414c17cefd0fb31bb782a311e11dbd4cc056bb
  ms.sourcegitcommit: 093571de904fc7979e85ef3c048547d0accb1d8a
  ms.translationtype: MT
  ms.contentlocale: cs-CZ
  ms.lasthandoff: 09/06/2019
  ms.locfileid: "70394093"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="f1a51-105">Tento kurz vám umožní interaktivně C# prozkoumat 6, pomocí prohlížeče napsat C# a zobrazit výsledky kompilace a spuštění kódu.</span><span class="sxs-lookup"><span data-stu-id="f1a51-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="f1a51-106">Obsahuje řadu lekcí, které upravují předchozí C# postupy použití novějších a dalších stručných C# funkcí 6.</span><span class="sxs-lookup"><span data-stu-id="f1a51-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="f1a51-107">Zbývající část tohoto článku obsahuje přehled každé z těchto funkcí s odkazem na prozkoumání jednotlivých funkcí.</span><span class="sxs-lookup"><span data-stu-id="f1a51-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="f1a51-108">Automatické vlastnosti jen pro čtení umožňují typy jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="f1a51-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-109\">Dvě vylepšení syntaxe automatických vlastností usnadňují používání automatických vlastností na více místech: automatické vlastnosti a Inicializátory automatických vlastností.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"f1a51-110\">Vezměte v úvahu tento malý program:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"f1a51-111\">Přejděte do detailního režimu a zkopírujte předchozí kód do C# interaktivního okna.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"f1a51-112\">Pak klikněte na *Spustit* a podívejte se, jak kód dělá.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"f1a51-113\">`AllCaps`má nežádoucí vedlejší účinky úprav hodnot vlastností spolu s vrácením řetězce velkých písmen.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"f1a51-114\">Autor `Person` třídy, pro `FirstName` kterou jsou určeny řetězce, a `LastName` má být jen pro čtení.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"f1a51-115\">S C# 6 můžete tento záměr udělat jasným.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"f1a51-116\">`private set` Odeberte z obou vlastností, aby bylo možné vytvořit automatickou vlastnost určenou jen pro čtení.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"f1a51-117\">Klikněte na tlačítko *Spustit* a podívejte se, že kompilátor bude měnit dvě `FirstName` umístění `LastName` , kde jsou vlastnosti a změněny, pokud by neměly být.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"f1a51-118\">Chcete-li opravit `AllCaps` chybu kompilátoru, můžete změnit metodu na následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"f1a51-119\">Pomocí této nové syntaxe kompilátor zajišťuje, že vlastnosti jsou neměnné.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="f1a51-120">Inicializovat zálohovací pole pro automatické vlastnosti</span><span class="sxs-lookup"><span data-stu-id="f1a51-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"f1a51-121\">Nová syntaxe v C# 6 umožňuje použít inicializátory pro automatické vlastnosti.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"f1a51-122\">To je důležitější, protože třídy rozšiřují nové možnosti.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"f1a51-123\">Přidejte vlastnost prostřední název a nový konstruktor, který převezme tři řetězce `Person` třídy:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"f1a51-124\">Přiřazení u `MiddleName` vlastnosti je inicializátor.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"f1a51-125\">Inicializuje pole zálohování generované kompilátorem pro prostřední jméno.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="f1a51-126">Členové tvoření výrazy</span><span class="sxs-lookup"><span data-stu-id="f1a51-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="f1a51-127">Členové Expression-těle poskytují zjednodušenou syntaxi pro odlehčené metody.</span><span class="sxs-lookup"><span data-stu-id="f1a51-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="f1a51-128">`Person` Třída má dva Skvělé kandidáty.</span><span class="sxs-lookup"><span data-stu-id="f1a51-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="f1a51-129">Podívejte se na deklaraci `ToString`:</span><span class="sxs-lookup"><span data-stu-id="f1a51-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="f1a51-130">Nahraďte tuto deklaraci `ToString` následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="f1a51-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="f1a51-131">Zkuste to samé s `AllCaps` metodou.</span><span class="sxs-lookup"><span data-stu-id="f1a51-131">Try the same with the `AllCaps` method.</span></span> <span data-ttu-id="f1a51-132">Toto je malé zlepšení, ale v případě, že je to možné, vytvoří mnohem čitelnější kód, zejména u Přenos dat objektů (DTO) a dalších typů s minimálním chováním.</span><span class="sxs-lookup"><span data-stu-id="f1a51-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="f1a51-133">Import jedné třídy</span><span class="sxs-lookup"><span data-stu-id="f1a51-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-134\">Pokud opakovaně použijete jednu statickou metodu třídy v celém kódu, včetně názvu třídy, pokaždé, když je pokryta význam vašeho kódu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"f1a51-135\">Třída aktuálně importuje obor názvů, i když je použit <xref:System.Console?displayProperty=nameWithType>pouze. `System` `Person`</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"f1a51-136\">`using` Upravte příkaz následujícím způsobem:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"f1a51-137\">Příkaz `static using` je užitečnější ve větších programech, které umožňují rozsáhlé použití jedné třídy s mnoha statickými metodami, jako je [`string`](xref:System.String) třída nebo <xref:System.Math?displayProperty=nameWithType> třída.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="f1a51-138">Lepší formát řetězce</span><span class="sxs-lookup"><span data-stu-id="f1a51-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-139\">C#6 obsahuje novou syntaxi pro sestavování řetězců z řetězce a vložených výrazů, které jsou vyhodnocovány k vytvoření jiných řetězcových hodnot.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"f1a51-140\">Můžete změnit `ToString` metody a a `AllCaps` použít tuto syntaxi:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"f1a51-141\">Místo pozičních argumentů mezi `{` a `}`zapisujete C# výrazy přímo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"f1a51-142\">To můžete provést v `Main` metodě.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"f1a51-143\">Existující kód nahraďte následujícím kódem:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"f1a51-144\">V těchto výrazech nejste omezeni na jednu proměnnou.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"f1a51-145\">Pojďme začít novým příkladem a upravit ho k předvedení dalších výrazů, které můžete použít s interpolací řetězce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"f1a51-146\">Do interaktivního okna v `Main` metodě vložte následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n<span data-ttu-id=\"f1a51-147\">Který používá LINQ, takže budete muset přidat následující příkaz using do horní části interaktivního okna:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-147\">That uses LINQ, so you'll need to add the following using statement to the top of the interactive window:</span></span>\n\n```csharp\nusing System.Linq;\n```\n\n<span data-ttu-id=\"f1a51-148\">Můžete odebrat místní proměnnou `average` a provést tento výpočet jako součást interpolované řetězcové výrazu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-148\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"f1a51-149\">Poslední dva řádky nahraďte následujícím:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-149\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"f1a51-150\">Když spustíte předchozí příklad, zjistíte, že výstup pro `Average` má více desetinných míst, než byste chtěli.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-150\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"f1a51-151\">Syntaxe interpolace řetězce podporuje všechny formátovací řetězce, které jsou k dispozici pomocí dřívějších metod formátování.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-151\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"f1a51-152\">Řetězec formátu určíte uvnitř složených závorek.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-152\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"f1a51-153\">`:` Přidejte následující výraz pro formátování:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-153\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="f1a51-154">Rychlé a jednoduché kontroly s hodnotou null</span><span class="sxs-lookup"><span data-stu-id="f1a51-154">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-155\">Operátor `?.` (s hodnotou null) usnadňuje psaní logiky, která bez `null` dalších `if` kontrol přebírá hodnoty v bezproblémovém účtu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-155\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"f1a51-156\">Chcete-li prozkoumat tuto funkci, začněte zkopírováním následujícího kódu do interaktivního okna a vyzkoušejte:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-156\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"f1a51-157\">Vyvolá <xref:System.NullReferenceException> při spuštění ukázky.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-157\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"f1a51-158\">Změňte operátor přístupu \\*\\*\\*\\* členůnapodmíněnýoperátorshodnotou`.` null:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-158\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"f1a51-159\">Po této změně není k dispozici žádný výstup.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-159\">After this change, there's no output.</span></span> <span data-ttu-id=\"f1a51-160\">To je způsobeno tím, `s?.Length` že výsledkem `int?` `s.Length` `int`je, že je výsledkem.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-160\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"f1a51-161\">V tomto příkladu `s?.Length` je `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-161\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"f1a51-162\">Vrátí `?.` `null`, pokud je jeho levý operand. `null`</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-162\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"f1a51-163\">Pokud je typ pravého operandu typ hodnoty, `?.` vrátí operátor typ s možnou hodnotou null pro daný typ.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-163\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"f1a51-164\">Kromě toho `?.` můžete použít `?[]` pro přístup k poli nebo indexeru.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-164\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"f1a51-165\">V interaktivním okně zkuste použít následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-165\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"f1a51-166\">Více podmíněných operátorů lze zkombinovat do jednoho výrazu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-166\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"f1a51-167\">`null` Levý operand`null` vytvoří výsledek, což usnadňuje Vyhněte se vnořeným klauzulím if pro přístup ke členům členů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-167\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"f1a51-168\">Můžete například vyzkoušet následující kód v interaktivním okně:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-168\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"f1a51-169\">Předchozí příklad lze zjednodušit pomocí **operátoru slučování null** k poskytnutí výchozí hodnoty:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-169\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"f1a51-170\">**Podmíněný operátor s hodnotou null** vám pomůže napsat kód, který vytvoří základní logickou logiku k `null` bezproblémovému testování hodnot.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-170\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="f1a51-171">Filtry výjimek</span><span class="sxs-lookup"><span data-stu-id="f1a51-171">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-172\">Filtry výjimek umožňují zachytit výjimku na základě nějaké podmínky.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-172\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"f1a51-173\">Typickým použitím je vytvořit metodu filtru, která protokoluje výjimky, ale nikdy tyto výjimky nezpracovává.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-173\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"f1a51-174\">Filtr výjimek je logický výraz, který `true` je v `catch` případě, že by měla být provedena klauzule `false` a v případě, `catch` že by výjimka neměla být zachycena klauzulí.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-174\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"f1a51-175\">V interaktivním okně zkuste použít následující kód: Protokoluje typ výjimky a zprávu do konzoly.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-175\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"f1a51-176\">Vrátí `false` , což znamená, že výjimku nelze zpracovat.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-176\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"f1a51-177\">Vyzkoušejte program v interaktivním okně.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-177\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"f1a51-178\">Měla by se zobrazit zpráva z `LogException` metody následovaná výchozí zprávou výjimky.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-178\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"f1a51-179\">Stačí jenom experimentovat, změnit `return false` příkaz na `return true` a spustit ho znovu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-179\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"f1a51-180\">Nyní je výjimka zachycena a program se spustí k dokončení.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-180\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"f1a51-181\">Kromě scénářů protokolování může být filtry výjimek nejužitečnější, pokud vlastnost výjimky určuje, jakou akci chcete provést.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-181\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"f1a51-182\">Například můžete prohledat uvnitř <xref:System.AggregateException> a zjistit, jaké jsou obsažené výjimky, a provést v závislosti na konkrétní výjimce příslušné akce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-182\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="f1a51-183">Použití nameof</span><span class="sxs-lookup"><span data-stu-id="f1a51-183">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-184\">`nameof` Operátor vrátí název jakékoli proměnné, typu nebo členu typu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-184\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"f1a51-185\">Vyzkoušejte následující kód v interaktivním okně, abyste viděli, jak funguje:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-185\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"f1a51-186\">Výstup odpovídá názvu proměnné nebo typu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-186\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"f1a51-187\">I když jste zadali plně kvalifikovaný název typu (například `System.String`), `nameof` operátor vrátí Nekvalifikovaný název.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-187\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"f1a51-188\">Tato funkce je nejužitečnější, pokud potřebujete převést parametr nebo název vlastnosti na řetězec.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-188\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"f1a51-189\">Mezi příklady patří zachycení názvu argumentu pro vyvolání <xref:System.ArgumentNullException> nebo nebo <xref:System.ArgumentException>zachycení názvu změněné vlastnosti při implementaci <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-189\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="f1a51-190">Nová syntaxe inicializace objektu</span><span class="sxs-lookup"><span data-stu-id="f1a51-190">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f1a51-191\">Syntaxe inicializátoru objektu teď podporuje inicializaci *indexerů* a také vlastnosti a pole.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-191\">Object initializer syntax now supports initializing *indexers* as well as properties and fields.</span></span> <span data-ttu-id=\"f1a51-192\">Tato přidání usnadňuje inicializaci slovníků a dalších typů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-192\">This addition makes it easier to initialize dictionaries and other types.</span></span> <span data-ttu-id=\"f1a51-193\">Začněte slovníkem.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-193\">Start with a dictionary.</span></span> <span data-ttu-id=\"f1a51-194\">V interaktivním okně spusťte následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-194\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"f1a51-195\">Tato syntaxe, která nastaví hodnotu v indexeru, může být použita pro libovolný typ, který má přístup k přístupovému objektu set pro indexer.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-195\">This syntax, which sets a value in an indexer, can be used for any type that has an accessible set accessor on an indexer.</span></span>\n\n<span data-ttu-id=\"f1a51-196\">Druhá změna usnadňuje povolení syntaxe inicializátoru pro typy, které reprezentují sekvence.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-196\">A second change makes it easier to enable initializer syntax for types that represent sequences.</span></span> <span data-ttu-id=\"f1a51-197\">Inicializátory kolekce lze použít pro jakoukoliv třídu, která implementuje <xref:System.Collections.IEnumerable> a má veřejně dostupnou `Add` metodu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-197\">Collection initializers can be used on any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span> <span data-ttu-id=\"f1a51-198\">Tato `Add` metoda teď může být metodou rozšíření.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-198\">That `Add` method can now be an extension method.</span></span> \n\n<span data-ttu-id=\"f1a51-199\">Následující příklad ukazuje jeden scénář pro tuto syntaxi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-199\">The following example shows one scenario for this syntax.</span></span> <span data-ttu-id=\"f1a51-200\">Vytvoří `Path` třídu, která implementuje `IEnumerable<Point3D>` a má metodu pro přidání bodů, které přijímají tři argumenty.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-200\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that take three arguments.</span></span> <span data-ttu-id=\"f1a51-201\">Třída vytvoří další `Add` metodu pro přidání nového bodu z jeho tří součástí. `Extensions`</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-201\">The `Extensions` class creates an additional `Add` method to add a new point from its three components.</span></span> <span data-ttu-id=\"f1a51-202\">Tato ukázka se aktuálně nespouští interaktivně z důvodu omezení v prostředí.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f1a51-202\">This sample does not currently run interactively due to restrictions in the environment.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="f1a51-203">Dokončili jste průzkum nových funkcí v C# 6.</span><span class="sxs-lookup"><span data-stu-id="f1a51-203">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="f1a51-204">Teď si je můžete vyzkoušet sami ve svých aplikacích.</span><span class="sxs-lookup"><span data-stu-id="f1a51-204">Now try them yourself in your applications.</span></span>
