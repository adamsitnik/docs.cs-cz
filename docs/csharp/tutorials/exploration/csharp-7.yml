### YamlMime:Tutorial
title: <span data-ttu-id="c5f19-101">Prozkoumejte C# 7.0 - C# Interaktivní kurz</span><span class="sxs-lookup"><span data-stu-id="c5f19-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Prozkoumejte C# 7.0 – vyzkoušejte si nové funkce v C# 7.0 interaktivně, pomocí prohlížeče
  description: V tomto kurzu použijete prohlížeč k prozkoumání C# 7.0 interaktivně. Prozkoumáte nové idiomy můžete používat s C# 7.0, která umožňují stručnější a čitelnější kód.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 7cec35e0749ea0b38162244171459f311d27cb25
  ms.sourcegitcommit: a8d3504f0eae1a40bda2b06bd441ba01f1631ef0
  ms.translationtype: MT
  ms.contentlocale: cs-CZ
  ms.lasthandoff: 06/18/2019
  ms.locfileid: "67170228"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="c5f19-105">V tomto kurzu vám umožňuje zkoumat C# 7.0 funkce interaktivně, pomocí prohlížeče k zápisu C# a zobrazovat výsledky kompilace a spuštění kódu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="c5f19-106">Obsahuje sérii lekcí, které upravují dříve C# postupy při práci s novějšími, stručnější C# 7.0 funkce.</span><span class="sxs-lookup"><span data-stu-id="c5f19-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="c5f19-107">Zbývající část tohoto článku poskytuje přehled o každé z těchto funkcí s odkazem k prozkoumání jednotlivých funkcí.</span><span class="sxs-lookup"><span data-stu-id="c5f19-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="c5f19-108">Navýšení kapacity deklarace proměnných na umístění přiřazení</span><span class="sxs-lookup"><span data-stu-id="c5f19-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c5f19-109\">Existující syntaxi, která podporuje `out` v této verzi jsme vylepšili parametry.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"c5f19-110\">Klikněte na tlačítko *zadejte detailní režim* tlačítko v dolní části této stránky a pak zkuste v interaktivním okně následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"c5f19-111\">Nyní můžete deklarovat `out` proměnných v seznamu argumentů volání metody místo psaní příkazů samostatné prohlášení.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"c5f19-112\">Přesunout deklaraci do volání metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"c5f19-113\">Na konec interaktivního okna přidejte následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"c5f19-114\">Můžete změnit `int` prohlášení `var` deklarace.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"c5f19-115\">Do interaktivního okna přidejte následující kód:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"c5f19-116\">Nová syntaxe poskytuje dvě důležité výhody oproti existující syntaxi:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"c5f19-117\">Kód je lépe čitelný.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"c5f19-118\">Deklarujete proměnnou mimo, kde má být použito, ne na další řádek výše.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"c5f19-119\">Už není potřeba přiřadit počáteční hodnotu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"c5f19-120\">Deklarací `out` proměnné, kde se používá ve volání metody, nemůžete použít omylem ho dřív, než je přiřadí.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"c5f19-121\">Deklarovaná proměnná rozsahu je oboru nadřazeném `if` příkaz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"c5f19-122\">Můžete použít později.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"c5f19-123\">Upravit poslední `if` blokovat, jak je znázorněno v následujícím fragmentu kódu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="c5f19-124">Řazené kolekce členů vytvořit nenáročných datové struktury</span><span class="sxs-lookup"><span data-stu-id="c5f19-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"c5f19-125\">Řazené kolekce členů jsou jednoduché datové struktury, které obsahují více polí k reprezentaci datové členy.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"c5f19-126\">Pole pořadí úloh se neověřuje. proto nelze definovat vlastní metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c5f19-127\">Řazené kolekce členů byly k dispozici před C# 7.0, ale bylo neefektivní a měl neexistuje jazyková podpora.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"c5f19-128\">To znamená, že elementů řazené kolekce členů mohou být odkazovány pouze jako `Item1`, `Item2` a tak dále.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"c5f19-129\">C#7.0 přináší podporu jazyka pro řazené kolekce členů, která umožňuje sémantické názvy pro pole řazená kolekce členů pomocí nové efektivnější typy řazené kolekce členů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"c5f19-130\">Řazená kolekce členů můžete vytvořit tak, že přiřadíte hodnotu pro každého člena s názvem:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"c5f19-131\">`namedLetters` Řazené kolekce členů obsahuje pole, které jsou označovány jako `Alpha` a `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"c5f19-132\">Tyto názvy existují pouze v době kompilace a není zachováno v době běhu (při kontrole pomocí reflexe, například řazené kolekce členů).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"c5f19-133\">V přiřazení řazené kolekce členů můžete také zadat názvy polí na pravé straně přiřazení:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"c5f19-134\">Můžete zadat názvy polí na levé a pravé straně přiřazení, ale názvy na pravé straně jsou ignorovány.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"c5f19-135\">Řazené kolekce členů jsou nejužitečnější jako typy vracených hodnot pro `private` a `internal` metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"c5f19-136\">Řazené kolekce členů poskytují jednoduché syntaxi pro tyto metody k vrácení více jednotlivých hodnot.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"c5f19-137\">Vytvoření řazené kolekce členů je efektivnější a zvýšit produktivitu této vytváření třídy nebo struktury.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"c5f19-138\">Je jednodušší a jednoduché syntaxe pro definování datová struktura, která provede více než jednu hodnotu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"c5f19-139\">Následující příklad metoda vrátí minimální a maximální hodnoty nalezené v posloupnost celých čísel.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"c5f19-140\">Přidejte následující kód ve svém prohlížeči vyzkoušet:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"c5f19-141\">Může nastat situace, kdy budete chtít rozbalit členy řazené kolekce členů, které byly vráceny z metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"c5f19-142\">Můžete to udělat deklarací samostatné proměnných pro všechny hodnoty řazené kolekce členů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"c5f19-143\">Tento postup se nazývá *dekonstrukce* řazené kolekce členů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"c5f19-144\">Přidejte následující kód ve svém prohlížeči vyzkoušet:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"c5f19-145\">Při práci s řazenými kolekcemi členů, budete často zjistíte, že nepoužíváte všichni členové výsledku řazené kolekce členů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"c5f19-146\">Pokud k tomu dojde, můžete zrušit jednu nebo více vrácených hodnot s použitím `_` místo proměnné.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"c5f19-147\">Přidejte následující kód ve svém prohlížeči vyzkoušet:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"c5f19-148\">Další podrobnosti v o řazenými kolekcemi členů v [řazených kolekcí členů článku](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"c5f19-149\">Další informace o zahození v [zahození článku](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="c5f19-150">Použití vzoru typ s výraz</span><span class="sxs-lookup"><span data-stu-id="c5f19-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c5f19-151">`is` Výraz vzoru rozšiřuje známé [ `is` operátor](../../language-reference/keywords/is.md#pattern-matching-with-is) k dotazování nad rámec jeho typ objektu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="c5f19-152">Vyzkoušejte následující kód v okně prohlížeče:</span><span class="sxs-lookup"><span data-stu-id="c5f19-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="c5f19-153">Místo toho změňte deklaraci proměnné řetězce:</span><span class="sxs-lookup"><span data-stu-id="c5f19-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="c5f19-154">Nyní `is` výraz je nepravdivý, proto `else` větev provést.</span><span class="sxs-lookup"><span data-stu-id="c5f19-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="c5f19-155">Zkuste změnit `count` k `number` ve větvi else:</span><span class="sxs-lookup"><span data-stu-id="c5f19-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="c5f19-156">Výše uvedené nebude kompilovat, protože `number` není přiřazená ve `else` větve.</span><span class="sxs-lookup"><span data-stu-id="c5f19-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="c5f19-157">Je jenom přiřazená `true` větev `if` příkazu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="c5f19-158">`is` Vzor výrazu typu je užitečné, když máte malý počet typů pro porovnání výsledků testů.</span><span class="sxs-lookup"><span data-stu-id="c5f19-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="c5f19-159">Často je potřeba testovat více typů.</span><span class="sxs-lookup"><span data-stu-id="c5f19-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="c5f19-160">Který vyžaduje porovnávání vzorů `switch` příkazu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="c5f19-161">Porovnávání vzorů v příkazu switch</span><span class="sxs-lookup"><span data-stu-id="c5f19-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c5f19-162">*Odpovídat výrazu* má známou syntaxi, na základě `switch` příkaz již součástí jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="c5f19-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="c5f19-163">Začněme s malým vzorkem na základě `is` syntaxe výrazu jste prozkoumali na předchozí stránce:</span><span class="sxs-lookup"><span data-stu-id="c5f19-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="c5f19-164">Předchozí kód zkontroluje `int` nebo `null`.</span><span class="sxs-lookup"><span data-stu-id="c5f19-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="c5f19-165">Každý typ bylo dosaženo výchozí případ.</span><span class="sxs-lookup"><span data-stu-id="c5f19-165">Every other type reached the default case.</span></span> <span data-ttu-id="c5f19-166">Přidejte následující dva řádky, které ověří chování:</span><span class="sxs-lookup"><span data-stu-id="c5f19-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="c5f19-167">`switch` Výraz se převede na jeho odpovídající typ s možnou hodnotou Null typu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="c5f19-168">Přidejte následující ověření:</span><span class="sxs-lookup"><span data-stu-id="c5f19-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="c5f19-169">Přepínač příkazy, které můžete přidat libovolný počet dalších výrazů vzor typu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="c5f19-170">Přidejte tyto před `null` případ:</span><span class="sxs-lookup"><span data-stu-id="c5f19-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="c5f19-171">Ujistěte se, že tyto pracovní tak, že přidáte následující testy:</span><span class="sxs-lookup"><span data-stu-id="c5f19-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="c5f19-172">Výrazy shody také podporují konstanty.</span><span class="sxs-lookup"><span data-stu-id="c5f19-172">The match expressions also support constants.</span></span> <span data-ttu-id="c5f19-173">To ušetřit čas tím, které budou zohledňovat si jednoduchý případy:</span><span class="sxs-lookup"><span data-stu-id="c5f19-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="c5f19-174">Je nutné přidat v předchozím případě *před* `case int:` výrazu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="c5f19-175">Pokud chcete přidat po tento případ, kompilátor vás upozorní, že se má už zpracovala předchozí větví.</span><span class="sxs-lookup"><span data-stu-id="c5f19-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="c5f19-176">Můžete přidat `when` klauzule libovolný vzor malá a velká tak, aby bylo možné otestovat další podmínky nad rámec typu nebo konstantní hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="c5f19-177">Vyzkoušet tak, že přidáte následující případ nad Obecné `string` případ:</span><span class="sxs-lookup"><span data-stu-id="c5f19-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="c5f19-178">Testujte je něco jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="c5f19-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="c5f19-179">Nová syntaxe výrazů pro porovnávání usnadňuje vytvoření odeslání algoritmů pomocí jasné a stručné syntaxe založené na typ objektu nebo dalších vlastností.</span><span class="sxs-lookup"><span data-stu-id="c5f19-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="c5f19-180">Vzor odpovídající výrazy umožňují tyto konstrukce pro datové typy, které jsou nesouvisející prostřednictvím dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="c5f19-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="c5f19-181">Další informace o vzoru porovnávání ve článku vyhrazený pro [porovnávání vzorů v C# ](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="c5f19-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="c5f19-182">Optimalizace paměti úložiště pomocí místní referenční hodnoty a vrátí</span><span class="sxs-lookup"><span data-stu-id="c5f19-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c5f19-183">Tato funkce umožňuje algoritmy, které používají a vrátit odkazy na proměnné definované jinde.</span><span class="sxs-lookup"><span data-stu-id="c5f19-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="c5f19-184">Jedním z příkladů je velké matice a na jednom místě s určité vlastnosti hledání.</span><span class="sxs-lookup"><span data-stu-id="c5f19-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="c5f19-185">Jedna metoda vrátí dvou indexů na jednom místě v matici:</span><span class="sxs-lookup"><span data-stu-id="c5f19-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="c5f19-186">Otestováním této metody pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="c5f19-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="c5f19-187">To `Find` metoda vrátí indexy na položku v matici.</span><span class="sxs-lookup"><span data-stu-id="c5f19-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="c5f19-188">Který vede volajícím napsat kód, který používá tyto indexy přistoupit přes ukazatel matice a upravovat jeden element.</span><span class="sxs-lookup"><span data-stu-id="c5f19-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="c5f19-189">Měli byste spíše napsat metodu, která vrátí *odkaz* na prvek matrice, který chcete změnit.</span><span class="sxs-lookup"><span data-stu-id="c5f19-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="c5f19-190">Projděme si prostřednictvím řady změn k předvedení funkcí místní ref a ukazují, jak vytvořit metodu, která vrátí odkaz na interní úložiště.</span><span class="sxs-lookup"><span data-stu-id="c5f19-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="c5f19-191">Na cestě se dozvíte pravidla vrácených hodnot ref a ref místní funkce, které můžete chránit před omylem zneužití.</span><span class="sxs-lookup"><span data-stu-id="c5f19-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="c5f19-192">Začněte tím, že změna `Find` deklarace metody tak, aby se `ref int` místo řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="c5f19-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="c5f19-193">Upravte návratový příkaz vrátit položky na správnou indexů:</span><span class="sxs-lookup"><span data-stu-id="c5f19-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="c5f19-194">Změňte poslední vrácení namísto vyvolání výjimky:</span><span class="sxs-lookup"><span data-stu-id="c5f19-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="c5f19-195">Všimněte si, že to nebude kompilovat.</span><span class="sxs-lookup"><span data-stu-id="c5f19-195">Note that this won't compile.</span></span> <span data-ttu-id="c5f19-196">Označuje deklarace metody `ref` vrátit, ale návratový příkaz určuje návratovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c5f19-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="c5f19-197">Je nutné přidat `ref` – klíčové slovo pro každý příkaz return.</span><span class="sxs-lookup"><span data-stu-id="c5f19-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="c5f19-198">Který označuje návrat podle odkazu a pomáhá vývojářům čtení kódu později mějte na paměti, že metoda vrací odkazem:</span><span class="sxs-lookup"><span data-stu-id="c5f19-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="c5f19-199">Teď, když metoda vrátí odkaz na celočíselnou hodnotu v matici, budete muset upravit, kde je volán.</span><span class="sxs-lookup"><span data-stu-id="c5f19-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="c5f19-200">`var` Prohlášení znamená, že `valItem` je teď `int` místo řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="c5f19-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="c5f19-201">Volající kód změňte takto:</span><span class="sxs-lookup"><span data-stu-id="c5f19-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="c5f19-202">Druhá `WriteLine` příkaz v předchozím příkladu vytiskne hodnotu `42`, nikoli `24`.</span><span class="sxs-lookup"><span data-stu-id="c5f19-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="c5f19-203">Proměnná `valItem` je `int`, nikoli `ref int`.</span><span class="sxs-lookup"><span data-stu-id="c5f19-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="c5f19-204">`var` – Klíčové slovo umožňuje kompilátoru k určení typu, ale nepřidá implicitně `ref` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="c5f19-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="c5f19-205">Místo toho hodnota odkazuje `ref return` je *zkopírovat* do proměnné na levé straně přiřazení.</span><span class="sxs-lookup"><span data-stu-id="c5f19-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="c5f19-206">Proměnná není `ref` místní.</span><span class="sxs-lookup"><span data-stu-id="c5f19-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="c5f19-207">Pokud chcete upravit vráceného odkazu, je potřeba přidat `ref` modifikátoru deklarace lokální proměnné a před volání `Find` při vrácená hodnota je odkaz vytvořit odkaz proměnnou.</span><span class="sxs-lookup"><span data-stu-id="c5f19-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="c5f19-208">Upravte testovací kód v prohlížeči tak, aby odpovídala následující:</span><span class="sxs-lookup"><span data-stu-id="c5f19-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[TestByRef](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByRef "test code for return object by reference")]


    <span data-ttu-id="c5f19-209">Nyní, druhý `WriteLine` příkaz v předchozím příkladu vytiskne hodnotu `24`, označující, že byla změněna úložiště v matici.</span><span class="sxs-lookup"><span data-stu-id="c5f19-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="c5f19-210">Lokální proměnná jsou deklarované v rámci `ref` modifikátor který bude trvat `ref` vrátit.</span><span class="sxs-lookup"><span data-stu-id="c5f19-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="c5f19-211">Je nutné inicializovat `ref` proměnné při deklaraci; nelze rozdělit deklaraci a inicializaci.</span><span class="sxs-lookup"><span data-stu-id="c5f19-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="c5f19-212">Jazyk C# má tři další pravidla, které chrání vás před zneužitím `ref` místní hodnoty a vrátí:</span><span class="sxs-lookup"><span data-stu-id="c5f19-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="c5f19-213">Nelze přiřadit standardní metoda návratovou hodnotu pro `ref` místní proměnné.</span><span class="sxs-lookup"><span data-stu-id="c5f19-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="c5f19-214">Nelze vrátit `ref` do proměnné, jehož doba života nerozšiřuje nad rámec provádění metody.</span><span class="sxs-lookup"><span data-stu-id="c5f19-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="c5f19-215">`ref` místní hodnoty a vrátí nelze použít u asynchronních metod.</span><span class="sxs-lookup"><span data-stu-id="c5f19-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="c5f19-216">Přidání místní referenční hodnoty a ref vrátí povolit algoritmy, které jsou efektivnější se vyhnout kopírování hodnot nebo provádění operací přesměrování více než jednou.</span><span class="sxs-lookup"><span data-stu-id="c5f19-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="c5f19-217">Další informace najdete v tématu [ref – klíčové slovo](../../language-reference/keywords/ref.md) článku.</span><span class="sxs-lookup"><span data-stu-id="c5f19-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="c5f19-218">Minimalizovat přístup ke kódu s lokální funkce</span><span class="sxs-lookup"><span data-stu-id="c5f19-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c5f19-219\">Nyní můžete deklarovat lokální funkce, které jsou vnořené uvnitř jiné funkce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"c5f19-220\">To umožňuje minimalizovat, zda se tyto funkce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"c5f19-221\">Existují tři případy použití zřejmé pro lokální funkce:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"c5f19-222\">Rekurzivní funkce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"c5f19-223\">Metody iterátorů.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"c5f19-224\">Asynchronní metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"c5f19-225\">Začněme rekurzivní metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"c5f19-226\">Následující kód v prohlížeči k výpočtu `6!` (faktoriál):</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"c5f19-227\">Lokální funkce jsou skvělý způsob, jak implementovat rekurzivní algoritmy.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"c5f19-228\">Další běžné způsoby použití jsou určené pro veřejné iterátory a veřejné asynchronní metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"c5f19-229\">Oba typy metod generování kódu, který bude hlásit chyby později, než se dalo očekávat programátory.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"c5f19-230\">V případě metody iterátoru, všechny výjimky, jsou dodržovány pouze při volání metody kód, který uvádí, že vrácená sekvence.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"c5f19-231\">V případě asynchronní metody, všechny výjimky jsou pouze dodržovat při vráceného `Task` je očekáváno.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"c5f19-232\">Metody iterátorů se snadněji data prozkoumat v prohlížeči, takže použijeme v tomto průzkumu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"c5f19-233\">Vyzkoušejte následující kód, který volá metodu iterátoru v prohlížeči:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"c5f19-234\">Spusťte kód.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-234\">Run the code.</span></span> <span data-ttu-id=\"c5f19-235\">Všimněte si, že je vyvolána výjimka, když kód začne iterace druhou sadu výsledků.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"c5f19-236\">Kód, který iteruje první sada výsledků byla již spuštěna.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"c5f19-237\">Tato ukázka je malý a nezmění žádné datové struktury tak, aby byl neškodné a snadno to vyřešíme.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"c5f19-238\">Ale v rozsáhlejšího programu, ve kterém dvěma iterátoru objekty mohou být vytvořeny v metodách různé podřízené kořenové příčinou může být obtížné najít.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"c5f19-239\">Pokud první metodu iterátoru změnit stav dat, může i poškození dat. příčinou.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"c5f19-240\">Chcete, že byla výjimka okamžitě, předtím, než se provádí veškerou práci.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"c5f19-241\">Možné Refaktorovat kód, tak, aby veřejné metody ověří všechny argumenty a lokální funkce provádí výčtu:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"c5f19-242\">Předchozí verze je zřejmé, na který odkazuje místní metodu pouze v kontextu vnější metody.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"c5f19-243\">Pravidla pro lokální funkce také zajistěte, aby vývojář nesmí omylem z jiného umístění ve třídě zavolejte funkci Místní a obejít ověřování argumentu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"c5f19-244\">Stejným způsobem mohou být použity s `async` metody k zajištění, že výjimky vyplývající z ověřování argumentu jsou vyvolány před zahájením asynchronní práce.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c5f19-245\">Některé návrhy, které jsou podporovány lokální funkce také je možné dosáhnout použitím *výrazy lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"c5f19-246\">Tyto zúčastněné můžete [Další informace o rozdílech](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c5f19-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="c5f19-247">Dokončili jste vysvětlení hlavní nové funkce v C# 7.</span><span class="sxs-lookup"><span data-stu-id="c5f19-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="c5f19-248">Teď vyzkoušejte si je sami ve svých aplikacích.</span><span class="sxs-lookup"><span data-stu-id="c5f19-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="c5f19-249">Podívejte se na seznam v [co je nového v C# 7](../../whats-new/csharp-7.md) článku.</span><span class="sxs-lookup"><span data-stu-id="c5f19-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
