### YamlMime:Tutorial
title: Prozkoumejte C# 7.0 - C# Interaktivní kurz
metadata:
  title: Prozkoumejte C# 7.0 – vyzkoušejte si nové funkce v C# 7.0 interaktivně, pomocí prohlížeče
  description: V tomto kurzu použijete prohlížeč k prozkoumání C# 7.0 interaktivně. Prozkoumáte nové idiomy můžete používat s C# 7.0, která umožňují stručnější a čitelnější kód.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 7cec35e0749ea0b38162244171459f311d27cb25
  ms.sourcegitcommit: a8d3504f0eae1a40bda2b06bd441ba01f1631ef0
  ms.translationtype: MT
  ms.contentlocale: cs-CZ
  ms.lasthandoff: 06/18/2019
  ms.locfileid: "67170228"
items:
- durationInMinutes: 1
  content: >
    V tomto kurzu vám umožňuje zkoumat C# 7.0 funkce interaktivně, pomocí prohlížeče k zápisu C# a zobrazovat výsledky kompilace a spuštění kódu. Obsahuje sérii lekcí, které upravují dříve C# postupy při práci s novějšími, stručnější C# 7.0 funkce. Zbývající část tohoto článku poskytuje přehled o každé z těchto funkcí s odkazem k prozkoumání jednotlivých funkcí.
- title: Navýšení kapacity deklarace proměnných na umístění přiřazení
  durationInMinutes: 2
  content: "Existující syntaxi, která podporuje `out` v této verzi jsme vylepšili parametry. Klikněte na tlačítko *zadejte detailní režim* tlačítko v dolní části této stránky a pak zkuste v interaktivním okně následující kód: \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\nNyní můžete deklarovat `out` proměnných v seznamu argumentů volání metody místo psaní příkazů samostatné prohlášení. Přesunout deklaraci do volání metody. Na konec interaktivního okna přidejte následující kód:\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\nMůžete změnit `int` prohlášení `var` deklarace. Do interaktivního okna přidejte následující kód:\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\nNová syntaxe poskytuje dvě důležité výhody oproti existující syntaxi:\n\n* Kód je lépe čitelný. \n    - Deklarujete proměnnou mimo, kde má být použito, ne na další řádek výše.\n* Už není potřeba přiřadit počáteční hodnotu.\n    - Deklarací `out` proměnné, kde se používá ve volání metody, nemůžete použít omylem ho dřív, než je přiřadí.\n\nDeklarovaná proměnná rozsahu je oboru nadřazeném `if` příkaz. Můžete použít později. Upravit poslední `if` blokovat, jak je znázorněno v následujícím fragmentu kódu.\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: Řazené kolekce členů vytvořit nenáročných datové struktury
  durationInMinutes: 1
  content: "Řazené kolekce členů jsou jednoduché datové struktury, které obsahují více polí k reprezentaci datové členy. Pole pořadí úloh se neověřuje. proto nelze definovat vlastní metody.\n\n> [!NOTE]\n> Řazené kolekce členů byly k dispozici před C# 7.0, ale bylo neefektivní a měl neexistuje jazyková podpora. To znamená, že elementů řazené kolekce členů mohou být odkazovány pouze jako `Item1`, `Item2` a tak dále. C#7.0 přináší podporu jazyka pro řazené kolekce členů, která umožňuje sémantické názvy pro pole řazená kolekce členů pomocí nové efektivnější typy řazené kolekce členů.\n\nŘazená kolekce členů můžete vytvořit tak, že přiřadíte hodnotu pro každého člena s názvem:\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n`namedLetters` Řazené kolekce členů obsahuje pole, které jsou označovány jako `Alpha` a `Beta`. Tyto názvy existují pouze v době kompilace a není zachováno v době běhu (při kontrole pomocí reflexe, například řazené kolekce členů).\n\nV přiřazení řazené kolekce členů můžete také zadat názvy polí na pravé straně přiřazení: \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\nMůžete zadat názvy polí na levé a pravé straně přiřazení, ale názvy na pravé straně jsou ignorovány.\n\nŘazené kolekce členů jsou nejužitečnější jako typy vracených hodnot pro `private` a `internal` metody. Řazené kolekce členů poskytují jednoduché syntaxi pro tyto metody k vrácení více jednotlivých hodnot.\n\nVytvoření řazené kolekce členů je efektivnější a zvýšit produktivitu této vytváření třídy nebo struktury. Je jednodušší a jednoduché syntaxe pro definování datová struktura, která provede více než jednu hodnotu. Následující příklad metoda vrátí minimální a maximální hodnoty nalezené v posloupnost celých čísel. Přidejte následující kód ve svém prohlížeči vyzkoušet:\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\nMůže nastat situace, kdy budete chtít rozbalit členy řazené kolekce členů, které byly vráceny z metody.  Můžete to udělat deklarací samostatné proměnných pro všechny hodnoty řazené kolekce členů. Tento postup se nazývá *dekonstrukce* řazené kolekce členů. Přidejte následující kód ve svém prohlížeči vyzkoušet:\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\nPři práci s řazenými kolekcemi členů, budete často zjistíte, že nepoužíváte všichni členové výsledku řazené kolekce členů. Pokud k tomu dojde, můžete zrušit jednu nebo více vrácených hodnot s použitím `_` místo proměnné. Přidejte následující kód ve svém prohlížeči vyzkoušet:\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\nDalší podrobnosti v o řazenými kolekcemi členů v [řazených kolekcí členů článku](../../tuples.md).\nDalší informace o zahození v [zahození článku](../../discards.md).\n"
- title: Použití vzoru typ s výraz
  durationInMinutes: 2
  content: >
    `is` Výraz vzoru rozšiřuje známé [ `is` operátor](../../language-reference/keywords/is.md#pattern-matching-with-is) k dotazování nad rámec jeho typ objektu.


    Vyzkoušejte následující kód v okně prohlížeče:


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    Místo toho změňte deklaraci proměnné řetězce:


    ```csharp

    object count = "5";

    ```


    Nyní `is` výraz je nepravdivý, proto `else` větev provést. Zkuste změnit `count` k `number` ve větvi else:


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    Výše uvedené nebude kompilovat, protože `number` není přiřazená ve `else` větve. Je jenom přiřazená `true` větev `if` příkazu.


    `is` Vzor výrazu typu je užitečné, když máte malý počet typů pro porovnání výsledků testů. Často je potřeba testovat více typů. Který vyžaduje porovnávání vzorů `switch` příkazu.
- title: Porovnávání vzorů v příkazu switch
  durationInMinutes: 2
  content: >
    *Odpovídat výrazu* má známou syntaxi, na základě `switch` příkaz již součástí jazyka C#. Začněme s malým vzorkem na základě `is` syntaxe výrazu jste prozkoumali na předchozí stránce:


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    Předchozí kód zkontroluje `int` nebo `null`. Každý typ bylo dosaženo výchozí případ. Přidejte následující dva řádky, které ověří chování:


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    `switch` Výraz se převede na jeho odpovídající typ s možnou hodnotou Null typu. Přidejte následující ověření:


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    Přepínač příkazy, které můžete přidat libovolný počet dalších výrazů vzor typu. Přidejte tyto před `null` případ:


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    Ujistěte se, že tyto pracovní tak, že přidáte následující testy:


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    Výrazy shody také podporují konstanty. To ušetřit čas tím, které budou zohledňovat si jednoduchý případy:


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    Je nutné přidat v předchozím případě *před* `case int:` výrazu. Pokud chcete přidat po tento případ, kompilátor vás upozorní, že se má už zpracovala předchozí větví.


    Můžete přidat `when` klauzule libovolný vzor malá a velká tak, aby bylo možné otestovat další podmínky nad rámec typu nebo konstantní hodnotu. Vyzkoušet tak, že přidáte následující případ nad Obecné `string` případ:


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    Testujte je něco jako v následujícím kódu:


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    Nová syntaxe výrazů pro porovnávání usnadňuje vytvoření odeslání algoritmů pomocí jasné a stručné syntaxe založené na typ objektu nebo dalších vlastností. Vzor odpovídající výrazy umožňují tyto konstrukce pro datové typy, které jsou nesouvisející prostřednictvím dědičnosti.


    Další informace o vzoru porovnávání ve článku vyhrazený pro [porovnávání vzorů v C# ](../../pattern-matching.md).
- title: Optimalizace paměti úložiště pomocí místní referenční hodnoty a vrátí
  durationInMinutes: 2
  content: >
    Tato funkce umožňuje algoritmy, které používají a vrátit odkazy na proměnné definované jinde. Jedním z příkladů je velké matice a na jednom místě s určité vlastnosti hledání. Jedna metoda vrátí dvou indexů na jednom místě v matici:


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    Otestováním této metody pomocí následujícího kódu:


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    To `Find` metoda vrátí indexy na položku v matici. Který vede volajícím napsat kód, který používá tyto indexy přistoupit přes ukazatel matice a upravovat jeden element. Měli byste spíše napsat metodu, která vrátí *odkaz* na prvek matrice, který chcete změnit.


    Projděme si prostřednictvím řady změn k předvedení funkcí místní ref a ukazují, jak vytvořit metodu, která vrátí odkaz na interní úložiště. Na cestě se dozvíte pravidla vrácených hodnot ref a ref místní funkce, které můžete chránit před omylem zneužití.


    Začněte tím, že změna `Find` deklarace metody tak, aby se `ref int` místo řazené kolekce členů.


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    Upravte návratový příkaz vrátit položky na správnou indexů:


    ```csharp

    return matrix[i,j];

    ```


    Změňte poslední vrácení namísto vyvolání výjimky:


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    Všimněte si, že to nebude kompilovat. Označuje deklarace metody `ref` vrátit, ale návratový příkaz určuje návratovou hodnotu. Je nutné přidat `ref` – klíčové slovo pro každý příkaz return. Který označuje návrat podle odkazu a pomáhá vývojářům čtení kódu později mějte na paměti, že metoda vrací odkazem:


    ```csharp

    return ref matrix[i,j];

    ```


    Teď, když metoda vrátí odkaz na celočíselnou hodnotu v matici, budete muset upravit, kde je volán. `var` Prohlášení znamená, že `valItem` je teď `int` místo řazené kolekce členů. Volající kód změňte takto:


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    Druhá `WriteLine` příkaz v předchozím příkladu vytiskne hodnotu `42`, nikoli `24`. Proměnná `valItem` je `int`, nikoli `ref int`. `var` – Klíčové slovo umožňuje kompilátoru k určení typu, ale nepřidá implicitně `ref` modifikátor. Místo toho hodnota odkazuje `ref return` je *zkopírovat* do proměnné na levé straně přiřazení. Proměnná není `ref` místní.


    Pokud chcete upravit vráceného odkazu, je potřeba přidat `ref` modifikátoru deklarace lokální proměnné a před volání `Find` při vrácená hodnota je odkaz vytvořit odkaz proměnnou. Upravte testovací kód v prohlížeči tak, aby odpovídala následující:


    [!code-csharp[TestByRef](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByRef "test code for return object by reference")]


    Nyní, druhý `WriteLine` příkaz v předchozím příkladu vytiskne hodnotu `24`, označující, že byla změněna úložiště v matici. Lokální proměnná jsou deklarované v rámci `ref` modifikátor který bude trvat `ref` vrátit. Je nutné inicializovat `ref` proměnné při deklaraci; nelze rozdělit deklaraci a inicializaci.


    Jazyk C# má tři další pravidla, které chrání vás před zneužitím `ref` místní hodnoty a vrátí:


    * Nelze přiřadit standardní metoda návratovou hodnotu pro `ref` místní proměnné.

    * Nelze vrátit `ref` do proměnné, jehož doba života nerozšiřuje nad rámec provádění metody.

    * `ref` místní hodnoty a vrátí nelze použít u asynchronních metod.


    Přidání místní referenční hodnoty a ref vrátí povolit algoritmy, které jsou efektivnější se vyhnout kopírování hodnot nebo provádění operací přesměrování více než jednou.


    Další informace najdete v tématu [ref – klíčové slovo](../../language-reference/keywords/ref.md) článku.
- title: Minimalizovat přístup ke kódu s lokální funkce
  durationInMinutes: 2
  content: "Nyní můžete deklarovat lokální funkce, které jsou vnořené uvnitř jiné funkce. To umožňuje minimalizovat, zda se tyto funkce. Existují tři případy použití zřejmé pro lokální funkce:\n\n- Rekurzivní funkce.\n- Metody iterátorů.\n- Asynchronní metody.\n\nZačněme rekurzivní metody. Následující kód v prohlížeči k výpočtu `6!` (faktoriál):\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\nLokální funkce jsou skvělý způsob, jak implementovat rekurzivní algoritmy. Další běžné způsoby použití jsou určené pro veřejné iterátory a veřejné asynchronní metody. Oba typy metod generování kódu, který bude hlásit chyby později, než se dalo očekávat programátory. V případě metody iterátoru, všechny výjimky, jsou dodržovány pouze při volání metody kód, který uvádí, že vrácená sekvence. V případě asynchronní metody, všechny výjimky jsou pouze dodržovat při vráceného `Task` je očekáváno.\n\nMetody iterátorů se snadněji data prozkoumat v prohlížeči, takže použijeme v tomto průzkumu. Vyzkoušejte následující kód, který volá metodu iterátoru v prohlížeči:\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\nSpusťte kód. Všimněte si, že je vyvolána výjimka, když kód začne iterace druhou sadu výsledků. Kód, který iteruje první sada výsledků byla již spuštěna. Tato ukázka je malý a nezmění žádné datové struktury tak, aby byl neškodné a snadno to vyřešíme. Ale v rozsáhlejšího programu, ve kterém dvěma iterátoru objekty mohou být vytvořeny v metodách různé podřízené kořenové příčinou může být obtížné najít. Pokud první metodu iterátoru změnit stav dat, může i poškození dat. příčinou. Chcete, že byla výjimka okamžitě, předtím, než se provádí veškerou práci. Možné Refaktorovat kód, tak, aby veřejné metody ověří všechny argumenty a lokální funkce provádí výčtu:\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\nPředchozí verze je zřejmé, na který odkazuje místní metodu pouze v kontextu vnější metody. Pravidla pro lokální funkce také zajistěte, aby vývojář nesmí omylem z jiného umístění ve třídě zavolejte funkci Místní a obejít ověřování argumentu.\n\nStejným způsobem mohou být použity s `async` metody k zajištění, že výjimky vyplývající z ověřování argumentu jsou vyvolány před zahájením asynchronní práce.\n\n> [!NOTE]\n> Některé návrhy, které jsou podporovány lokální funkce také je možné dosáhnout použitím *výrazy lambda*. Tyto zúčastněné můžete [Další informace o rozdílech](../../local-functions-vs-lambdas.md).\n"
- content: Dokončili jste vysvětlení hlavní nové funkce v C# 7. Teď vyzkoušejte si je sami ve svých aplikacích. Podívejte se na seznam v [co je nového v C# 7](../../whats-new/csharp-7.md) článku.
