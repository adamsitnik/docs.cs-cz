---
title: Generování a asynchronní datové proudy
description: V tomto kurzu pokročilé znázorňuje scénáře, kdy generování a využívání asynchronní datové proudy poskytuje přirozenější způsob, jak pracovat s posloupností dat, která může být generována asynchronně.
ms.date: 02/10/2019
ms.custom: mvc
ms.openlocfilehash: 0fa7c778ca9ce0f0124fcc520dd4de65f2f92ea8
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2019
ms.locfileid: "59308546"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="2ee1e-103">Kurz: Vygenerování a zpracování datových proudů asynchronní pomocí C# 8.0 a .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="2ee1e-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="2ee1e-104">C#8.0 představuje **asynchronní datové proudy**, který model streamování zdroj dat, pokud prvky v datovém proudu může načíst nebo generována asynchronně.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="2ee1e-105">Spolehněte se na nové rozhraní zavedené v .NET Standard 2.1 a implementovat v .NET Core 3.0 zajištění přirozené programovací model pro asynchronního streamování zdroje dat asynchronní datové proudy.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="2ee1e-106">V tomto kurzu se dozvíte jak:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
> * <span data-ttu-id="2ee1e-107">Vytvořte zdroj dat, který generuje sekvenci prvků data asynchronně.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> * <span data-ttu-id="2ee1e-108">Tento zdroj dat spotřebovat asynchronně.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-108">Consume that data source asynchronously.</span></span>
> * <span data-ttu-id="2ee1e-109">Rozpoznat nové rozhraní a zdroje dat jsou upřednostňované dříve synchronní data sekvencí.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2ee1e-110">Požadavky</span><span class="sxs-lookup"><span data-stu-id="2ee1e-110">Prerequisites</span></span>

<span data-ttu-id="2ee1e-111">Budete muset nastavit počítač pro spuštění .NET Core, včetně C# 8.0 beta verze kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-111">You’ll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.</span></span> <span data-ttu-id="2ee1e-112">C# Je k dispozici od verze 8 beta verze kompilátoru [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), nebo si prohlédnout nejnovější [preview SDK .NET Core 3.0](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span><span class="sxs-lookup"><span data-stu-id="2ee1e-112">The C# 8 beta compiler is available starting with [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the latest [.NET Core 3.0 preview SDK](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span></span> <span data-ttu-id="2ee1e-113">Asynchronní datové proudy jsou nejprve k dispozici v rozhraní .NET Core 3.0 ve verzi preview 1.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-113">Async streams are first available in .NET Core 3.0 preview 1.</span></span>

<span data-ttu-id="2ee1e-114">Budete muset vytvořit [přístupový token Githubu](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) tak, aby vám může přístup ke koncovému bodu GraphQL Githubu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-114">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="2ee1e-115">Vyberte následující oprávnění pro váš Token přístupu Githubu:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-115">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="2ee1e-116">repo:status</span><span class="sxs-lookup"><span data-stu-id="2ee1e-116">repo:status</span></span>
- <span data-ttu-id="2ee1e-117">public_repo</span><span class="sxs-lookup"><span data-stu-id="2ee1e-117">public_repo</span></span>

<span data-ttu-id="2ee1e-118">Uložte přístupový token na bezpečném místě, ve kterém můžete získat přístup ke koncovému bodu rozhraní API Githubu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-118">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="2ee1e-119">Zabezpečit svůj osobní přístupový token.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-119">Keep your personal access token secure.</span></span> <span data-ttu-id="2ee1e-120">Veškerý software s svůj osobní přístupový token může volat rozhraní API Githubu pomocí vašimi přístupovými právy.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-120">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="2ee1e-121">Tento kurz předpokládá, že jste obeznámeni s C# a .NET, včetně sady Visual Studio nebo rozhraní příkazového řádku .NET Core.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-121">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="2ee1e-122">Spuštění aplikace starter</span><span class="sxs-lookup"><span data-stu-id="2ee1e-122">Run the starter application</span></span>

<span data-ttu-id="2ee1e-123">Můžete získat kód pro Startovní aplikace použité v tomto kurzu z našich [dotnet/samples](https://github.com/dotnet/samples) úložiště v [csharp/kurzy/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) složky.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-123">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="2ee1e-124">Startovní aplikace je konzolová aplikace, která používá [Githubu GraphQL](https://developer.github.com/v4/) rozhraní k načtení poslední problémy, které jsou napsané v [dotnet/docs](https://github.com/dotnet/docs) úložiště.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-124">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="2ee1e-125">Začněte zobrazením následující kód pro úvodní aplikaci `Main` metody:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-125">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="2ee1e-126">Můžete buď nastaven `GitHubKey` proměnnou prostředí pro svůj osobní přístupový token, nebo můžete nahradit posledním argumentem ve volání `GenEnvVariable` s svůj osobní přístupový token.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-126">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="2ee1e-127">Neumisťujte přístupový kód ve zdrojovém kódu Pokud budete se ukládání zdroji s ostatními, nebo jej v úložišti sdílené zdroje.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-127">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="2ee1e-128">Po vytvoření klienta Githubu, kód v `Main` vytvoří průběh vytváření sestav objektu a token zrušení.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-128">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="2ee1e-129">Po vytvoření těchto objektů `Main` volání `runPagedQueryAsync` načíst posledních 250 vytvořili problémy.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-129">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="2ee1e-130">Po dokončení této úlohy se zobrazí výsledky.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-130">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="2ee1e-131">Při spuštění aplikace starter, můžete provést některé důležité skutečnosti o tom, jak tato aplikace funguje.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-131">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="2ee1e-132">Zobrazí se průběh pro každou stránku vrácená z Githubu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-132">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="2ee1e-133">Patrné pozastavení můžete sledovat, před vrácením každou novou stránku problémy Githubu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-133">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="2ee1e-134">A konečně problémy se zobrazí až po všech 10 stránek byly načteny z Githubu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-134">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="2ee1e-135">Vyzkoušení implementace</span><span class="sxs-lookup"><span data-stu-id="2ee1e-135">Examine the implementation</span></span>

<span data-ttu-id="2ee1e-136">Implementace odhalí důvod, proč jste zaznamenali chování popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-136">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="2ee1e-137">Zkontrolujte kód pro `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-137">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="2ee1e-138">Pojďme se soustředit na stránkování algoritmus a asynchronní konstrukce předchozí kód.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-138">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="2ee1e-139">(Můžete konzultovat [dokumentace Githubu GraphQL](https://developer.github.com/v4/guides/) podrobnosti o rozhraní API Githubu GraphQL.) `runPagedQueryAsync` Metoda výčet problémů od nejnovější po nejstarší.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-139">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="2ee1e-140">Požaduje 25 problémy na jedné stránce a zkoumá `pageInfo` struktura odpovědi a pokračujte na předchozí stránku.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-140">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="2ee1e-141">Který sleduje GraphQL na standardní podporu stránkování pro více stránek odpovědí.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-141">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="2ee1e-142">Odpověď obsahuje `pageInfo` objekt, který zahrnuje `hasPreviousPages` hodnotu a `startCursor` hodnota používaná pro požádání o na předchozí stránku.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-142">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="2ee1e-143">Tyto problémy jsou v `nodes` pole.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-143">The issues are in the `nodes` array.</span></span> <span data-ttu-id="2ee1e-144">`runPagedQueryAsync` Metoda přidá tyto uzly na pole, která obsahuje všechny výsledky ze všech stránek.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-144">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="2ee1e-145">Po načtení a obnovení stránku výsledků, `runPagedQueryAsync` hlásí průběh a kontroluje zrušení.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-145">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="2ee1e-146">Pokud bylo vyžádáno zrušení, `runPagedQueryAsync` vyvolá <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-146">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="2ee1e-147">Existuje několik elementů v tento kód, který se může zlepšit.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-147">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="2ee1e-148">Co je nejdůležitější `runPagedQueryAsync` musí přidělit úložiště pro všechny problémy, které jsou vráceny.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-148">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="2ee1e-149">Tato ukázka se zastaví na 250 problémy vzhledem k tomu, že načítání všech otevřených problémů by vyžadoval víc paměti pro ukládání všechny načtené problémy.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-149">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="2ee1e-150">Kromě toho protokoly pro podporu průběh a podporuje zrušení znesnadnit algoritmus pochopit na jeho nejprve přečíst.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-150">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="2ee1e-151">Je třeba najít třídu průběh najít, kde hlášení.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-151">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="2ee1e-152">Budete také muset trasování komunikace prostřednictvím <xref:System.Threading.CancellationTokenSource> spolu s přidruženými <xref:System.Threading.CancellationToken> pochopit, kde je požadováno zrušení a je-li poskytnuta.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-152">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="2ee1e-153">Asynchronní datové proudy poskytují lepší způsob</span><span class="sxs-lookup"><span data-stu-id="2ee1e-153">Async streams provide a better way</span></span>

<span data-ttu-id="2ee1e-154">Asynchronní datové proudy a přiřazená jazyková podpora řeší všechny tyto aspekty.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-154">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="2ee1e-155">Teď můžete použít kód, který generuje sekvenci `yield return` vrátit prvky v metodě, která byla deklarována pomocí `async` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-155">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="2ee1e-156">Můžete využívat na asynchronní datový proud pomocí `await foreach` smyčky, stejně jako využívat jakékoli pořadí pomocí `foreach` smyčky.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-156">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="2ee1e-157">Tyto nové funkce jazyka závisí na třech nových rozhraní přidány do .NET Standard 2.1 a implementovat v .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-157">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="2ee1e-158">Tyto tři rozhraní by měl být většina C# vývojáři.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-158">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="2ee1e-159">Chovají se podobně jako jejich protějšky v synchronním způsobem:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-159">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="2ee1e-160">Jeden typ, který může být obeznámeni se <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-160">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2ee1e-161">`ValueTask` Struktury poskytuje podobné rozhraní API k <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-161">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> `ValueTask` <span data-ttu-id="2ee1e-162">se používá v těchto rozhraní z důvodů výkonu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-162">is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="2ee1e-163">Převést na asynchronní datové proudy</span><span class="sxs-lookup"><span data-stu-id="2ee1e-163">Convert to async streams</span></span>

<span data-ttu-id="2ee1e-164">V dalším kroku převést `runPagedQueryAsync` metoda ke generování na asynchronní datový proud.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-164">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="2ee1e-165">Nejprve změňte podpis `runPagedQueryAsync` se vraťte `IAsyncEnumerable<JToken>`a zrušení tokenu a průběh objekty odebrat ze seznamu parametrů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-165">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="2ee1e-166">Počáteční kód zpracovává každé stránce jako se stránka načte, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-166">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="2ee1e-167">Tyto tři řádky nahraďte následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-167">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="2ee1e-168">Můžete také odebrat deklaraci `finalResults` výše v této metodě a `return` příkazu, který následuje smyčky změnil.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-168">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="2ee1e-169">Dokončili jste změny Generovat asynchronní proud.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-169">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="2ee1e-170">Dokončená metoda by se mělo podobat následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-170">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="2ee1e-171">V dalším kroku změníte kód, který využívá kolekce, kterou chcete používat asynchronní datový proud.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-171">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="2ee1e-172">Následující kód, který v `Main` , která zpracovává sadu problémy:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-172">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="2ee1e-173">Nahraďte kód následujícím kódem `await foreach` smyčka:</span><span class="sxs-lookup"><span data-stu-id="2ee1e-173">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="2ee1e-174">Můžete získat kód pro dokončení kurzu z [dotnet/samples](https://github.com/dotnet/samples) úložiště v [csharp/kurzy/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) složky.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-174">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="2ee1e-175">Spusťte dokončenou aplikaci</span><span class="sxs-lookup"><span data-stu-id="2ee1e-175">Run the finished application</span></span>

<span data-ttu-id="2ee1e-176">Spusťte aplikaci znovu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-176">Run the application again.</span></span> <span data-ttu-id="2ee1e-177">Porovnejte své chování s chováním Startovní aplikace.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-177">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="2ee1e-178">První stránka výsledků je vypočten, jakmile je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-178">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="2ee1e-179">Každá nová stránka je požadováno a načíst je pozorovatelných pozastavit a potom rychle vytvořit výčet další stránky výsledků.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-179">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="2ee1e-180">`try`  /  `catch` Bloku není potřeba ke zpracování zrušení: volající zastavit vyčíslení kolekce.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-180">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="2ee1e-181">Jasně hlášení vzhledem k tomu, že asynchronní datový proud generuje výsledky stažené každou stránku.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-181">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span>

<span data-ttu-id="2ee1e-182">Uvidíte zdokonalení využití paměti porovnáním kód.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-182">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="2ee1e-183">Už nemusíte přidělit kolekce pro ukládání všech výsledků, předtím, než jste výčtu.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-183">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="2ee1e-184">Volající můžete určit, jak využívat výsledky a pokud je zapotřebí úložiště kolekce.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-184">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="2ee1e-185">Spustit počáteční i hotové aplikace a můžete sledovat rozdílů mezi implementacemi sami.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-185">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="2ee1e-186">Můžete odstranit přístupový token Githubu, který jste vytvořili při spuštění v tomto kurzu po dokončení.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-186">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="2ee1e-187">Pokud útočník získal přístup do tohoto tokenu, může přístup k rozhraní API Githubu pomocí svých přihlašovacích údajů.</span><span class="sxs-lookup"><span data-stu-id="2ee1e-187">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
