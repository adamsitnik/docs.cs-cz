---
title: Porovnávání vzorů – průvodce v C#
description: Další informace o vzoru porovnávání výrazů v jazyce C#
ms.date: 04/10/2019
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 5ace3c4552184b848b90dee3516d549ca8fd5806
ms.sourcegitcommit: 859b2ba0c74a1a5a4ad0d59a3c3af23450995981
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/11/2019
ms.locfileid: "59481363"
---
# <a name="pattern-matching"></a><span data-ttu-id="e3251-103">Porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="e3251-103">Pattern Matching</span></span>

<span data-ttu-id="e3251-104">Vzory testování, že hodnota patří k určitým *tvar*a můžete *extrahovat* informace z hodnotu, pokud má odpovídající obrazce.</span><span class="sxs-lookup"><span data-stu-id="e3251-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="e3251-105">Porovnávání vzorů poskytuje stručnější syntaxi pro algoritmy, které už máte ještě dnes.</span><span class="sxs-lookup"><span data-stu-id="e3251-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="e3251-106">Jste již vytvořili porovnávání vzorů pomocí syntaxe pro stávající algoritmy.</span><span class="sxs-lookup"><span data-stu-id="e3251-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="e3251-107">Při psaní `if` nebo `switch` příkazy, které testují hodnoty.</span><span class="sxs-lookup"><span data-stu-id="e3251-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="e3251-108">Když tyto příkazy odpovídají, potom extrahovat a používat informace z této hodnoty.</span><span class="sxs-lookup"><span data-stu-id="e3251-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="e3251-109">Nové prvky syntaxe jsou rozšíření pro příkazy, které jste již obeznámeni s: `is` a `switch`.</span><span class="sxs-lookup"><span data-stu-id="e3251-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="e3251-110">Tyto nové přípony kombinovat testování hodnotu a extrakci těchto informací.</span><span class="sxs-lookup"><span data-stu-id="e3251-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="e3251-111">V tomto článku se podíváme na novou syntaxi až vám ukážeme, jak umožňuje čitelný a stručné kódu.</span><span class="sxs-lookup"><span data-stu-id="e3251-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="e3251-112">Porovnávání vzorů umožňuje idiomy kde data a kód jsou oddělené, na rozdíl od objektově orientované vzory, kde data a metody, které s nimi manipulovat jsou úzce svázány.</span><span class="sxs-lookup"><span data-stu-id="e3251-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="e3251-113">Pro ilustraci, tyto nové idiomy, budeme pracovat s struktury, které představují geometrické tvary pomocí porovnávání vzorů příkazy.</span><span class="sxs-lookup"><span data-stu-id="e3251-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="e3251-114">Už pravděpodobně znáte vytváření hierarchií tříd a vytváření [virtuální metody a přepsané metody](methods.md#inherited) k přizpůsobení chování objektu na základě modulu runtime typu objektu.</span><span class="sxs-lookup"><span data-stu-id="e3251-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="e3251-115">Tyto metody nejsou pro data, která neodpovídá struktuře hierarchie tříd je to možné.</span><span class="sxs-lookup"><span data-stu-id="e3251-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="e3251-116">Pokud data a metody jsou oddělené, je potřeba další nástroje.</span><span class="sxs-lookup"><span data-stu-id="e3251-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="e3251-117">Nové *porovnávání vzorů* konstrukce povolit přehlednější syntaxe sloužící ke zkoumání dat a manipulaci s řízení toku na základě těchto dat všechny podmínky.</span><span class="sxs-lookup"><span data-stu-id="e3251-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="e3251-118">Již píšete `if` příkazy a `switch` , které testují hodnota proměnné.</span><span class="sxs-lookup"><span data-stu-id="e3251-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="e3251-119">Při psaní `is` příkazy, které typ proměnné testu.</span><span class="sxs-lookup"><span data-stu-id="e3251-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="e3251-120">*Porovnávání vzorů* přidává nové funkce pro tyto příkazy.</span><span class="sxs-lookup"><span data-stu-id="e3251-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="e3251-121">V tomto článku budete vytvářet metodu, která vypočítá oblasti jiné geometrické tvary.</span><span class="sxs-lookup"><span data-stu-id="e3251-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="e3251-122">Ale můžete udělat bez nutnosti uchýlit se k objektově orientované techniky a vytvoření hierarchie tříd u různých tvarů.</span><span class="sxs-lookup"><span data-stu-id="e3251-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="e3251-123">Budete používat *porovnávání vzorů* místo.</span><span class="sxs-lookup"><span data-stu-id="e3251-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="e3251-124">Při procházení této ukázce, kontrast tohoto kódu s jakým způsobem bude strukturovaná jako hierarchii objektů.</span><span class="sxs-lookup"><span data-stu-id="e3251-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="e3251-125">Když data musíte dotazování a manipulaci s není hierarchie tříd, porovnávání vzorů umožňuje elegantní návrhy.</span><span class="sxs-lookup"><span data-stu-id="e3251-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="e3251-126">Namísto počínaje definici abstraktní tvar a přidávání odlišném tvaru konkrétních tříd, začneme místo toho jednoduchou datovou pouze definice pro každý geometrické tvary:</span><span class="sxs-lookup"><span data-stu-id="e3251-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="e3251-127">Z těchto struktur napište metodu, která vypočítá oblasti nějaké obrazce.</span><span class="sxs-lookup"><span data-stu-id="e3251-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="e3251-128">`is` Zadejte výraz vzoru</span><span class="sxs-lookup"><span data-stu-id="e3251-128">The `is` type pattern expression</span></span>

<span data-ttu-id="e3251-129">Před C# 7.0, je třeba, otestujte všechny typy v řadě `if` a `is` příkazy:</span><span class="sxs-lookup"><span data-stu-id="e3251-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="e3251-130">Je výše uvedený kód výrazu classic *vzor typu*: Provedete testování proměnnou k určení jeho typu a různé akce na základě tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="e3251-131">Tento kód bude jednodušší pomocí rozšíření `is` výrazu přiřazení proměnných Pokud test proběhne úspěšně:</span><span class="sxs-lookup"><span data-stu-id="e3251-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="e3251-132">V této verzi aktualizované `is` výraz testuje proměnné i přiřadí ji nové proměnné typu správné.</span><span class="sxs-lookup"><span data-stu-id="e3251-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="e3251-133">Také, Všimněte si, že tato verze zahrnuje `Rectangle` typ, který je `struct`.</span><span class="sxs-lookup"><span data-stu-id="e3251-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="e3251-134">Nové `is` výraz pracuje s typy hodnot a typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="e3251-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="e3251-135">Jazyk pravidel pro vzor odpovídající výrazy snáze vyhnete zneužití výsledky odpovídající výraz.</span><span class="sxs-lookup"><span data-stu-id="e3251-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="e3251-136">V příkladu výše, proměnné `s`, `c`, a `r` pouze v určitém rozsahu a jednoznačně přiřazena při výrazy porovnání odpovídající vzoru `true` výsledky.</span><span class="sxs-lookup"><span data-stu-id="e3251-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="e3251-137">Pokud se pokusíte použít buď proměnnou na jiné místo, vygeneruje kód chyby kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="e3251-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="e3251-138">Podívejme se na obě tato pravidla podrobně, počínaje oboru.</span><span class="sxs-lookup"><span data-stu-id="e3251-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="e3251-139">Proměnná `c` je v oboru pouze v `else` větev první `if` příkazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="e3251-140">Proměnná `s` je v oboru v metodě `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="e3251-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="e3251-141">Důvodem je, že každá větev `if` příkaz vytváří samostatný obor pro proměnné.</span><span class="sxs-lookup"><span data-stu-id="e3251-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="e3251-142">Ale `if` nepodporuje příkaz samotný.</span><span class="sxs-lookup"><span data-stu-id="e3251-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="e3251-143">To znamená, že proměnné deklarované v `if` jsou ve stejném oboru jako `if` – příkaz (metody v tomto případě.) Toto chování se neomezuje jen na porovnávání vzorů, ale je definované chování proměnné obory a `if` a `else` příkazy.</span><span class="sxs-lookup"><span data-stu-id="e3251-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="e3251-144">Proměnné `c` a `s` jsou přiřazeny při funkcím `if` tvrzení jsou pravdivá kvůli jednoznačně přiřazené při true mechanismus.</span><span class="sxs-lookup"><span data-stu-id="e3251-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="e3251-145">Ukázky v tomto tématu použijte doporučenou konstrukce, kde je porovnávání `is` výraz jednoznačně přiřadí proměnné shody v `true` větev `if` příkazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="e3251-146">Logika může obrátit vyslovením `if (!(shape is Square s))` a proměnná `s` by být přiřazen pouze v `false` větve.</span><span class="sxs-lookup"><span data-stu-id="e3251-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="e3251-147">Když je platný C#, se nedoporučuje, protože je pro postupujte podle logiky více matoucí.</span><span class="sxs-lookup"><span data-stu-id="e3251-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="e3251-148">Tato pravidla znamená, že jste nepravděpodobné, že omylem přístupu výsledek výrazu shoda vzoru v případě, že nebyla splněna tento vzor.</span><span class="sxs-lookup"><span data-stu-id="e3251-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="e3251-149">Použití porovnávání vzorů `switch` příkazy</span><span class="sxs-lookup"><span data-stu-id="e3251-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="e3251-150">Když čas proběhne, budete možná potřebovat k podpoře jiných typů tvaru.</span><span class="sxs-lookup"><span data-stu-id="e3251-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="e3251-151">Roste počet podmínek, které testujete, zjistíte to pomocí `is` vzoru porovnávání výrazů může být náročné.</span><span class="sxs-lookup"><span data-stu-id="e3251-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="e3251-152">Kromě nutnosti `if` příkazy pro každý typ, který chcete zkontrolovat, `is` výrazy jsou omezené na testování, pokud je vstup odpovídá jednoho typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="e3251-153">V takovém případě zjistíte, která `switch` vzor odpovídající výrazy bude vhodnější volbou.</span><span class="sxs-lookup"><span data-stu-id="e3251-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="e3251-154">Tradiční `switch` příkaz byl výraz vzoru: podporované konstantní vzorek.</span><span class="sxs-lookup"><span data-stu-id="e3251-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="e3251-155">Můžete porovnat proměnnou pro libovolná konstanta použita ve `case` – příkaz:</span><span class="sxs-lookup"><span data-stu-id="e3251-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="e3251-156">Pouze vzoru podporovanému službou `switch` příkaz byl konstantní vzorek.</span><span class="sxs-lookup"><span data-stu-id="e3251-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="e3251-157">Byla dále omezená na číselné typy a `string` typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="e3251-158">Tato omezení se odebraly a teď můžete psát `switch` zahrne příkaz using vzor typu:</span><span class="sxs-lookup"><span data-stu-id="e3251-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="e3251-159">Porovnávání vzorů `switch` příkaz používá známou syntaxi pro vývojáře, kteří používali tradiční C-style `switch` příkazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="e3251-160">Každý `case` je vyhodnocen a spuštění kódu pod podmínkou, že odpovídá je vstupní proměnná.</span><span class="sxs-lookup"><span data-stu-id="e3251-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="e3251-161">Spuštění kódu se nedá "předat" z jeden výraz case na další. syntaxe `case` příkazu vyžaduje každý `case` končit `break`, `return`, nebo `goto`.</span><span class="sxs-lookup"><span data-stu-id="e3251-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="e3251-162">`goto` Příkazy pro přechod na jiný popisek jsou platné pouze pro konstantní vzorek (příkazu classic switch).</span><span class="sxs-lookup"><span data-stu-id="e3251-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="e3251-163">Existují důležité nová pravidla, kterými se řídí `switch` příkazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="e3251-164">Omezení typu proměnné v `switch` výraz byly odebrány.</span><span class="sxs-lookup"><span data-stu-id="e3251-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="e3251-165">Jakýkoli typ, jako například `object` v tomto příkladu může být použit.</span><span class="sxs-lookup"><span data-stu-id="e3251-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="e3251-166">Výrazy case, už nejsou omezeny na konstantní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="e3251-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="e3251-167">Odebírá se těmto omezením znamená, že tuto změnu pořadí `switch` oddíly se může změnit chování programu.</span><span class="sxs-lookup"><span data-stu-id="e3251-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="e3251-168">Když omezeno na konstantní hodnoty, ne více než jedna `case` popisek může odpovídat hodnotě `switch` výraz.</span><span class="sxs-lookup"><span data-stu-id="e3251-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="e3251-169">Kombinovat s pravidlem, které každý `switch` části nesmí být předáno do další části a ho a potom, `switch` oddíly může být změnit jejich uspořádání v libovolném pořadí bez ovlivnění chování.</span><span class="sxs-lookup"><span data-stu-id="e3251-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="e3251-170">Nyní, s více zobecnit `switch` výrazy, záleží na pořadí jednotlivých oddílů.</span><span class="sxs-lookup"><span data-stu-id="e3251-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="e3251-171">`switch` Výrazy jsou vyhodnocovány v pořadí textové.</span><span class="sxs-lookup"><span data-stu-id="e3251-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="e3251-172">Vykonávání se přenese na první `switch` popisek, který odpovídá `switch` výrazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="e3251-173">`default` Případu se spustí pouze pokud žádné popisky případů odpovídají.</span><span class="sxs-lookup"><span data-stu-id="e3251-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="e3251-174">`default` Případu se vyhodnocují jako poslední, bez ohledu na jeho textové pořadí.</span><span class="sxs-lookup"><span data-stu-id="e3251-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="e3251-175">Pokud není žádné `default` případ a žádný z nich `case` příkazy shodují, provádění pokračuje na příkazu za `switch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="e3251-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="e3251-176">Žádná z `case` popisky kód je spuštěn.</span><span class="sxs-lookup"><span data-stu-id="e3251-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="e3251-177">`when` Klauzule v `case` výrazy</span><span class="sxs-lookup"><span data-stu-id="e3251-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="e3251-178">Můžete provést zvláštní případy, které mají 0 oblasti s použitím tvarů `when` klauzuli `case` popisek.</span><span class="sxs-lookup"><span data-stu-id="e3251-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="e3251-179">Čtverec o délce na straně 0 nebo kruhu s poloměrem 0 má 0 oblasti.</span><span class="sxs-lookup"><span data-stu-id="e3251-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="e3251-180">Určíte, že při použití podmínky `when` klauzuli `case` popisku:</span><span class="sxs-lookup"><span data-stu-id="e3251-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="e3251-181">Tato změna ukazuje několik důležitých bodů o nové syntaxe.</span><span class="sxs-lookup"><span data-stu-id="e3251-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="e3251-182">Nejprve je potřeba více `case` popisky můžete použít k jednomu `switch` oddílu.</span><span class="sxs-lookup"><span data-stu-id="e3251-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="e3251-183">Spuštění tohoto bloku příkazů Pokud některý z nich je `true`.</span><span class="sxs-lookup"><span data-stu-id="e3251-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="e3251-184">V takovém případě pokud `switch` výraz je kruh nebo čtverec s 0 oblastí, metoda vrátí – konstanta 0.</span><span class="sxs-lookup"><span data-stu-id="e3251-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="e3251-185">V tomto příkladu zavádí dvě různé proměnné ve dvou `case` popisky pro první `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="e3251-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="e3251-186">Všimněte si, že příkazy v tomto `switch` bloku nepoužívejte buď proměnné `c` (pro kruhu) nebo `s` (pro druhou mocninu).</span><span class="sxs-lookup"><span data-stu-id="e3251-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="e3251-187">Ani jeden z těchto proměnných je jednoznačně přiřazena v tomto `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="e3251-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="e3251-188">Pokud některý z těchto případů shodují, se přiřadí jasně jedna z proměnných.</span><span class="sxs-lookup"><span data-stu-id="e3251-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="e3251-189">Je však možné předat *který* byla přiřazena v době kompilace, protože obou případech může odpovídat za běhu.</span><span class="sxs-lookup"><span data-stu-id="e3251-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="e3251-190">Z tohoto důvodu většinou při použití více `case` popisky pro stejný blok, nezpůsobí novou proměnnou `case` příkazu, nebo budete používat pouze proměnné v `when` klauzule.</span><span class="sxs-lookup"><span data-stu-id="e3251-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="e3251-191">Přidání tvarů s 0 oblastí přidáme několik dalších typů obrazce: obdélníku a trojúhelník:</span><span class="sxs-lookup"><span data-stu-id="e3251-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="e3251-192">Tato sada změn přidá `case` popisků degenerovanou případech popisky a bloky pro každé nové obrazce.</span><span class="sxs-lookup"><span data-stu-id="e3251-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="e3251-193">Nakonec můžete přidat `null` případ zajistit argument není `null`:</span><span class="sxs-lookup"><span data-stu-id="e3251-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="e3251-194">Zvláštní chování `null` vzor je zajímavé protože konstanty `null` ve vzoru nemá typ, ale je možné převést na kterýkoli typ odkazu nebo typ připouštějící hodnotu Null.</span><span class="sxs-lookup"><span data-stu-id="e3251-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="e3251-195">Místo převést `null` na libovolný typ, který definuje jazyk `null` hodnoty nebudou odpovídat libovolný typ vzor, bez ohledu na kompilaci typu proměnné.</span><span class="sxs-lookup"><span data-stu-id="e3251-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="e3251-196">Díky tomuto chování nové `switch` na základě typu vzor konzistentní s `is` – příkaz: `is` příkazy vždy vrátit `false` Pokud je hodnotou kontroluje `null`.</span><span class="sxs-lookup"><span data-stu-id="e3251-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="e3251-197">Je také jednodušší: až si projdete typ, není nutné další kontrolu hodnot null.</span><span class="sxs-lookup"><span data-stu-id="e3251-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="e3251-198">Uvidíte, že ze skutečnosti, že neexistují žádné null zkontroluje v žádném případě bloků výše uvedené ukázky: nejsou potřebné, protože odpovídající vzoru typ záruky nenulová hodnota.</span><span class="sxs-lookup"><span data-stu-id="e3251-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="e3251-199">`var` deklarace v `case` výrazy</span><span class="sxs-lookup"><span data-stu-id="e3251-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="e3251-200">Po zavedení služby `var` jako jeden z výrazů shoda zavádí nová pravidla pro shodu vzoru.</span><span class="sxs-lookup"><span data-stu-id="e3251-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="e3251-201">První pravidlo je, že `var` normální typ odvozených pravidel, následuje po deklaraci: Typ je odvozen být statického typu výrazu přepínače.</span><span class="sxs-lookup"><span data-stu-id="e3251-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="e3251-202">Z tohoto pravidla vždy odpovídá typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="e3251-203">Druhé pravidlo je, že `var` deklarace nemá kontrolu hodnot null, které zahrnují další vzorek výrazy typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="e3251-204">To znamená, že proměnná může mít hodnotu null a v takovém případě je nutné kontrolu hodnot null.</span><span class="sxs-lookup"><span data-stu-id="e3251-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="e3251-205">Znamenají, že tyto dvě pravidla v mnoha případech `var` deklarace v `case` výraz odpovídá za stejných podmínek jako `default` výrazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="e3251-206">Protože libovolné nevýchozí případ je upřednostňována před `default` případech `default` případu se nikdy neprovede.</span><span class="sxs-lookup"><span data-stu-id="e3251-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="e3251-207">Kompilátor negeneruje upozornění v případech, kde `default` případ byl zapsán ale se nikdy neprovede.</span><span class="sxs-lookup"><span data-stu-id="e3251-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="e3251-208">To je konzistentní s aktuálním `switch` chování příkazu, ve kterém byly vypsali všechny možné případy.</span><span class="sxs-lookup"><span data-stu-id="e3251-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="e3251-209">Třetí pravidlo představuje používá kde `var` případě může být užitečné.</span><span class="sxs-lookup"><span data-stu-id="e3251-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="e3251-210">Představte si, že provádíte porovnávání, pokud je vstupní řetězec a hledáte známého příkazu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="e3251-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="e3251-211">Můžete například napsat vypadat:</span><span class="sxs-lookup"><span data-stu-id="e3251-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="e3251-212">`var` Malá a velká shody `null`, prázdný řetězec nebo libovolný řetězec, který obsahuje pouze prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="e3251-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="e3251-213">Všimněte si, že předchozí kód používá `?.` operátor Ujistěte se, že nevyvolá omylem <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="e3251-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="e3251-214">`default` Případ zpracovává libovolné řetězcové hodnoty, které nebudou srozumitelné pro tento příkaz analyzátor.</span><span class="sxs-lookup"><span data-stu-id="e3251-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="e3251-215">Toto je jeden příklad, kde můžete chtít zvážit `var` malá a velká výraz, který se liší od `default` výrazu.</span><span class="sxs-lookup"><span data-stu-id="e3251-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="e3251-216">Závěry</span><span class="sxs-lookup"><span data-stu-id="e3251-216">Conclusions</span></span>

<span data-ttu-id="e3251-217">*Vzor odpovídající konstrukce* vám umožní snadno spravovat tok řízení mezi různé proměnné a typy, které spolu nesouvisí podle hierarchie dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="e3251-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="e3251-218">Můžete také řídit logiku na proměnnou používat jakoukoli podmínku, kterou testujete.</span><span class="sxs-lookup"><span data-stu-id="e3251-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="e3251-219">Umožňuje vzory a idiomy, které budete potřebovat více často, jak vytvářet více distribuovaných aplikací, kde jsou oddělené data a metody, které zpracovávají data.</span><span class="sxs-lookup"><span data-stu-id="e3251-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="e3251-220">Všimněte si, že tvar struktury používané v tomto příkladu neobsahují žádné metody pouze vlastnosti jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="e3251-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="e3251-221">Porovnávání vzorů spolupracuje s libovolného datového typu.</span><span class="sxs-lookup"><span data-stu-id="e3251-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="e3251-222">Zápis výrazů, které prověřit objekt a rozhodování řízení toku na základě těchto podmínek.</span><span class="sxs-lookup"><span data-stu-id="e3251-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="e3251-223">Porovnat kód od této ukázky s návrhem, které by od vytvoření hierarchie tříd pro abstraktní následují `Shape` a konkrétní odvozený obrazce, každý s vlastní implementaci virtuální metody pro výpočet.</span><span class="sxs-lookup"><span data-stu-id="e3251-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="e3251-224">Budete často zjistíte, že odpovídající výrazy vzorek může být velmi užitečným nástrojem při práci s daty a chcete aspekty chování nezávislá na infrastruktuře úložiště dat nemuseli dělat starosti.</span><span class="sxs-lookup"><span data-stu-id="e3251-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>
