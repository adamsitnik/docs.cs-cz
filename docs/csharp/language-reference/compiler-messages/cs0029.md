---
title: Chyba kompilátoru CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 20874eaa2f07832ae28c6ef69927e022bbdbb6c5
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54663125"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="48a2e-102">Chyba kompilátoru CS0029</span><span class="sxs-lookup"><span data-stu-id="48a2e-102">Compiler Error CS0029</span></span>

<span data-ttu-id="48a2e-103">Nelze implicitně převést na typ 'type' na 'type'</span><span class="sxs-lookup"><span data-stu-id="48a2e-103">Cannot implicitly convert type 'type' to 'type'</span></span>  
  
 <span data-ttu-id="48a2e-104">Kompilátor, vyžaduje explicitní převod.</span><span class="sxs-lookup"><span data-stu-id="48a2e-104">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="48a2e-105">Potřebujete například přetypování r-value být stejného typu jako l hodnotou.</span><span class="sxs-lookup"><span data-stu-id="48a2e-105">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="48a2e-106">Nebo, je nutné zadat převodní rutiny pro podporu určitých přetížení operátoru.</span><span class="sxs-lookup"><span data-stu-id="48a2e-106">Or, you must provide conversion routines to support certain operator overloads.</span></span>  
  
 <span data-ttu-id="48a2e-107">Při přiřazování proměnnou jeden typ proměnné jiného typu se musí vyskytovat převody.</span><span class="sxs-lookup"><span data-stu-id="48a2e-107">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="48a2e-108">Při vytváření přiřazení mezi různých typů proměnných, musí kompilátor převést typ na pravé straně operátoru přiřazení k typu na levé straně operátoru přiřazení.</span><span class="sxs-lookup"><span data-stu-id="48a2e-108">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="48a2e-109">Následující kód:</span><span class="sxs-lookup"><span data-stu-id="48a2e-109">Take the following the code:</span></span>  

```csharp
int i = 50;  
long lng = 100;  
i = lng;  
```

 <span data-ttu-id="48a2e-110">`i = lng;` Díky přiřazení, ale datové typy proměnných na levé a pravé straně operátoru přiřazení se neshodují.</span><span class="sxs-lookup"><span data-stu-id="48a2e-110">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="48a2e-111">Před provedením kompilátor přiřazení je implicitně převod proměnné `lng`, která je typu long na celé číslo Toto je implicitní, protože žádný kód explicitně pokyn kompilátoru k provedení tohoto převodu.</span><span class="sxs-lookup"><span data-stu-id="48a2e-111">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="48a2e-112">Problém s tímto kódem je, že tato skutečnost považována za zužující převod, a kompilátor nepovoluje implicitní zužující převody, protože můžou být potenciální ztrátě dat.</span><span class="sxs-lookup"><span data-stu-id="48a2e-112">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>  
  
 <span data-ttu-id="48a2e-113">Zužující převod existuje při převodu na datový typ, který zabírá méně místa v paměti než datový typ, který převádíme.</span><span class="sxs-lookup"><span data-stu-id="48a2e-113">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="48a2e-114">Například převod typu long int bude považovat za zužující převod.</span><span class="sxs-lookup"><span data-stu-id="48a2e-114">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="48a2e-115">Dlouho zabírá 8 bajtů paměti, zatímco zabírá celé číslo 4 bajty.</span><span class="sxs-lookup"><span data-stu-id="48a2e-115">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="48a2e-116">Pokud chcete zobrazit, jak může dojít ke ztrátě dat, vezměte v úvahu následující ukázce:</span><span class="sxs-lookup"><span data-stu-id="48a2e-116">To see how data loss can occur, consider the following sample:</span></span>  

```csharp
int i = 50;  
long lng = 3147483647;  
i = lng;  
```

 <span data-ttu-id="48a2e-117">Proměnná `lng` teď obsahuje hodnotu, která nemůže být uložen v proměnné `i` protože je moc velká.</span><span class="sxs-lookup"><span data-stu-id="48a2e-117">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="48a2e-118">Pokud bychom měli převést tuto hodnotu na typ int jsme by ztráty, některé z našich dat a převedená hodnota nemusí být stejná jako hodnota před převodem.</span><span class="sxs-lookup"><span data-stu-id="48a2e-118">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>  
  
 <span data-ttu-id="48a2e-119">Rozšiřující převod může být opakem zužující převod.</span><span class="sxs-lookup"><span data-stu-id="48a2e-119">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="48a2e-120">S rozšiřující převody, jsme převodu na datový typ, který bude zabírat více prostoru úložiště v paměti než datový typ, který převádíme.</span><span class="sxs-lookup"><span data-stu-id="48a2e-120">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="48a2e-121">Tady je příklad rozšiřujícího převodu:</span><span class="sxs-lookup"><span data-stu-id="48a2e-121">Here is an example of a widening conversion:</span></span>  

```csharp
int i = 50;  
long lng = 100;  
lng = i;  
```

 <span data-ttu-id="48a2e-122">Všimněte si rozdílu mezi tento vzorový kód a první.</span><span class="sxs-lookup"><span data-stu-id="48a2e-122">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="48a2e-123">V tuto chvíli proměnnou `lng` je na levé straně operátoru přiřazení tak, aby byl cílový našeho přiřazení.</span><span class="sxs-lookup"><span data-stu-id="48a2e-123">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="48a2e-124">Předtím, než může být přiřazení provedeno, musí kompilátor implicitně převést proměnnou `i`, což je typ int na typ long.</span><span class="sxs-lookup"><span data-stu-id="48a2e-124">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="48a2e-125">To je rozšiřující převod protože jsme se převod z typu, který bude zabírat 4 bajty paměti (int) na typ, který bude zabírat 8 bajtů paměti (dlouhé).</span><span class="sxs-lookup"><span data-stu-id="48a2e-125">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="48a2e-126">Implicitní rozšiřující převody jsou povolená, protože neexistuje žádný potenciální ztráta dat.</span><span class="sxs-lookup"><span data-stu-id="48a2e-126">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="48a2e-127">Libovolnou hodnotu, která můžou být uložené v int mohou také uložené v typu long.</span><span class="sxs-lookup"><span data-stu-id="48a2e-127">Any value that can be stored in an int can also be stored in a long.</span></span>  
  
 <span data-ttu-id="48a2e-128">Víme, že nejsou povoleny implicitní zužující převody, tak abyste mohli tento kód zkompilovat potřebujeme k explicitnímu převodu datového typu.</span><span class="sxs-lookup"><span data-stu-id="48a2e-128">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="48a2e-129">Explicitní převody jsou prováděny pomocí přetypování.</span><span class="sxs-lookup"><span data-stu-id="48a2e-129">Explicit conversions are done using casting.</span></span> <span data-ttu-id="48a2e-130">Přetypování je pojem používaný v jazyce C# pro převod jednoho datového typu na jiný.</span><span class="sxs-lookup"><span data-stu-id="48a2e-130">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="48a2e-131">Chcete-li získat kód mohl zkompilovat by musíme použijte následující syntaxi:</span><span class="sxs-lookup"><span data-stu-id="48a2e-131">To get the code to compile we would need to use the following syntax:</span></span>  

```csharp
int i = 50;  
long lng = 100;  
i = (int) lng;   // cast to int  
```

 <span data-ttu-id="48a2e-132">Třetí řádek kódu instruuje kompilátor, aby explicitně převést proměnnou `lng`, což je typu long int před provedením přiřazení.</span><span class="sxs-lookup"><span data-stu-id="48a2e-132">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="48a2e-133">Mějte na paměti, že s zužující převod, je potenciální ztráta dat.</span><span class="sxs-lookup"><span data-stu-id="48a2e-133">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="48a2e-134">Zužující převody by měl používat s rozvahou a i v případě, kód se zkompiluje můžete obdržet neočekávané výsledky v době běhu.</span><span class="sxs-lookup"><span data-stu-id="48a2e-134">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>  
  
 <span data-ttu-id="48a2e-135">Tato diskuse byla pouze pro typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="48a2e-135">This discussion has only been for value types.</span></span> <span data-ttu-id="48a2e-136">Při práci s typy hodnot, které při práci přímo s daty uloženými v proměnné.</span><span class="sxs-lookup"><span data-stu-id="48a2e-136">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="48a2e-137">Rozhraní .NET Framework, ale má také typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="48a2e-137">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="48a2e-138">Při práci s typy odkazů pracujete s odkazem na proměnnou, ne na skutečná data.</span><span class="sxs-lookup"><span data-stu-id="48a2e-138">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="48a2e-139">Příklady typů odkazu by třídy, rozhraní a pole.</span><span class="sxs-lookup"><span data-stu-id="48a2e-139">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="48a2e-140">Nelze implicitně nebo explicitně převést jeden typ odkazu na jiný Pokud kompilátor umožňuje konkrétní ani převod příslušné, které jsou implementovány operátory.</span><span class="sxs-lookup"><span data-stu-id="48a2e-140">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>  
  
 <span data-ttu-id="48a2e-141">Následující ukázka generuje CS0029:</span><span class="sxs-lookup"><span data-stu-id="48a2e-141">The following sample generates CS0029:</span></span>  

```csharp
// CS0029.cs  
public class MyInt  
{  
    private int x = 0;
  
    // Uncomment this conversion routine to resolve CS0029  
    /*  
    public static implicit operator int(MyInt i)  
    {  
       return i.x;  
    }  
    */  
  
    public static void Main()  
   {  
      MyInt myInt = new MyInt();  
      int i = myInt; // CS0029  
   }  
}  
```

## <a name="see-also"></a><span data-ttu-id="48a2e-142">Viz také:</span><span class="sxs-lookup"><span data-stu-id="48a2e-142">See also</span></span>

- [<span data-ttu-id="48a2e-143">Operátory převodu</span><span class="sxs-lookup"><span data-stu-id="48a2e-143">Conversion Operators</span></span>](../../../csharp/programming-guide/statements-expressions-operators/conversion-operators.md)
