---
title: C# struktury – prohlídka jazyka C#
description: Přečtěte si, že se že se základy C# hodnoty typů nazývaných struktury
ms.date: 08/10/2016
ms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8
ms.openlocfilehash: d22cb23fe095874f24d7c002dfdb3eefdde66722
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/23/2019
ms.locfileid: "61675751"
---
# <a name="structs"></a><span data-ttu-id="c36a3-103">Struktury</span><span class="sxs-lookup"><span data-stu-id="c36a3-103">Structs</span></span>

<span data-ttu-id="c36a3-104">Třídy, jako jsou ***struktury*** datové struktury, které mohou obsahovat datové členy a funkční členy jsou, ale na rozdíl od tříd, struktur jsou typy hodnot a nevyžadují přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="c36a3-104">Like classes, ***structs*** are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation.</span></span> <span data-ttu-id="c36a3-105">Proměnné typu Struktura přímo ukládá datové struktury, že proměnné typu třída uchovává odkaz na do dynamicky alokovaného objektu.</span><span class="sxs-lookup"><span data-stu-id="c36a3-105">A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object.</span></span> <span data-ttu-id="c36a3-106">Typy struktury nepodporují dědičnosti zadané uživatelem, a všechny typy struktury implicitně dědí z typu <xref:System.ValueType>, což následně bude implicitně dědí z `object`.</span><span class="sxs-lookup"><span data-stu-id="c36a3-106">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <xref:System.ValueType>, which in turn implicitly inherits from `object`.</span></span>

<span data-ttu-id="c36a3-107">Struktury jsou zvláště užitečná pro malé datové struktury, které mají hodnotu sémantiku.</span><span class="sxs-lookup"><span data-stu-id="c36a3-107">Structs are particularly useful for small data structures that have value semantics.</span></span> <span data-ttu-id="c36a3-108">Komplexní čísla, body v souřadnicovém systému nebo páry klíč hodnota do slovníku jsou všechny dobrým příkladem struktury.</span><span class="sxs-lookup"><span data-stu-id="c36a3-108">Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs.</span></span> <span data-ttu-id="c36a3-109">Použití struktur, místo třídy pro malé datové struktury mohou přinést důležité velký počet přidělení paměti aplikace provádí.</span><span class="sxs-lookup"><span data-stu-id="c36a3-109">The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs.</span></span> <span data-ttu-id="c36a3-110">Například následující program vytvoří a inicializuje pole 100 bodů.</span><span class="sxs-lookup"><span data-stu-id="c36a3-110">For example, the following program creates and initializes an array of 100 points.</span></span> <span data-ttu-id="c36a3-111">S `Point` implementován jako třída, 101 samostatné objekty jsou vytvořena instance – jednu pro pole a jeden pro 100 elementů.</span><span class="sxs-lookup"><span data-stu-id="c36a3-111">With `Point` implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements.</span></span>

[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]

<span data-ttu-id="c36a3-112">Alternativou je, aby bod struktury.</span><span class="sxs-lookup"><span data-stu-id="c36a3-112">An alternative is to make Point a struct.</span></span>

[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]

<span data-ttu-id="c36a3-113">Nyní pouze jeden objekt je vytvořena instance – jednu pro pole – a `Point` instance jsou uložené v řádku v poli.</span><span class="sxs-lookup"><span data-stu-id="c36a3-113">Now, only one object is instantiated—the one for the array—and the `Point` instances are stored in-line in the array.</span></span>

<span data-ttu-id="c36a3-114">Konstruktory struktury jsou vyvolány pomocí `new` operátoru, podobně jako konstruktor třídy.</span><span class="sxs-lookup"><span data-stu-id="c36a3-114">Struct constructors are invoked with the `new` operator, similar to a class constructor.</span></span> <span data-ttu-id="c36a3-115">Ale namísto dynamického přidělování objektu na spravované haldě a vrátí na ni odkaz, konstruktor struktury jednoduše vrací hodnotu – struktura (obvykle do dočasného umístění v zásobníku) a tato hodnota se pak zkopíruje podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="c36a3-115">But, instead of dynamically allocating an object on the managed heap and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.</span></span>

<span data-ttu-id="c36a3-116">Pomocí třídy je možné pro dvě proměnné odkazovat na stejný objekt a proto je možné pro operace v rámci jedné proměnné ovlivňovat objekt odkazovaný jinou proměnnou.</span><span class="sxs-lookup"><span data-stu-id="c36a3-116">With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="c36a3-117">Struktury proměnné každý mají své vlastní kopii dat, a není možné pro operace se na nich se má vliv na jinou.</span><span class="sxs-lookup"><span data-stu-id="c36a3-117">With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span> <span data-ttu-id="c36a3-118">Například výstup vytvořený podle následující fragment kódu závisí na tom bod třídy nebo struktury.</span><span class="sxs-lookup"><span data-stu-id="c36a3-118">For example, the output produced by the following code fragment depends on whether Point is a class or a struct.</span></span>

[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]

<span data-ttu-id="c36a3-119">Pokud `Point` je třída, výstup je 20, protože `a` a `b` odkazovat na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="c36a3-119">If `Point` is a class, the output is 20 because `a` and `b` reference the same object.</span></span> <span data-ttu-id="c36a3-120">Pokud `Point` je struktura, výstup je 10, protože přiřazení `a` k `b` vytvoří kopii hodnoty, a tuto kopii není ovlivněn následné přiřazení `a.x`.</span><span class="sxs-lookup"><span data-stu-id="c36a3-120">If `Point` is a struct, the output is 10 because the assignment of `a` to `b` creates a copy of the value, and this copy is unaffected by the subsequent assignment to `a.x`.</span></span>

<span data-ttu-id="c36a3-121">Předchozí příklad ukazuje dvě omezení struktury.</span><span class="sxs-lookup"><span data-stu-id="c36a3-121">The previous example highlights two of the limitations of structs.</span></span> <span data-ttu-id="c36a3-122">Kopírování celé struktury je poprvé, obvykle méně efektivní než odkaz na objekt, kopírování, předávání přiřazení a hodnota parametru může být dražší s struktury než s typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="c36a3-122">First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types.</span></span> <span data-ttu-id="c36a3-123">Druhý, s výjimkou `in`, `ref`, a `out` parametry, není možné vytvořit odkazy na struktury, který vylučuje jejich použití v mnoha situacích.</span><span class="sxs-lookup"><span data-stu-id="c36a3-123">Second, except for `in`, `ref`, and `out` parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="c36a3-124">[Předchozí](classes-and-objects.md)
>[další](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="c36a3-124">[Previous](classes-and-objects.md)
[Next](arrays.md)</span></span>
