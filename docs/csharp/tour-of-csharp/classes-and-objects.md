---
title: Třídy a objekty v C# -A prohlídku C# jazyka
description: Začínáte C#? Přečtěte si tento přehled tříd, objektů a dědičnosti.
ms.date: 08/10/2016
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: be8e760b19b7ca5305918ecfdbf9ad797d7e76b2
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/28/2019
ms.locfileid: "70105633"
---
# <a name="classes-and-objects"></a><span data-ttu-id="543a2-104">Třídy a objekty</span><span class="sxs-lookup"><span data-stu-id="543a2-104">Classes and objects</span></span>

<span data-ttu-id="543a2-105">*Třídy* jsou základem C#typů.</span><span class="sxs-lookup"><span data-stu-id="543a2-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="543a2-106">Třída je datová struktura, která kombinuje stav (pole) a akce (metody a další členy funkce) v jedné jednotce.</span><span class="sxs-lookup"><span data-stu-id="543a2-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="543a2-107">Třída poskytuje definici pro dynamicky vytvořené *instance* třídy, označované také jako *objekty*.</span><span class="sxs-lookup"><span data-stu-id="543a2-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="543a2-108">Třídy podporují *Dědičnost* a *polymorfismus*, mechanismy, kterými mohou *odvozené třídy* roztáhnout a specializovat *základní třídy*.</span><span class="sxs-lookup"><span data-stu-id="543a2-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="543a2-109">Nové třídy jsou vytvářeny pomocí deklarací třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-109">New classes are created using class declarations.</span></span> <span data-ttu-id="543a2-110">Deklarace třídy začíná hlavičkou, která určuje atributy a modifikátory třídy, název třídy, základní třídu (Pokud je daná) a rozhraní implementovaná třídou.</span><span class="sxs-lookup"><span data-stu-id="543a2-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="543a2-111">Pod hlavičkou následuje tělo třídy, které se skládá ze seznamu deklarací členů napsaných mezi oddělovači `{` a. `}`</span><span class="sxs-lookup"><span data-stu-id="543a2-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="543a2-112">Následuje deklarace jednoduché třídy s názvem `Point`:</span><span class="sxs-lookup"><span data-stu-id="543a2-112">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="543a2-113">Instance tříd jsou vytvořeny pomocí `new` operátoru, který přiděluje paměť pro novou instanci, vyvolá konstruktor pro inicializaci instance a vrátí odkaz na instanci.</span><span class="sxs-lookup"><span data-stu-id="543a2-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="543a2-114">Následující příkazy vytvoří dva objekty Point a ukládají odkazy na tyto objekty ve dvou proměnných:</span><span class="sxs-lookup"><span data-stu-id="543a2-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="543a2-115">Paměť obsazená objektem je automaticky uvolněna v případě, že objekt již není dostupný.</span><span class="sxs-lookup"><span data-stu-id="543a2-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="543a2-116">Není ani možné explicitně zrušit přidělení objektů v C#.</span><span class="sxs-lookup"><span data-stu-id="543a2-116">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="543a2-117">Členové</span><span class="sxs-lookup"><span data-stu-id="543a2-117">Members</span></span>

<span data-ttu-id="543a2-118">Členy třídy jsou buď statické členy, nebo členy instance.</span><span class="sxs-lookup"><span data-stu-id="543a2-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="543a2-119">Statické členy patří ke třídám a členy instance patří do objektů (instance tříd).</span><span class="sxs-lookup"><span data-stu-id="543a2-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="543a2-120">Následující příklad obsahuje přehled druhů členů, které třída může obsahovat.</span><span class="sxs-lookup"><span data-stu-id="543a2-120">The following provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="543a2-121">Konstanty</span><span class="sxs-lookup"><span data-stu-id="543a2-121">Constants</span></span>
  - <span data-ttu-id="543a2-122">Konstantní hodnoty přidružené ke třídě</span><span class="sxs-lookup"><span data-stu-id="543a2-122">Constant values associated with the class</span></span>
- <span data-ttu-id="543a2-123">Pole</span><span class="sxs-lookup"><span data-stu-id="543a2-123">Fields</span></span>
  - <span data-ttu-id="543a2-124">Proměnné třídy</span><span class="sxs-lookup"><span data-stu-id="543a2-124">Variables of the class</span></span>
- <span data-ttu-id="543a2-125">Metody</span><span class="sxs-lookup"><span data-stu-id="543a2-125">Methods</span></span>
  - <span data-ttu-id="543a2-126">Výpočty a akce, které mohou být provedeny třídou</span><span class="sxs-lookup"><span data-stu-id="543a2-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="543a2-127">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="543a2-127">Properties</span></span>
  - <span data-ttu-id="543a2-128">Akce spojené s čtením a zápisem s názvem vlastnosti třídy</span><span class="sxs-lookup"><span data-stu-id="543a2-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="543a2-129">Indexery</span><span class="sxs-lookup"><span data-stu-id="543a2-129">Indexers</span></span>
  - <span data-ttu-id="543a2-130">Akce přidružené k indexování instancí třídy, jako je pole</span><span class="sxs-lookup"><span data-stu-id="543a2-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="543a2-131">Události</span><span class="sxs-lookup"><span data-stu-id="543a2-131">Events</span></span>
  - <span data-ttu-id="543a2-132">Oznámení, která mohou být vygenerována třídou</span><span class="sxs-lookup"><span data-stu-id="543a2-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="543a2-133">Operátory</span><span class="sxs-lookup"><span data-stu-id="543a2-133">Operators</span></span>
  - <span data-ttu-id="543a2-134">Převody a operátory výrazů podporované třídou</span><span class="sxs-lookup"><span data-stu-id="543a2-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="543a2-135">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="543a2-135">Constructors</span></span>
  - <span data-ttu-id="543a2-136">Akce vyžadované pro inicializaci instancí třídy nebo samotné třídy</span><span class="sxs-lookup"><span data-stu-id="543a2-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="543a2-137">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="543a2-137">Finalizers</span></span>
  - <span data-ttu-id="543a2-138">Akce, které se mají provést před tím, než se instance třídy trvale zahodí</span><span class="sxs-lookup"><span data-stu-id="543a2-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="543a2-139">Typy</span><span class="sxs-lookup"><span data-stu-id="543a2-139">Types</span></span>
  - <span data-ttu-id="543a2-140">Vnořené typy deklarované třídou</span><span class="sxs-lookup"><span data-stu-id="543a2-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="543a2-141">Usnadnění</span><span class="sxs-lookup"><span data-stu-id="543a2-141">Accessibility</span></span>

<span data-ttu-id="543a2-142">Každý člen třídy má přidruženou přístupnost, která řídí oblasti textu programu, které mají přístup k členu.</span><span class="sxs-lookup"><span data-stu-id="543a2-142">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="543a2-143">Existuje šest možných forem usnadnění přístupu.</span><span class="sxs-lookup"><span data-stu-id="543a2-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="543a2-144">Tyto jsou shrnuté níže.</span><span class="sxs-lookup"><span data-stu-id="543a2-144">These are summarized below.</span></span>

- `public`
  - <span data-ttu-id="543a2-145">Přístup není omezený</span><span class="sxs-lookup"><span data-stu-id="543a2-145">Access not limited</span></span>
- `protected`
  - <span data-ttu-id="543a2-146">Přístup omezený na tuto třídu nebo třídy odvozené z této třídy</span><span class="sxs-lookup"><span data-stu-id="543a2-146">Access limited to this class or classes derived from this class</span></span>
- `internal`
  - <span data-ttu-id="543a2-147">Přístup omezený na aktuální sestavení (. exe,. dll atd.)</span><span class="sxs-lookup"><span data-stu-id="543a2-147">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
- `protected internal`
  - <span data-ttu-id="543a2-148">Přístup omezený na obsahující třídu, třídy odvozené od obsahující třídy nebo třídy v rámci stejného sestavení</span><span class="sxs-lookup"><span data-stu-id="543a2-148">Access limited to the containing class, classes derived from the containing class, or classes within the same assembly</span></span>
- `private`
  - <span data-ttu-id="543a2-149">Přístup omezený na tuto třídu</span><span class="sxs-lookup"><span data-stu-id="543a2-149">Access limited to this class</span></span>
- `private protected`
  - <span data-ttu-id="543a2-150">Přístup omezený na obsahující třídu nebo třídy odvozené z nadřazeného typu v rámci stejného sestavení</span><span class="sxs-lookup"><span data-stu-id="543a2-150">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="543a2-151">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="543a2-151">Type parameters</span></span>

<span data-ttu-id="543a2-152">Definice třídy může určovat sadu parametrů typu za názvem třídy a lomenými závorkami ohraničující seznam názvů parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="543a2-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="543a2-153">Parametry typu lze potom použít v těle deklarací třídy k definování členů třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="543a2-154">V následujícím příkladu parametry `Pair` typu jsou `TFirst` a `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="543a2-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="543a2-155">Typ třídy, která je deklarována pro přijetí parametrů typu, se nazývá *typ obecné třídy*.</span><span class="sxs-lookup"><span data-stu-id="543a2-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="543a2-156">Typy struktury, rozhraní a delegátů můžou být také obecné.</span><span class="sxs-lookup"><span data-stu-id="543a2-156">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="543a2-157">Při použití obecné třídy je nutné zadat argumenty typu pro každý z parametrů typu:</span><span class="sxs-lookup"><span data-stu-id="543a2-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="543a2-158">Obecný typ s poskytnutými argumenty typu, jako `Pair<int,string>` je například výše, se označuje jako *konstruovaný typ*.</span><span class="sxs-lookup"><span data-stu-id="543a2-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="543a2-159">Základní třídy</span><span class="sxs-lookup"><span data-stu-id="543a2-159">Base classes</span></span>

<span data-ttu-id="543a2-160">Deklarace třídy může specifikovat základní třídu za názvem třídy a parametry typu s dvojtečkou a názvem základní třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="543a2-161">Vynechání specifikace základní třídy je stejné jako odvození z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="543a2-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="543a2-162">V následujícím příkladu `Point3D` je základní třída třídy `Point` `Point` a základní třída `object`:</span><span class="sxs-lookup"><span data-stu-id="543a2-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="543a2-163">Třída dědí členy své základní třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="543a2-164">Dědičnost znamená, že třída implicitně obsahuje všechny členy své základní třídy, s výjimkou instancí a statických konstruktorů a finalizační metody základní třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="543a2-165">Odvozená třída může přidat nové členy do těch, které dědí, ale nemůže odebrat definici zděděného člena.</span><span class="sxs-lookup"><span data-stu-id="543a2-165">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="543a2-166">V předchozím příkladu `Point3D` `x` dědí pole a `y` z `Point`a každá `Point3D` instance obsahuje tři pole, `x`, `y`a `z`.</span><span class="sxs-lookup"><span data-stu-id="543a2-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="543a2-167">Implicitní převod existuje z typu třídy na libovolný z jeho základních typů třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="543a2-168">Proto proměnná typu třídy může odkazovat na instanci této třídy nebo instanci jakékoli odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-168">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="543a2-169">Například s ohledem na předchozí deklarace třídy může proměnná typu `Point` odkazovat buď na `Point` , nebo `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="543a2-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="543a2-170">Pole</span><span class="sxs-lookup"><span data-stu-id="543a2-170">Fields</span></span>

<span data-ttu-id="543a2-171">*Pole* je proměnná, která je přidružena ke třídě nebo s instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="543a2-172">Pole deklarované pomocí statického modifikátoru definuje statické pole.</span><span class="sxs-lookup"><span data-stu-id="543a2-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="543a2-173">Statické pole identifikuje právě jedno umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="543a2-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="543a2-174">Bez ohledu na to, kolik instancí třídy je vytvořeno, existuje pouze jedna kopie statického pole.</span><span class="sxs-lookup"><span data-stu-id="543a2-174">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="543a2-175">Pole deklarované bez statického modifikátoru definuje pole instance.</span><span class="sxs-lookup"><span data-stu-id="543a2-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="543a2-176">Každá instance třídy obsahuje samostatnou kopii všech polí instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="543a2-177">V následujícím příkladu má `Color` každá instance třídy samostatnou kopii `r`polí `Black`instance, `g`a `b` `Red`, ale je k dispozici pouze jedna kopie, `White`,, `Green` a`Blue` statická pole:</span><span class="sxs-lookup"><span data-stu-id="543a2-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="543a2-178">Jak je znázorněno v předchozím příkladu, *pole jen pro čtení* mohou být deklarována `readonly` s modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="543a2-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="543a2-179">Přiřazení k `readonly` poli může být provedeno pouze v rámci deklarace pole nebo v konstruktoru ve stejné třídě.</span><span class="sxs-lookup"><span data-stu-id="543a2-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="543a2-180">Metody</span><span class="sxs-lookup"><span data-stu-id="543a2-180">Methods</span></span>

<span data-ttu-id="543a2-181">*Metoda* je člen, který implementuje výpočet nebo akci, kterou lze provést pomocí objektu nebo třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="543a2-182">*Statické metody* jsou k dispozici prostřednictvím třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="543a2-183">*Metody instance* jsou k dispozici prostřednictvím instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="543a2-184">Metody mohou mít seznam *parametrů*, které reprezentují hodnoty nebo odkazy na proměnné předané metodě a *návratový typ*, který určuje typ počítané hodnoty a vrácený metodou.</span><span class="sxs-lookup"><span data-stu-id="543a2-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="543a2-185">Návratový typ metody je `void` , pokud nevrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="543a2-185">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="543a2-186">Podobně jako typy mohou metody mít také sadu parametrů typu, pro které argumenty typu musí být zadány při volání metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="543a2-187">Na rozdíl od typů lze argumenty typu často odvodit z argumentů volání metody a nemusí být explicitně předány.</span><span class="sxs-lookup"><span data-stu-id="543a2-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="543a2-188">*Signatura* metody musí být jedinečná ve třídě, ve které je metoda deklarovaná.</span><span class="sxs-lookup"><span data-stu-id="543a2-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="543a2-189">Signatura metody se skládá z názvu metody, počtu parametrů typu a počtu, modifikátorů a typů jeho parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="543a2-190">Podpis metody nezahrnuje návratový typ.</span><span class="sxs-lookup"><span data-stu-id="543a2-190">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="543a2-191">Parametry</span><span class="sxs-lookup"><span data-stu-id="543a2-191">Parameters</span></span>

<span data-ttu-id="543a2-192">Parametry slouží k předání hodnot nebo odkazů na proměnné metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="543a2-193">Parametry metody získají jejich skutečné hodnoty z *argumentů* , které jsou zadány při volání metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="543a2-194">Existují čtyři typy parametrů: parametry hodnoty, parametry odkazu, výstupní parametry a pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="543a2-195">*Parametr hodnoty* se používá pro předávání vstupních argumentů.</span><span class="sxs-lookup"><span data-stu-id="543a2-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="543a2-196">Parametr hodnoty odpovídá místní proměnné, která vrací počáteční hodnotu z argumentu předaného pro parametr.</span><span class="sxs-lookup"><span data-stu-id="543a2-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="543a2-197">Úpravy parametru hodnoty neovlivňují argument, který byl předán parametru.</span><span class="sxs-lookup"><span data-stu-id="543a2-197">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="543a2-198">Parametry hodnoty mohou být volitelné, zadáním výchozí hodnoty, aby bylo možné vynechat odpovídající argumenty.</span><span class="sxs-lookup"><span data-stu-id="543a2-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="543a2-199">*Parametr reference* se používá pro předávání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="543a2-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="543a2-200">Argument předaný parametru reference musí být proměnná s určitou hodnotou a během provádění metody představuje parametr reference stejné umístění úložiště jako proměnná argumentu.</span><span class="sxs-lookup"><span data-stu-id="543a2-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="543a2-201">Parametr reference je deklarován s `ref` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="543a2-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="543a2-202">Následující příklad ukazuje použití `ref` parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="543a2-203">*Výstupní parametr* se používá pro předávání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="543a2-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="543a2-204">Je podobná referenčnímu parametru, s tím rozdílem, že nevyžaduje explicitně přiřadit hodnotu k argumentu, který je k dispozici volajícímu.</span><span class="sxs-lookup"><span data-stu-id="543a2-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="543a2-205">Výstupní parametr je deklarován s `out` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="543a2-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="543a2-206">Následující příklad ukazuje použití `out` parametrů pomocí syntaxe představené v C# 7.</span><span class="sxs-lookup"><span data-stu-id="543a2-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="543a2-207">*Pole parametrů* povoluje proměnný počet argumentů, které mají být předány metodě.</span><span class="sxs-lookup"><span data-stu-id="543a2-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="543a2-208">Pole parametrů je deklarováno s `params` modifikátorem.</span><span class="sxs-lookup"><span data-stu-id="543a2-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="543a2-209">Pouze poslední parametr metody může být pole parametrů a typ pole parametrů musí být jednorozměrné pole.</span><span class="sxs-lookup"><span data-stu-id="543a2-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="543a2-210">Metody Write a WriteLine <xref:System.Console?displayProperty=nameWithType> třídy jsou vhodnými příklady použití pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="543a2-211">Jsou deklarovány následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="543a2-211">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="543a2-212">V rámci metody, která používá pole parametrů, se pole parametru chová stejně jako regulární parametr typu pole.</span><span class="sxs-lookup"><span data-stu-id="543a2-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="543a2-213">Při vyvolání metody s parametrem pole je však možné předat buď jeden argument typu pole parametru, nebo libovolný počet argumentů typu prvku pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-213">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="543a2-214">V druhém případě je instance pole automaticky vytvořena a inicializována s danými argumenty.</span><span class="sxs-lookup"><span data-stu-id="543a2-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="543a2-215">Tento příklad</span><span class="sxs-lookup"><span data-stu-id="543a2-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="543a2-216">je ekvivalentem zápisu následujícího.</span><span class="sxs-lookup"><span data-stu-id="543a2-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="543a2-217">Tělo metody a místní proměnné</span><span class="sxs-lookup"><span data-stu-id="543a2-217">Method body and local variables</span></span>

<span data-ttu-id="543a2-218">Tělo metody Určuje příkazy, které mají být provedeny při volání metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="543a2-219">Tělo metody může deklarovat proměnné, které jsou specifické pro vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="543a2-220">Tyto proměnné se nazývají *místní proměnné*.</span><span class="sxs-lookup"><span data-stu-id="543a2-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="543a2-221">Místní deklarace proměnné Určuje název typu, název proměnné a pravděpodobně počáteční hodnotu.</span><span class="sxs-lookup"><span data-stu-id="543a2-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="543a2-222">Následující příklad deklaruje místní proměnnou `i` s počáteční hodnotou nula a místní proměnnou `j` bez počáteční hodnoty.</span><span class="sxs-lookup"><span data-stu-id="543a2-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="543a2-223">C#aby bylo možné získat hodnotu, musí být místní proměnná *jednoznačně přiřazena* .</span><span class="sxs-lookup"><span data-stu-id="543a2-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="543a2-224">Například pokud deklarace předchozí `i` nezahrnuje počáteční hodnotu, kompilátor by nahlásil chybu pro následné použití `i` , protože `i` by se v těchto bodech v programu nedala jednoznačně přiřadit.</span><span class="sxs-lookup"><span data-stu-id="543a2-224">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="543a2-225">Metoda může použít `return` příkazy pro vrácení řízení volajícímu.</span><span class="sxs-lookup"><span data-stu-id="543a2-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="543a2-226">V metodách, `void`které `return` vracejí, příkazy nemohou určovat výraz.</span><span class="sxs-lookup"><span data-stu-id="543a2-226">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="543a2-227">V metodě, která vrací typ non- `return` void, musí příkazy zahrnovat výraz, který vypočítá vrácenou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="543a2-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="543a2-228">Statické a instanční metody</span><span class="sxs-lookup"><span data-stu-id="543a2-228">Static and instance methods</span></span>

<span data-ttu-id="543a2-229">Metoda deklarovaná pomocí statického modifikátoru je *statická metoda*.</span><span class="sxs-lookup"><span data-stu-id="543a2-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="543a2-230">Statická metoda nepracuje na konkrétní instanci a může přímo přistupovat ke statickým členům.</span><span class="sxs-lookup"><span data-stu-id="543a2-230">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="543a2-231">Metoda deklarovaná bez statického modifikátoru je *Metoda instance*.</span><span class="sxs-lookup"><span data-stu-id="543a2-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="543a2-232">Metoda instance pracuje na konkrétní instanci a může přistupovat ke statickým i instancím členů.</span><span class="sxs-lookup"><span data-stu-id="543a2-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="543a2-233">Instance, na které byla vyvolána metoda instance, může být explicitně k dispozici jako `this`.</span><span class="sxs-lookup"><span data-stu-id="543a2-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="543a2-234">V případě, že se odkazuje na `this` statickou metodu, se jedná o chybu.</span><span class="sxs-lookup"><span data-stu-id="543a2-234">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="543a2-235">Následující `Entity` třída má členy statických i instancí.</span><span class="sxs-lookup"><span data-stu-id="543a2-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="543a2-236">Každá `Entity` instance obsahuje sériové číslo (a předpokládá se, že některé další informace nejsou zde uvedeny).</span><span class="sxs-lookup"><span data-stu-id="543a2-236">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="543a2-237">`Entity` Konstruktor (který je jako metoda instance) Inicializuje novou instanci s dalším dostupným sériovým číslem.</span><span class="sxs-lookup"><span data-stu-id="543a2-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="543a2-238">Vzhledem k tomu, že je konstruktor členem instance, je povolen přístup `serialNo` k poli instance i k `nextSerialNo` statickému poli.</span><span class="sxs-lookup"><span data-stu-id="543a2-238">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="543a2-239">Statické metody `SetNextSerialNo`amůžou přistupovat ke `serialNo` statickému poli, ale při přímém přístupu k poli instance by to byla chyba. `nextSerialNo` `GetNextSerialNo`</span><span class="sxs-lookup"><span data-stu-id="543a2-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="543a2-240">Následující příklad ukazuje použití třídy entity.</span><span class="sxs-lookup"><span data-stu-id="543a2-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="543a2-241">Všimněte si, `SetNextSerialNo` že `GetNextSerialNo` statické metody a jsou vyvolány `GetSerialNo` ve třídě, zatímco metoda instance je vyvolána na instancích třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-241">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="543a2-242">Virtuální, přepisování a abstraktní metody</span><span class="sxs-lookup"><span data-stu-id="543a2-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="543a2-243">Pokud deklarace metody instance obsahuje `virtual` modifikátor, metoda je označována jako *virtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="543a2-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="543a2-244">Pokud není k dispozici žádný modifikátor Virtual, metoda je označována jako *nevirtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="543a2-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="543a2-245">Když je vyvolána virtuální metoda, je *typ běhu* instance, pro kterou probíhá vyvolání, určuje vlastní implementaci metody, která má být vyvolána.</span><span class="sxs-lookup"><span data-stu-id="543a2-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="543a2-246">V nevirtuálním volání metody je *Typ doby kompilace* instance určujícím faktorem.</span><span class="sxs-lookup"><span data-stu-id="543a2-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="543a2-247">Virtuální metoda může být přepsána v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="543a2-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="543a2-248">Pokud deklarace metody instance obsahuje modifikátor přepsání, metoda přepíše zděděnou virtuální metodu se stejnou signaturou.</span><span class="sxs-lookup"><span data-stu-id="543a2-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="543a2-249">Zatímco deklarace virtuální metody zavádí novou metodu, deklarace metody přepsání specializuje existující zděděnou virtuální metodu tím, že poskytuje novou implementaci této metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="543a2-250">*Abstraktní metoda* je virtuální metoda bez implementace.</span><span class="sxs-lookup"><span data-stu-id="543a2-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="543a2-251">Abstraktní metoda je deklarována s modifikátorem abstract a je povolena pouze ve třídě, která je také deklarována jako abstraktní.</span><span class="sxs-lookup"><span data-stu-id="543a2-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="543a2-252">Abstraktní metoda musí být přepsána v každé neabstraktní odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="543a2-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="543a2-253">Následující příklad deklaruje abstraktní `Expression`třídu,, která představuje uzel stromu výrazu, a tři odvozené třídy, `Constant`, `VariableReference`, a `Operation`, které implementují uzly stromu výrazů pro konstanty, proměnnou odkazy a aritmetické operace.</span><span class="sxs-lookup"><span data-stu-id="543a2-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="543a2-254">(To je podobné, ale nelze je zaměňovat s typy stromu výrazů).</span><span class="sxs-lookup"><span data-stu-id="543a2-254">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="543a2-255">K modelování aritmetických výrazů lze použít předchozí čtyři třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="543a2-256">Například pomocí instancí těchto tříd může být výraz `x + 3` reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="543a2-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="543a2-257">Metoda instance je vyvolána pro vyhodnocení `double` daného výrazu a vytvoření hodnoty. `Expression` `Evaluate`</span><span class="sxs-lookup"><span data-stu-id="543a2-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="543a2-258">Metoda přebírá `Dictionary` argument, který obsahuje názvy proměnných (jako klíče záznamů) a hodnoty (jako hodnoty položek).</span><span class="sxs-lookup"><span data-stu-id="543a2-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="543a2-259">Protože `Evaluate` je abstraktní metoda, neabstraktní třídy odvozené z `Expression` musí být přepsány `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="543a2-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="543a2-260">`Constant` Implementacejednoduševrátí`Evaluate` uloženou konstantu.</span><span class="sxs-lookup"><span data-stu-id="543a2-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="543a2-261">Implementace `VariableReference`objektu vyhledá název proměnné ve slovníku a vrátí výslednou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="543a2-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="543a2-262">Implementace nejprve vyhodnotí levý a pravý operand (rekurzivním `Evaluate` voláním metod) a poté provede danou aritmetickou operaci. `Operation`</span><span class="sxs-lookup"><span data-stu-id="543a2-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="543a2-263">Následující program používá `Expression` třídy pro vyhodnocení výrazu `x * (y + 2)` pro různé hodnoty `x` a `y`.</span><span class="sxs-lookup"><span data-stu-id="543a2-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="543a2-264">Přetížení metody</span><span class="sxs-lookup"><span data-stu-id="543a2-264">Method overloading</span></span>

<span data-ttu-id="543a2-265">*Přetížení* metody umožňuje, aby více metod ve stejné třídě měl stejný název, pokud mají jedinečné podpisy.</span><span class="sxs-lookup"><span data-stu-id="543a2-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="543a2-266">Při kompilování volání přetížené metody kompilátor používá *řešení přetížení* k určení konkrétní metody, která má být vyvolána.</span><span class="sxs-lookup"><span data-stu-id="543a2-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="543a2-267">Řešení přetížení najde jednu metodu, která nejlépe odpovídá argumentům, nebo hlásí chybu, pokud nelze najít žádnou nejlepší shodu.</span><span class="sxs-lookup"><span data-stu-id="543a2-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="543a2-268">Následující příklad ukazuje rozlišení přetížení v platnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="543a2-269">Komentář pro každé vyvolání v `UsageExample` metodě ukazuje, která metoda je skutečně vyvolána.</span><span class="sxs-lookup"><span data-stu-id="543a2-269">The comment for each invocation in the `UsageExample` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="543a2-270">Jak je znázorněno v příkladu, konkrétní metodu lze vždy vybrat explicitním přetypováním argumentů na přesné typy parametrů a/nebo explicitním zadáním argumentů typu.</span><span class="sxs-lookup"><span data-stu-id="543a2-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="543a2-271">Další členové funkcí</span><span class="sxs-lookup"><span data-stu-id="543a2-271">Other function members</span></span>

<span data-ttu-id="543a2-272">Členy, které obsahují spustitelný kód, jsou souhrnně označovány jako *Členové funkce* třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="543a2-273">Předchozí část popisuje metody, které jsou hlavním typem členů funkce.</span><span class="sxs-lookup"><span data-stu-id="543a2-273">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="543a2-274">Tato část popisuje další typy členů funkce, které C#podporuje: konstruktory, vlastnosti, indexery, události, operátory a finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="543a2-275">Následující příklad ukazuje obecnou třídu nazvanou `MyList<T>`, která implementuje zvětšený seznam objektů.</span><span class="sxs-lookup"><span data-stu-id="543a2-275">The following shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="543a2-276">Třída obsahuje několik příkladů nejběžnějších druhů členů funkce.</span><span class="sxs-lookup"><span data-stu-id="543a2-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="543a2-277">Tento příklad vytvoří `MyList` třídu, která není stejná jako standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.NET.</span><span class="sxs-lookup"><span data-stu-id="543a2-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="543a2-278">Ilustruje koncepty potřebné pro tuto prohlídku, ale není náhradou za tuto třídu.</span><span class="sxs-lookup"><span data-stu-id="543a2-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="543a2-279">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="543a2-279">Constructors</span></span>

<span data-ttu-id="543a2-280">C#podporuje jak instance, tak statické konstruktory.</span><span class="sxs-lookup"><span data-stu-id="543a2-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="543a2-281">*Konstruktor instance* je člen, který implementuje akce vyžadované pro inicializaci instance třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="543a2-282">*Statický konstruktor* je člen, který implementuje akce vyžadované k inicializaci samotné třídy při prvním načtení.</span><span class="sxs-lookup"><span data-stu-id="543a2-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="543a2-283">Konstruktor je deklarovaný jako metoda bez návratového typu a stejný název jako obsahující třída.</span><span class="sxs-lookup"><span data-stu-id="543a2-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="543a2-284">Pokud deklarace konstruktoru obsahuje statický modifikátor, deklaruje statický konstruktor.</span><span class="sxs-lookup"><span data-stu-id="543a2-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="543a2-285">V opačném případě deklaruje konstruktor instance.</span><span class="sxs-lookup"><span data-stu-id="543a2-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="543a2-286">Konstruktory instancí můžou být přetížené a můžou mít volitelné parametry.</span><span class="sxs-lookup"><span data-stu-id="543a2-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="543a2-287">Například `MyList<T>` třída deklaruje jeden konstruktor instance s jedním volitelným `int` parametrem.</span><span class="sxs-lookup"><span data-stu-id="543a2-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="543a2-288">Konstruktory instancí jsou vyvolány `new` pomocí operátoru.</span><span class="sxs-lookup"><span data-stu-id="543a2-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="543a2-289">Následující příkazy přidělují dvě `MyList<string>` instance pomocí konstruktoru `MyList` třídy s nepovinným argumentem a bez něj.</span><span class="sxs-lookup"><span data-stu-id="543a2-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="543a2-290">Na rozdíl od jiných členů nejsou konstruktory instancí zděděny a třída nemá žádné konstruktory instancí jiné než ty, které jsou ve třídě skutečně deklarovány.</span><span class="sxs-lookup"><span data-stu-id="543a2-290">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="543a2-291">Pokud pro třídu není zadán konstruktor instance, bude automaticky zadáno prázdné číslo bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="543a2-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="543a2-292">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="543a2-292">Properties</span></span>

<span data-ttu-id="543a2-293">*Vlastnosti* jsou přirozené rozšíření polí.</span><span class="sxs-lookup"><span data-stu-id="543a2-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="543a2-294">Oba se nazývají členové s přidruženými typy a syntaxe pro přístup k polím a vlastnostem je stejná.</span><span class="sxs-lookup"><span data-stu-id="543a2-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="543a2-295">Na rozdíl od polí ale vlastnosti neoznačují umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="543a2-295">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="543a2-296">Místo toho mají vlastnosti *přistupující objekty* , které určují příkazy, které mají být provedeny, když jsou jejich hodnoty čteny nebo zapsány.</span><span class="sxs-lookup"><span data-stu-id="543a2-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="543a2-297">Vlastnost je deklarována jako pole s tím rozdílem, že deklarace končí pomocí přístupového objektu Get nebo pomocí přístupového objektu sady zapsaného mezi `{` oddělovači a `}` místo konci středníku.</span><span class="sxs-lookup"><span data-stu-id="543a2-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="543a2-298">Vlastnost, která má přistupující objekt get i přístupový objekt set, je *vlastnost pro čtení i zápis*, vlastnost, která má pouze přistupující objekt get, je *vlastnost jen pro čtení*a vlastnost, která má pouze přístupový objekt set, je *vlastnost pouze pro zápis*.</span><span class="sxs-lookup"><span data-stu-id="543a2-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="543a2-299">Přístupový objekt get odpovídá metodě bez parametrů s návratovou hodnotou typu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="543a2-300">S výjimkou cíle přiřazení, při odkazování na vlastnost ve výrazu, je vyvolána přístupová metoda get vlastnosti pro výpočet hodnoty vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="543a2-301">Přístupový objekt set odpovídá metodě s jedním parametrem s názvem Value a bez návratového typu.</span><span class="sxs-lookup"><span data-stu-id="543a2-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="543a2-302">Když se na vlastnost odkazuje jako na cíl přiřazení nebo jako operand + + nebo--, přistupující objekt set je vyvolán s argumentem, který poskytuje novou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="543a2-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="543a2-303">Třída deklaruje dvě vlastnosti `Count` `Capacity`, které jsou jen pro čtení a pro čtení i zápis, v uvedeném pořadí. `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="543a2-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="543a2-304">Následuje příklad použití těchto vlastností:</span><span class="sxs-lookup"><span data-stu-id="543a2-304">The following is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="543a2-305">Podobně jako pole a metody C# podporuje vlastnosti instance i statické vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="543a2-306">Statické vlastnosti jsou deklarovány se statickým modifikátorem a vlastnosti instance jsou deklarovány bez ní.</span><span class="sxs-lookup"><span data-stu-id="543a2-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="543a2-307">Přístupové objekty vlastnosti mohou být virtuální.</span><span class="sxs-lookup"><span data-stu-id="543a2-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="543a2-308">Pokud deklarace vlastnosti obsahuje `virtual`modifikátor, `abstract`nebo `override` , vztahuje se na přístupový objekt (y) vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="543a2-309">Indexery</span><span class="sxs-lookup"><span data-stu-id="543a2-309">Indexers</span></span>

<span data-ttu-id="543a2-310">*Indexer* je člen, který umožňuje, aby objekty byly indexovány stejným způsobem jako pole.</span><span class="sxs-lookup"><span data-stu-id="543a2-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="543a2-311">Indexer je deklarován jako vlastnost s tím rozdílem, že název člena je `this` následován seznamem parametrů napsaným mezi `[` oddělovači a `]`.</span><span class="sxs-lookup"><span data-stu-id="543a2-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="543a2-312">Parametry jsou k dispozici v přistupujícím objektu indexeru.</span><span class="sxs-lookup"><span data-stu-id="543a2-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="543a2-313">Podobně jako u vlastností mohou být indexery pro čtení i zápis, jen pro čtení a přístup k nástroji indexeru, které mohou být virtuální.</span><span class="sxs-lookup"><span data-stu-id="543a2-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="543a2-314">Třída deklaruje jeden indexer pro čtení a zápis, který `int` přebírá parametr. `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="543a2-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="543a2-315">Indexer umožňuje indexovat `MyList<T>` instance s `int` hodnotami.</span><span class="sxs-lookup"><span data-stu-id="543a2-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="543a2-316">Příklad:</span><span class="sxs-lookup"><span data-stu-id="543a2-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="543a2-317">Indexery mohou být přetíženy, což znamená, že třída může deklarovat více indexerů za předpokladu, že počet nebo typy jejich parametrů se liší.</span><span class="sxs-lookup"><span data-stu-id="543a2-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="543a2-318">Události</span><span class="sxs-lookup"><span data-stu-id="543a2-318">Events</span></span>

<span data-ttu-id="543a2-319">*Událost* je člen, který umožňuje třídě nebo objektu poskytovat oznámení.</span><span class="sxs-lookup"><span data-stu-id="543a2-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="543a2-320">Událost je deklarována jako pole s tím rozdílem, že deklarace zahrnuje klíčové slovo události a typ musí být delegát typu.</span><span class="sxs-lookup"><span data-stu-id="543a2-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="543a2-321">V rámci třídy, která deklaruje člena události, se událost chová stejně jako pole typu delegáta (za předpokladu, že událost není abstraktní a nedeklaruje přistupující objekty).</span><span class="sxs-lookup"><span data-stu-id="543a2-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="543a2-322">Pole ukládá odkaz na delegáta, který představuje obslužné rutiny událostí, které byly přidány do události.</span><span class="sxs-lookup"><span data-stu-id="543a2-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="543a2-323">Pokud nejsou k dispozici žádné obslužné rutiny událostí `null`, pole je.</span><span class="sxs-lookup"><span data-stu-id="543a2-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="543a2-324">Třída deklaruje jeden člen události s názvem `Changed`, který indikuje, že do seznamu byla přidána nová položka. `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="543a2-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="543a2-325">Změněná událost je vyvolána `OnChanged` virtuální metodou, která nejprve kontroluje, zda je `null` událost (to znamená, že nejsou přítomny žádné obslužné rutiny).</span><span class="sxs-lookup"><span data-stu-id="543a2-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="543a2-326">Pojem vyvolání události je přesně shodný s voláním delegáta reprezentovaného událostí, takže neexistují žádné speciální jazykové konstrukce pro vyvolání událostí.</span><span class="sxs-lookup"><span data-stu-id="543a2-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="543a2-327">Klienti reagují na události prostřednictvím *obslužných rutin událostí*.</span><span class="sxs-lookup"><span data-stu-id="543a2-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="543a2-328">Obslužné rutiny událostí jsou připojeny `+=` pomocí operátoru a odebrány `-=` pomocí operátoru.</span><span class="sxs-lookup"><span data-stu-id="543a2-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="543a2-329">Následující příklad připojí obslužnou rutinu události k `Changed` události. `MyList<string>`</span><span class="sxs-lookup"><span data-stu-id="543a2-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="543a2-330">Pro pokročilé scénáře, kde je požadováno řízení základního úložiště události, může deklarace události explicitně poskytnout `add` a `remove` přistupující objekty, které `set` jsou poněkud podobné přístupovému objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="543a2-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="543a2-331">Operátory</span><span class="sxs-lookup"><span data-stu-id="543a2-331">Operators</span></span>

<span data-ttu-id="543a2-332">*Operátor* je člen, který definuje význam použití konkrétního operátoru výrazu na instance třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="543a2-333">Lze definovat tři typy operátorů: unární operátory, binární operátory a operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="543a2-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="543a2-334">Všechny operátory musí být deklarovány `public` jako `static`a.</span><span class="sxs-lookup"><span data-stu-id="543a2-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="543a2-335">Třída deklaruje dva operátory `operator ==` `MyList` , a, a poskytuje tak nový význam pro výrazy, které tyto operátory aplikují na instance. `operator !=` `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="543a2-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="543a2-336">Konkrétně operátory definují rovnost dvou `MyList<T>` instancí jako porovnávání každého z obsažených objektů pomocí jejich stejných metod.</span><span class="sxs-lookup"><span data-stu-id="543a2-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="543a2-337">Následující příklad používá `==` operátor k porovnání dvou `MyList<int>` instancí.</span><span class="sxs-lookup"><span data-stu-id="543a2-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="543a2-338">První `Console.WriteLine` výstupy `True` , protože dva seznamy obsahují stejný počet objektů se stejnými hodnotami ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="543a2-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="543a2-339">`a` `MyList<int>` Nebyl definován `operator ==`, `False` první `Console.WriteLine` by měl výstup, protože a`b` odkazují na různé instance. `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="543a2-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="543a2-340">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="543a2-340">Finalizers</span></span>

<span data-ttu-id="543a2-341">*Finalizační metoda* je člen, který implementuje akce vyžadované k finalizaci instance třídy.</span><span class="sxs-lookup"><span data-stu-id="543a2-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="543a2-342">Finalizační metody nemohou mít parametry, nemohou mít modifikátory dostupnosti a nelze je volat explicitně.</span><span class="sxs-lookup"><span data-stu-id="543a2-342">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="543a2-343">Finalizační metoda pro instanci je vyvolána automaticky během uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="543a2-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="543a2-344">Uvolňování paměti je povolená rozsáhlá Zeměpisná šířka při rozhodování o shromažďování objektů a spouštění finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="543a2-345">Konkrétně časování volání finalizační metody není deterministické a v jakémkoli vlákně mohou být provedeny finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="543a2-345">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="543a2-346">Z těchto a dalších důvodů by třídy měly implementovat finalizační metody pouze v případě, že žádná jiná řešení nejsou proveditelná.</span><span class="sxs-lookup"><span data-stu-id="543a2-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="543a2-347">`using` Příkaz poskytuje lepší přístup k zničení objektu.</span><span class="sxs-lookup"><span data-stu-id="543a2-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="543a2-348">[Předchozí](statements.md)Další
> [](structs.md)</span><span class="sxs-lookup"><span data-stu-id="543a2-348">[Previous](statements.md)
[Next](structs.md)</span></span>
