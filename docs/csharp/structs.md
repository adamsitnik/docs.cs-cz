---
title: Struktury – průvodce v C#
description: Další informace o typu Struktura a jak vytvořit
ms.date: 10/12/2016
ms.assetid: a7094b8c-7229-4b6f-82fc-824d0ea0ec40
ms.openlocfilehash: 6fcd30907880be9159b3cc2e3ab10659ddec248b
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/23/2019
ms.locfileid: "61706452"
---
# <a name="structs"></a><span data-ttu-id="c3876-103">Struktury</span><span class="sxs-lookup"><span data-stu-id="c3876-103">Structs</span></span>
<span data-ttu-id="c3876-104">A *struktura* je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c3876-104">A *struct* is a value type.</span></span> <span data-ttu-id="c3876-105">Když se vytvoří struktura, obsahuje proměnné, ke kterému je přiřazena struktura, obsahovat skutečná data.</span><span class="sxs-lookup"><span data-stu-id="c3876-105">When a struct is created, the variable to which the struct is assigned holds the struct's actual data.</span></span> <span data-ttu-id="c3876-106">Když je struktura přiřazena nové proměnné, zkopíruje se.</span><span class="sxs-lookup"><span data-stu-id="c3876-106">When the struct is assigned to a new variable, it is copied.</span></span> <span data-ttu-id="c3876-107">Nové proměnné a původní proměnné proto obsahují dvě oddělené kopie stejných dat.</span><span class="sxs-lookup"><span data-stu-id="c3876-107">The new variable and the original variable therefore contain two separate copies of the same data.</span></span> <span data-ttu-id="c3876-108">Změny provedené v jedné kopii neovlivní druhou kopii.</span><span class="sxs-lookup"><span data-stu-id="c3876-108">Changes made to one copy do not affect the other copy.</span></span>

<span data-ttu-id="c3876-109">Hodnoty typových proměnných přímo obsahují své hodnoty, což znamená, že paměť je přidělena vnitřně v jakémkoli kontextu je proměnná deklarována.</span><span class="sxs-lookup"><span data-stu-id="c3876-109">Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</span></span> <span data-ttu-id="c3876-110">Neexistuje samostatné přidělení haldy nebo zařazení kolekce paměti pro proměnné typu hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c3876-110">There is no separate heap allocation or garbage collection overhead for value-type variables.</span></span>  
  
<span data-ttu-id="c3876-111">Existují dvě kategorie typů hodnot: [struktura](./language-reference/keywords/struct.md) a [výčtu](./language-reference/keywords/enum.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-111">There are two categories of value types: [struct](./language-reference/keywords/struct.md) and [enum](./language-reference/keywords/enum.md).</span></span>  
  
<span data-ttu-id="c3876-112">Předdefinované číselné typy jsou struktury a mají vlastnosti a metody, které dostanete:</span><span class="sxs-lookup"><span data-stu-id="c3876-112">The built-in numeric types are structs, and they have properties and methods that you can access:</span></span>  
  
[!code-csharp[Static Method](../../samples/snippets/csharp/concepts/structs/static-method.cs)]
  
<span data-ttu-id="c3876-113">Ale deklarujete je a přiřadit jim hodnoty tak jako by byly jednoduché neagregované typy:</span><span class="sxs-lookup"><span data-stu-id="c3876-113">But you declare and assign values to them as if they were simple non-aggregate types:</span></span>  
  
[!code-csharp[Assign Values](../../samples/snippets/csharp/concepts/structs/assign-value.cs)] 
  
<span data-ttu-id="c3876-114">Typy hodnot jsou *zapečetěné*, což znamená, že, například, že nemůžete odvodit typ z <xref:System.Int32>, a nemůžete definovat strukturu pro dědění z jakéhokoli uživatelsky definované třídy nebo struktury, protože struktura může dědit jedině z <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="c3876-114">Value types are *sealed*, which means, for example, that you cannot derive a type from <xref:System.Int32>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType>.</span></span> <span data-ttu-id="c3876-115">Strukturu však můžete implementovat jednu nebo více rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3876-115">However, a struct can implement one or more interfaces.</span></span> <span data-ttu-id="c3876-116">Můžete přetypovat obsadit typ struktury pro typ rozhraní; To způsobí, že *zabalení* operace zalomí strukturu uvnitř odkazu typu objektu na spravované haldě.</span><span class="sxs-lookup"><span data-stu-id="c3876-116">You can cast a struct type to an interface type; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap.</span></span> <span data-ttu-id="c3876-117">K operaci zabalení dochází při předání typu hodnoty metodě, která přebírá <xref:System.Object> jako vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="c3876-117">Boxing operations occur when you pass a value type to a method that takes an <xref:System.Object> as an input parameter.</span></span> <span data-ttu-id="c3876-118">Další informace najdete v tématu [zabalení a rozbalení](./programming-guide/types/boxing-and-unboxing.md ).</span><span class="sxs-lookup"><span data-stu-id="c3876-118">For more information, see [Boxing and Unboxing](./programming-guide/types/boxing-and-unboxing.md ).</span></span>  
  
<span data-ttu-id="c3876-119">Můžete použít [struktura](./language-reference/keywords/struct.md) – klíčové slovo k tvorbě vlastních typů vlastní hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c3876-119">You use the [struct](./language-reference/keywords/struct.md) keyword to create your own custom value types.</span></span> <span data-ttu-id="c3876-120">Obvykle struktura slouží jako kontejner pro malou skupinu příbuzných proměnných, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="c3876-120">Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</span></span>  
  
[!code-csharp[Struct Keyword](../../samples/snippets/csharp/concepts/structs/struct-keyword.cs)]  
  
<span data-ttu-id="c3876-121">Další informace o typech hodnot v rozhraní .NET Framework najdete v tématu [obecný systém typů](../standard/common-type-system.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-121">For more information about value types in the .NET Framework, see [Common Type System](../standard/common-type-system.md).</span></span>  
    
<span data-ttu-id="c3876-122">Většinu podle stejné syntaxe jako třídy, struktury sdílet, ačkoli struktury jsou omezeny více než třídy:</span><span class="sxs-lookup"><span data-stu-id="c3876-122">Structs share most of the same syntax as classes, although structs are more limited than classes:</span></span>  
  
- <span data-ttu-id="c3876-123">V deklaraci struktury nelze inicializovat pole, jestliže nejsou deklarovány jako `const` nebo `static`.</span><span class="sxs-lookup"><span data-stu-id="c3876-123">Within a struct declaration, fields cannot be initialized unless they are declared as `const` or `static`.</span></span>  
  
- <span data-ttu-id="c3876-124">Struktury nelze deklarovat konstruktor bez parametrů (konstruktor bez parametrů) nebo finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="c3876-124">A struct cannot declare a parameterless constructor (a constructor without parameters) or a finalizer.</span></span>  
  
- <span data-ttu-id="c3876-125">Struktury se zkopírují na přiřazení.</span><span class="sxs-lookup"><span data-stu-id="c3876-125">Structs are copied on assignment.</span></span> <span data-ttu-id="c3876-126">Když je struktura přiřazena nové proměnné, se data kopírují a jakékoli změny nová kopie nezmění data pro původní kopírování.</span><span class="sxs-lookup"><span data-stu-id="c3876-126">When a struct is assigned to a new variable, all the data is copied, and any modification to the new copy does not change the data for the original copy.</span></span> <span data-ttu-id="c3876-127">To je důležité pamatovat při práci s kolekcemi typů hodnot, jako je například Dictionary < string, myStruct >.</span><span class="sxs-lookup"><span data-stu-id="c3876-127">This is important to remember when working with collections of value types such as Dictionary<string, myStruct>.</span></span>  
  
- <span data-ttu-id="c3876-128">Struktury jsou typy hodnot a třídy jsou odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="c3876-128">Structs are value types and classes are reference types.</span></span>  
  
- <span data-ttu-id="c3876-129">Na rozdíl od tříd, struktur dá vytvořit instance bez použití `new` operátor.</span><span class="sxs-lookup"><span data-stu-id="c3876-129">Unlike classes, structs can be instantiated without using a `new` operator.</span></span>  
  
- <span data-ttu-id="c3876-130">Struktury můžete deklarovat konstruktory, které mají parametry.</span><span class="sxs-lookup"><span data-stu-id="c3876-130">Structs can declare constructors that have parameters.</span></span>  
  
- <span data-ttu-id="c3876-131">Struktura nemůže dědit z jiné třídy nebo struktury a nemůže být základní třídy.</span><span class="sxs-lookup"><span data-stu-id="c3876-131">A struct cannot inherit from another struct or class, and it cannot be the base of a class.</span></span> <span data-ttu-id="c3876-132">Všechny struktury dědí přímo z <xref:System.ValueType>, který dědí z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c3876-132">All structs inherit directly from <xref:System.ValueType>, which inherits from <xref:System.Object>.</span></span>  
  
- <span data-ttu-id="c3876-133">Struktury můžou implementovat rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3876-133">A struct can implement interfaces.</span></span>

## <a name="literal-values"></a><span data-ttu-id="c3876-134">Hodnoty literálu</span><span class="sxs-lookup"><span data-stu-id="c3876-134">Literal values</span></span>  
<span data-ttu-id="c3876-135">V jazyce C# hodnoty literálu získávají typ z kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="c3876-135">In C#, literal values receive a type from the compiler.</span></span> <span data-ttu-id="c3876-136">Můžete určit, jak by měly být typu číselný literál přidáním písmene na konci čísla.</span><span class="sxs-lookup"><span data-stu-id="c3876-136">You can specify how a numeric literal should be typed by appending a letter to the end of the number.</span></span> <span data-ttu-id="c3876-137">Například chcete-li určit, že by měl hodnotou 4,56 zacházet jako s float, přidejte k "f" nebo "F" za číslo: `4.56f`.</span><span class="sxs-lookup"><span data-stu-id="c3876-137">For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: `4.56f`.</span></span> <span data-ttu-id="c3876-138">Pokud není připojeno žádné písmeno, kompilátor odvodí `double` typ literál.</span><span class="sxs-lookup"><span data-stu-id="c3876-138">If no letter is appended, the compiler will infer the `double` type for the literal.</span></span> <span data-ttu-id="c3876-139">Další informace o tom, které mohou být typy specifikovat písmennými příponami, najdete v referenčních stránkách pro jednotlivé typy v [hodnotách](./language-reference/keywords/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-139">For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](./language-reference/keywords/value-types.md).</span></span>  
  
<span data-ttu-id="c3876-140">Vzhledem k tomu, že jsou literály typovány a všechny typy jsou nakonec odvozeny z <xref:System.Object>, můžete psát a kompilovat kód následujícím:</span><span class="sxs-lookup"><span data-stu-id="c3876-140">Because literals are typed, and all types derive ultimately from <xref:System.Object>, you can write and compile code such as the following:</span></span>  
  
[!code-csharp[Literal Values](../../samples/snippets/csharp/concepts/structs/literals.cs)]

<span data-ttu-id="c3876-141">Poslední dva příklady znázorňují funkce jazyka C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="c3876-141">The last two examples demonstrate language features introduced in C# 7.0.</span></span> <span data-ttu-id="c3876-142">První umožňuje použít jako podtržítkem *oddělovač číslic* v numerických literálech.</span><span class="sxs-lookup"><span data-stu-id="c3876-142">The first allows you to use an underscore character as a *digit separator* inside numeric literals.</span></span> <span data-ttu-id="c3876-143">Můžete je umístit kdekoli budete chtít mezi číslicemi, aby se zlepšila čitelnost.</span><span class="sxs-lookup"><span data-stu-id="c3876-143">You can put them wherever you want between digits to improve readability.</span></span> <span data-ttu-id="c3876-144">Nemají žádný účinek na hodnotě.</span><span class="sxs-lookup"><span data-stu-id="c3876-144">They have no effect on the value.</span></span>

<span data-ttu-id="c3876-145">Ukazuje, druhý *binární literály:*, které vám umožňují určit bitové vzory přímo namísto použití šestnáctkové soustavě.</span><span class="sxs-lookup"><span data-stu-id="c3876-145">The second demonstrates *binary literals*, which allow you to specify bit patterns directly instead of using hexadecimal notation.</span></span>

## <a name="nullable-types"></a><span data-ttu-id="c3876-146">Typy s povolenou hodnotou Null</span><span class="sxs-lookup"><span data-stu-id="c3876-146">Nullable types</span></span>  
<span data-ttu-id="c3876-147">Typy běžných hodnot nemohou mít hodnotu [null](./language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-147">Ordinary value types cannot have a value of [null](./language-reference/keywords/null.md).</span></span> <span data-ttu-id="c3876-148">Můžete však vytvořit typy s možnou hodnotou Null přidáním **?**</span><span class="sxs-lookup"><span data-stu-id="c3876-148">However, you can create nullable value types by affixing a **?**</span></span> <span data-ttu-id="c3876-149">Po vytvoření typu.</span><span class="sxs-lookup"><span data-stu-id="c3876-149">after the type.</span></span> <span data-ttu-id="c3876-150">Například **int?** je **int** typ, který může mít také hodnotu [null](./language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-150">For example, **int?** is an **int** type that can also have the value [null](./language-reference/keywords/null.md).</span></span> <span data-ttu-id="c3876-151">V CTS jsou typy připouštějící hodnotu Null instancemi obecného typu struktury <xref:System.Nullable%601>.</span><span class="sxs-lookup"><span data-stu-id="c3876-151">In the CTS, nullable types are instances of the generic struct type <xref:System.Nullable%601>.</span></span> <span data-ttu-id="c3876-152">Typy s možnou hodnotou Null jsou zvláště užitečné při předávání dat do a z databáze, ve kterých mohou být číselné hodnoty null.</span><span class="sxs-lookup"><span data-stu-id="c3876-152">Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.</span></span> <span data-ttu-id="c3876-153">Další informace najdete v tématu [typy s možnou hodnotou Null (C# Programming Guide)](./programming-guide/nullable-types/index.md).</span><span class="sxs-lookup"><span data-stu-id="c3876-153">For more information, see [Nullable Types (C# Programming Guide)](./programming-guide/nullable-types/index.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c3876-154">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c3876-154">See also</span></span>

- [<span data-ttu-id="c3876-155">Třídy</span><span class="sxs-lookup"><span data-stu-id="c3876-155">Classes</span></span>](classes.md)
- [<span data-ttu-id="c3876-156">Základní typy</span><span class="sxs-lookup"><span data-stu-id="c3876-156">Basic Types</span></span>](basic-types.md)
