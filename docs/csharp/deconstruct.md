---
title: Dekonstrukce řazených kolekcí členů a ostatními typy
description: Zjistěte, jak dekonstruovat řazených kolekcí členů a dalších typů.
author: rpetrusha
ms.author: ronpet
ms.date: 07/18/2016
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 90c693790398509a810d93d8504e1eb748637bb5
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54710248"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="620f0-103">Dekonstrukce řazených kolekcí členů a ostatními typy</span><span class="sxs-lookup"><span data-stu-id="620f0-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="620f0-104">Řazená kolekce členů poskytuje odlehčené způsob, jak načíst několik hodnot z volání metody.</span><span class="sxs-lookup"><span data-stu-id="620f0-104">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="620f0-105">Ale po načtení řazené kolekce členů je potřeba zpracovat jeho jednotlivé prvky.</span><span class="sxs-lookup"><span data-stu-id="620f0-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="620f0-106">Na základě prvek po prvku je to náročná, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="620f0-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="620f0-107">`QueryCityData` Metoda vrátí hodnotu 3-n-tice a každý z jeho prvků je přiřazená k proměnné v samostatné operaci.</span><span class="sxs-lookup"><span data-stu-id="620f0-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="620f0-108">Načítání více hodnot pole a vlastnosti z objektu může být stejně náročné: je potřeba přiřadit hodnotu pole nebo vlastnost každý člen členské proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="620f0-109">Od verze C# 7.0, můžete načíst několik elementů z řazené kolekce členů nebo načtení více pole, vlastnosti a vypočítané hodnoty z objektu do jediného *dekonstruovat* operace.</span><span class="sxs-lookup"><span data-stu-id="620f0-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="620f0-110">Pokud jste dekonstruovat řazené kolekce členů, přiřadíte jeho prvky jednotlivé proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="620f0-111">Když jste dekonstruovat objektu, přiřadíte vybraných hodnot jednotlivé proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="620f0-112">Dekonstrukce řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="620f0-112">Deconstructing a tuple</span></span>

<span data-ttu-id="620f0-113">Funkce C# integrovanou podporu pro dekonstrukce řazených kolekcí členů, které umožňuje rozbalit všechny položky v řazené kolekce členů v rámci jedné operace.</span><span class="sxs-lookup"><span data-stu-id="620f0-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="620f0-114">Obecná syntaxe dekonstrukce řazené kolekce členů je podobná syntaxe pro definování: uzavřete proměnné, ke kterým má být přiřazena v závorkách na levé straně příkazu přiřazení jednotlivých prvků.</span><span class="sxs-lookup"><span data-stu-id="620f0-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="620f0-115">Například následující příkaz přiřadí prvky 4-řazenou kolekci členů na čtyřech samostatných proměnné:</span><span class="sxs-lookup"><span data-stu-id="620f0-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="620f0-116">Existují tři způsoby, jak dekonstruovat řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="620f0-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="620f0-117">Můžete explicitně deklarovat typ každého pole uvnitř závorek.</span><span class="sxs-lookup"><span data-stu-id="620f0-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="620f0-118">Následující příklad používá tento přístup k dekonstruovat 3 řazené kolekce členů vrácené `QueryCityData` metody.</span><span class="sxs-lookup"><span data-stu-id="620f0-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="620f0-119">Můžete použít `var` – klíčové slovo tak tohoto jazyka C# odvodí typ každou proměnnou.</span><span class="sxs-lookup"><span data-stu-id="620f0-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="620f0-120">Umístíte `var` – klíčové slovo mimo závorky.</span><span class="sxs-lookup"><span data-stu-id="620f0-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="620f0-121">Následující příklad používá odvození typu při dekonstrukce 3 řazené kolekce členů vrácené `QueryCityData` metody.</span><span class="sxs-lookup"><span data-stu-id="620f0-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="620f0-122">Můžete také použít `var` – klíčové slovo samostatně pomocí některé nebo všechny deklarace proměnných v závorkách.</span><span class="sxs-lookup"><span data-stu-id="620f0-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="620f0-123">To je náročné a nedoporučuje se používat.</span><span class="sxs-lookup"><span data-stu-id="620f0-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="620f0-124">A konečně může dekonstruovat řazené kolekce členů do proměnné, které už je deklarovaný.</span><span class="sxs-lookup"><span data-stu-id="620f0-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="620f0-125">Všimněte si, že nelze zadat konkrétní typ mimo závorky i v případě každé pole v n-tice stejného typu.</span><span class="sxs-lookup"><span data-stu-id="620f0-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="620f0-126">Tím se vygeneruje Chyba kompilátoru CS8136 "formulář Dekonstrukce 'var (...)' zakazuje určitého typu pro"var".".</span><span class="sxs-lookup"><span data-stu-id="620f0-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="620f0-127">Všimněte si, že musíte také přiřadit každý prvek řazené kolekce členů k proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="620f0-128">Pokud nezadáte žádné elementy, kompilátor vygeneruje chybu CS8132 "Nejde dekonstruovat se řazená kolekce členů"x"prvky do proměnné"y"."</span><span class="sxs-lookup"><span data-stu-id="620f0-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="620f0-129">Všimněte si, že nejde kombinovat deklarace a přiřazení existujících proměnných na levé straně dekonstrukce.</span><span class="sxs-lookup"><span data-stu-id="620f0-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="620f0-130">Kompilátor vygeneruje chybu CS8184 "při dekonstrukci nejde kombinovat deklarace a výrazy v levé straně."</span><span class="sxs-lookup"><span data-stu-id="620f0-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="620f0-131">Když členy obsahovat nově deklarované a existující proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="620f0-132">Dekonstrukce elementů řazené kolekce členů se zahodí.</span><span class="sxs-lookup"><span data-stu-id="620f0-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="620f0-133">Při dekonstrukce řazené kolekce členů, často máte zájem hodnoty jenom některé prvky.</span><span class="sxs-lookup"><span data-stu-id="620f0-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="620f0-134">Od verze C# 7.0, můžete využít výhod podpory jazyka C# pro *zahodí*, které jsou jen pro zápis proměnné jehož hodnoty, které jste se rozhodli ignorovat.</span><span class="sxs-lookup"><span data-stu-id="620f0-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="620f0-135">Zahození je určeno znakem podtržítka ("\_") v přiřazení.</span><span class="sxs-lookup"><span data-stu-id="620f0-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="620f0-136">Zahodit libovolný počet hodnot, jak chcete; všechny jsou reprezentované pomocí jedné zahození `_`.</span><span class="sxs-lookup"><span data-stu-id="620f0-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="620f0-137">Následující příklad ukazuje použití řazených kolekcí členů se zahodí.</span><span class="sxs-lookup"><span data-stu-id="620f0-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="620f0-138">`QueryCityDataForYears` Metoda vrátí 6-řazené kolekce členů s názvem Město, jeho oblast, rok, název města plnění pro daný rok, druhý rok a název města plnění pro daný druhý rok.</span><span class="sxs-lookup"><span data-stu-id="620f0-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="620f0-139">Příklad ukazuje změnu počtu obyvatel mezi tyto dva roky.</span><span class="sxs-lookup"><span data-stu-id="620f0-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="620f0-140">Data k dispozici z řazené kolekce členů, jsme unconcerned k oblasti města a víme název města a dvěma kalendářními daty v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="620f0-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="620f0-141">V důsledku toho jsme zajímá pouze dvě naplnění hodnoty uložené v řazené kolekci členů a dokáže zpracovat zbývající hodnoty jako zahození.</span><span class="sxs-lookup"><span data-stu-id="620f0-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="620f0-142">Dekonstrukce uživatelem definované typy</span><span class="sxs-lookup"><span data-stu-id="620f0-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="620f0-143">Typy bez řazené kolekce členů nejsou nabízejí integrovanou podporu pro zahodí.</span><span class="sxs-lookup"><span data-stu-id="620f0-143">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="620f0-144">Jako autor třídy, struktury nebo rozhraní, můžete ale povolit instance daného typu, který možné dekonstruovat implementací jeden nebo více `Deconstruct` metody.</span><span class="sxs-lookup"><span data-stu-id="620f0-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="620f0-145">Metoda vrací hodnotu void a každá hodnota na možné dekonstruovat. je označen [si](language-reference/keywords/out-parameter-modifier.md) parametr v podpisu metody.</span><span class="sxs-lookup"><span data-stu-id="620f0-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="620f0-146">Například následující `Deconstruct` metodu `Person` vrátí první a poslední název třídy:</span><span class="sxs-lookup"><span data-stu-id="620f0-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="620f0-147">Potom můžete dekonstruovat instance `Person` třídu s názvem `p` s přiřazení následujícím postupem:</span><span class="sxs-lookup"><span data-stu-id="620f0-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="620f0-148">Následující příklad přetížení `Deconstruct` metoda vrátí různé kombinace vlastností `Person` objektu.</span><span class="sxs-lookup"><span data-stu-id="620f0-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="620f0-149">Vrátí jednotlivé přetížení:</span><span class="sxs-lookup"><span data-stu-id="620f0-149">Individual overloads return:</span></span>

- <span data-ttu-id="620f0-150">První a poslední název.</span><span class="sxs-lookup"><span data-stu-id="620f0-150">A first and last name.</span></span>
- <span data-ttu-id="620f0-151">První, poslední a druhé křestní jméno.</span><span class="sxs-lookup"><span data-stu-id="620f0-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="620f0-152">Křestní jméno, příjmení, název města a název stavu.</span><span class="sxs-lookup"><span data-stu-id="620f0-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="620f0-153">Vzhledem k tomu může dojít k přetížení `Deconstruct` metodu tak, aby odrážely skupin dat, která se běžně extrahují z objektu, je třeba pečlivě definovat `Deconstruct` metody s podpisy, které jsou charakteristické a jednoznačný.</span><span class="sxs-lookup"><span data-stu-id="620f0-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="620f0-154">Více `Deconstruct` metody, které mají stejný počet `out` parametry nebo stejný počet a typ `out` parametry v jiném pořadí, může způsobit zmatení.</span><span class="sxs-lookup"><span data-stu-id="620f0-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="620f0-155">Přetížené `Deconstruct` metodu v následujícím příkladu znázorňuje jeden stávají možným zdrojem nejasnostem.</span><span class="sxs-lookup"><span data-stu-id="620f0-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="620f0-156">První přetížení vrátí křestní jméno, křestní jméno, příjmení a věk `Person` objekt v tomto pořadí.</span><span class="sxs-lookup"><span data-stu-id="620f0-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="620f0-157">Druhé přetížení vrátí informace o názvu pouze spolu s roční příjem, ale první a poslední název jsou v jiném pořadí.</span><span class="sxs-lookup"><span data-stu-id="620f0-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="620f0-158">To umožňuje snadno zaměnit pořadí argumentů při dekonstrukce `Person` instance.</span><span class="sxs-lookup"><span data-stu-id="620f0-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="620f0-159">Dekonstrukce typ definovaný uživatelem se zahodí.</span><span class="sxs-lookup"><span data-stu-id="620f0-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="620f0-160">Stejně, jako je tomu u [řazených kolekcí členů](#deconstructing-tuple-elements-with-discards), můžete ignorovat vybrané položky vrácené zahození `Deconstruct` metoda.</span><span class="sxs-lookup"><span data-stu-id="620f0-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="620f0-161">Každý zahození je určené proměnnou s názvem "\_", a jeden dekonstrukce operace může obsahovat více zahození.</span><span class="sxs-lookup"><span data-stu-id="620f0-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="620f0-162">Následující příklad deconstructs `Person` objektu do čtyř řetězců (jména a příjmení, města a státu) ale zahodí poslední názvu a stavu.</span><span class="sxs-lookup"><span data-stu-id="620f0-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="620f0-163">Uživatelem definovaný typ dekonstrukce s metodu rozšíření</span><span class="sxs-lookup"><span data-stu-id="620f0-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="620f0-164">Pokud jste neměli vytvářet třídy, struktury nebo rozhraní, můžete stále dekonstruovat objekty daného typu implementací jeden nebo více `Deconstruct` [rozšiřující metody](programming-guide/classes-and-structs/extension-methods.md) vracet hodnoty, které vás zajímá.</span><span class="sxs-lookup"><span data-stu-id="620f0-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="620f0-165">Následující příklad definuje dvě `Deconstruct` rozšiřující metody pro <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="620f0-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="620f0-166">Vrátí první sadu hodnot, které charakteristiku vlastnosti, včetně jeho typ, ať už jde o statické nebo instance, zda je jen pro čtení a určuje, zda se indexují.</span><span class="sxs-lookup"><span data-stu-id="620f0-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="620f0-167">Druhý určuje vlastnosti usnadnění.</span><span class="sxs-lookup"><span data-stu-id="620f0-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="620f0-168">Protože usnadnění get a přístupové objekty set se může lišit, logické hodnoty označuje, zda vlastnost má samostatné get i set přístupové objekty a pokud ano, ať už mají stejné usnadnění.</span><span class="sxs-lookup"><span data-stu-id="620f0-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="620f0-169">Pokud existuje jenom jeden přistupující objekt nebo get i přístupový objekt set mají stejnou přístupností `access` proměnné označuje usnadnění vlastnost jako celek.</span><span class="sxs-lookup"><span data-stu-id="620f0-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="620f0-170">V opačném případě usnadnění operace get a set přístupové objekty jsou označeny accessaccessibility je indikován `getAccess` a `setAccess` proměnné.</span><span class="sxs-lookup"><span data-stu-id="620f0-170">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="620f0-171">Viz také:</span><span class="sxs-lookup"><span data-stu-id="620f0-171">See also</span></span>

- [<span data-ttu-id="620f0-172">Zahození</span><span class="sxs-lookup"><span data-stu-id="620f0-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="620f0-173">Řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="620f0-173">Tuples</span></span>](tuples.md)
