---
title: Vysvětlení stromů výrazů
description: Přečtěte si o stromech výrazů a o tom, jak jsou užitečné při překladu algoritmů pro externí spuštění a kontrolu kódu před jeho provedením.
ms.date: 06/20/2016
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: c5d4b2ad54fab547567d430f11a31542a11d03f3
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/28/2019
ms.locfileid: "70104795"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="03cf8-103">Vysvětlení stromů výrazů</span><span class="sxs-lookup"><span data-stu-id="03cf8-103">Expression Trees Explained</span></span>

[<span data-ttu-id="03cf8-104">Předchozí – přehled</span><span class="sxs-lookup"><span data-stu-id="03cf8-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="03cf8-105">Strom výrazu je datová struktura, která definuje kód.</span><span class="sxs-lookup"><span data-stu-id="03cf8-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="03cf8-106">Jsou založené na stejných strukturách, které kompilátor používá k analýze kódu a generování zkompilovaného výstupu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="03cf8-107">Při čtení v tomto kurzu si všimnete trochu podobnosti mezi stromy výrazů a typy používanými v rozhraních API Roslyn k vytváření [analyzátorů a CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="03cf8-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="03cf8-108">(Analyzátory a CodeFixes jsou balíčky NuGet, které provádějí statickou analýzu kódu a můžou navrhovat možné opravy pro vývojáře.) Koncepty jsou podobné a konečný výsledek je datová struktura, která umožňuje srozumitelným způsobem vyzkoušení zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="03cf8-109">Stromy výrazů jsou však založeny na zcela jiné sadě tříd a rozhraní API než rozhraní API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="03cf8-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="03cf8-110">Pojďme se podívat na jednoduchý příklad.</span><span class="sxs-lookup"><span data-stu-id="03cf8-110">Let's look at a simple example.</span></span>
<span data-ttu-id="03cf8-111">Zde je řádek kódu:</span><span class="sxs-lookup"><span data-stu-id="03cf8-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="03cf8-112">Pokud jste ho mohli analyzovat jako strom výrazu, strom obsahuje několik uzlů.</span><span class="sxs-lookup"><span data-stu-id="03cf8-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="03cf8-113">Nejvzdálenější uzel je příkaz deklarace proměnné s přiřazením (`var sum = 1 + 2;`), který má nejvzdálenější uzel několik podřízených uzlů: deklaraci proměnné, operátor přiřazení a výraz představující pravou stranu znaménka rovná se.</span><span class="sxs-lookup"><span data-stu-id="03cf8-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="03cf8-114">Tento výraz je dále rozdělen na výrazy, které reprezentují operaci sčítání a levý a pravý operand přidání.</span><span class="sxs-lookup"><span data-stu-id="03cf8-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="03cf8-115">Pojďme přejít k podrobnostem o výrazech, které tvoří pravou stranu znaménka rovná se.</span><span class="sxs-lookup"><span data-stu-id="03cf8-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="03cf8-116">Výraz je `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="03cf8-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="03cf8-117">To je binární výraz.</span><span class="sxs-lookup"><span data-stu-id="03cf8-117">That's a binary expression.</span></span> <span data-ttu-id="03cf8-118">Konkrétně se jedná o binární výraz sčítání.</span><span class="sxs-lookup"><span data-stu-id="03cf8-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="03cf8-119">Výraz výrazu Binary má dva podřízené prvky, reprezentující levý a pravý uzel výrazu sčítání.</span><span class="sxs-lookup"><span data-stu-id="03cf8-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="03cf8-120">Tady jsou oba uzly konstantní výrazy: Levý operand je hodnota `1`a pravý operand je hodnota. `2`</span><span class="sxs-lookup"><span data-stu-id="03cf8-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="03cf8-121">Vizuálně je celý příkaz stromovou strukturou: Můžete začít na kořenovém uzlu a projít každý uzel ve stromové struktuře a zobrazit kód, který tvoří příkaz:</span><span class="sxs-lookup"><span data-stu-id="03cf8-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="03cf8-122">Proměnná deklarace příkazu s přiřazením`var sum = 1 + 2;`()</span><span class="sxs-lookup"><span data-stu-id="03cf8-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="03cf8-123">Deklarace implicitního typu proměnné`var sum`()</span><span class="sxs-lookup"><span data-stu-id="03cf8-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="03cf8-124">Implicitní klíčové slovo var`var`()</span><span class="sxs-lookup"><span data-stu-id="03cf8-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="03cf8-125">Deklarace proměnné názvu (`sum`)</span><span class="sxs-lookup"><span data-stu-id="03cf8-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="03cf8-126">Operátor přiřazení (`=`)</span><span class="sxs-lookup"><span data-stu-id="03cf8-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="03cf8-127">Výraz binárního sčítání`1 + 2`()</span><span class="sxs-lookup"><span data-stu-id="03cf8-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="03cf8-128">Levý operand (`1`)</span><span class="sxs-lookup"><span data-stu-id="03cf8-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="03cf8-129">Operátor sčítání (`+`)</span><span class="sxs-lookup"><span data-stu-id="03cf8-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="03cf8-130">Pravý operand (`2`)</span><span class="sxs-lookup"><span data-stu-id="03cf8-130">Right operand (`2`)</span></span>

<span data-ttu-id="03cf8-131">To může vypadat komplikované, ale je velmi výkonné.</span><span class="sxs-lookup"><span data-stu-id="03cf8-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="03cf8-132">Po stejném procesu můžete rozložit mnohem složitější výrazy.</span><span class="sxs-lookup"><span data-stu-id="03cf8-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="03cf8-133">Vezměte v úvahu tento výraz:</span><span class="sxs-lookup"><span data-stu-id="03cf8-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="03cf8-134">Výše uvedený výraz je také deklarace proměnné s přiřazením.</span><span class="sxs-lookup"><span data-stu-id="03cf8-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="03cf8-135">V této instanci je pravá strana přiřazení mnohem složitější strom.</span><span class="sxs-lookup"><span data-stu-id="03cf8-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="03cf8-136">Tento výraz nebudeme rozložit, ale zvažte, co můžou být jednotlivé uzly.</span><span class="sxs-lookup"><span data-stu-id="03cf8-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="03cf8-137">Existují volání metody s použitím aktuálního objektu jako přijímače, který má explicitního `this` přijímače, který nemá.</span><span class="sxs-lookup"><span data-stu-id="03cf8-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="03cf8-138">Existují volání metod pomocí jiných objektů přijímače, existují konstantní argumenty různých typů.</span><span class="sxs-lookup"><span data-stu-id="03cf8-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="03cf8-139">A nakonec je k dispozici binární operátor sčítání.</span><span class="sxs-lookup"><span data-stu-id="03cf8-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="03cf8-140">V závislosti na návratový typ `SecretSauceFunction()` nebo `MoreSecretSauce()`může být daný binární operátor sčítání metodou volání přepsaného operátoru sčítání, který se překládá na volání statické metody do binárního operátoru sčítání definovaného pro třídu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="03cf8-141">Navzdory této vnímané složitosti výše uvedený výraz vytvoří stromovou strukturu, kterou lze snadno přejít jako první vzorek.</span><span class="sxs-lookup"><span data-stu-id="03cf8-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="03cf8-142">Chcete-li ve výrazu najít uzly typu list, můžete ve výrazu zůstat přecházení podřízených uzlů.</span><span class="sxs-lookup"><span data-stu-id="03cf8-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="03cf8-143">Nadřazené uzly budou mít odkazy na své podřízené položky a každý uzel má vlastnost, která popisuje, jaký typ uzlu je.</span><span class="sxs-lookup"><span data-stu-id="03cf8-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="03cf8-144">Struktura stromu výrazů je velmi konzistentní.</span><span class="sxs-lookup"><span data-stu-id="03cf8-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="03cf8-145">Jakmile se naučíte základy, můžete pochopit i nejsložitější kód, když je reprezentován jako strom výrazu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="03cf8-146">Elegance v datové struktuře vysvětluje, jak může C# kompilátor analyzovat nejvíc komplexní C# programy a vytvořit vhodný výstup z tohoto složitého zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="03cf8-147">Jakmile se seznámíte se strukturou stromů výrazů, zjistíte, že znalostní báze vám pomůže rychle pracovat s mnoha dalšími a pokročilejšími scénáři.</span><span class="sxs-lookup"><span data-stu-id="03cf8-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="03cf8-148">Ve stromech výrazů je nedostupné napájení.</span><span class="sxs-lookup"><span data-stu-id="03cf8-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="03cf8-149">Kromě překladu algoritmů pro spuštění v jiných prostředích můžete použít stromy výrazů, aby bylo snazší psát algoritmy, které kontrolují kód před jeho spuštěním.</span><span class="sxs-lookup"><span data-stu-id="03cf8-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="03cf8-150">Můžete napsat metodu, jejíž argumenty jsou výrazy, a poté tyto výrazy před spuštěním kódu prostudovat.</span><span class="sxs-lookup"><span data-stu-id="03cf8-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="03cf8-151">Strom výrazu je úplná reprezentace kódu: můžete zobrazit hodnoty libovolného dílčího výrazu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="03cf8-152">Můžete vidět názvy metod a vlastností.</span><span class="sxs-lookup"><span data-stu-id="03cf8-152">You can see method and property names.</span></span> <span data-ttu-id="03cf8-153">Můžete zobrazit hodnotu libovolných konstantních výrazů.</span><span class="sxs-lookup"><span data-stu-id="03cf8-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="03cf8-154">Strom výrazu lze také převést na delegáta spustitelného souboru a spustit kód.</span><span class="sxs-lookup"><span data-stu-id="03cf8-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="03cf8-155">Rozhraní API pro stromy výrazů umožňují vytvářet stromy, které reprezentují téměř jakoukoli platnou konstrukci kódu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="03cf8-156">Pokud ale chcete co nejjednodušším způsobem zjednodušit, C# některé idiomy nejde ve stromové struktuře výrazu vytvořit.</span><span class="sxs-lookup"><span data-stu-id="03cf8-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="03cf8-157">Jedním z příkladů jsou asynchronní výrazy (pomocí `async` klíčových `await` slov a).</span><span class="sxs-lookup"><span data-stu-id="03cf8-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="03cf8-158">Pokud vaše potřeby vyžadují asynchronní algoritmy, je nutné manipulovat přímo s `Task` objekty, nikoli spoléhat na podporu kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="03cf8-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="03cf8-159">Další je vytváření smyček.</span><span class="sxs-lookup"><span data-stu-id="03cf8-159">Another is in creating loops.</span></span> <span data-ttu-id="03cf8-160">Obvykle je `for`vytvoříte pomocí smyčky `while` , `foreach`nebo `do` .</span><span class="sxs-lookup"><span data-stu-id="03cf8-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="03cf8-161">Jak vidíte [později v této sérii](expression-trees-building.md), rozhraní API pro stromy výrazů podporují výraz s `break` jednou smyčkou a `continue` výrazy, které řídí opakování smyčky.</span><span class="sxs-lookup"><span data-stu-id="03cf8-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="03cf8-162">Jedna z věcí, kterou nemůžete udělat, je změnit strom výrazu.</span><span class="sxs-lookup"><span data-stu-id="03cf8-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="03cf8-163">Stromy výrazů jsou neměnné datové struktury.</span><span class="sxs-lookup"><span data-stu-id="03cf8-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="03cf8-164">Chcete-li postupovat (změnit) strom výrazu, je nutné vytvořit nový strom, který je kopií původního objektu, ale s požadovanými změnami.</span><span class="sxs-lookup"><span data-stu-id="03cf8-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="03cf8-165">Typy dalších--architektury podporující stromy výrazů</span><span class="sxs-lookup"><span data-stu-id="03cf8-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
