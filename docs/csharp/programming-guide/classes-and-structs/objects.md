---
title: Objekty - C# Průvodce programováním
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: de44f0c416de798fb42fba93e30ec6aa6ed0208d
ms.sourcegitcommit: c7a7e1468bf0fa7f7065de951d60dfc8d5ba89f5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/14/2019
ms.locfileid: "65585980"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="f90a7-102">Objekty (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="f90a7-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="f90a7-103">Definice třídy nebo struktury je jako matrice, který určuje, co můžete dělat typu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="f90a7-104">Objekt je v podstatě blok paměti, která byla přidělena a nakonfigurovány podle podrobný plán.</span><span class="sxs-lookup"><span data-stu-id="f90a7-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="f90a7-105">Program může vytvořit mnoho objektů stejné třídy.</span><span class="sxs-lookup"><span data-stu-id="f90a7-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="f90a7-106">Objekty se také označují jako instance a mohou být uloženy v pojmenované proměnné nebo v poli nebo kolekci.</span><span class="sxs-lookup"><span data-stu-id="f90a7-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="f90a7-107">Klientský kód je kód, který používá tyto proměnné pro volání metody a přístup k veřejné vlastnosti objektu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="f90a7-108">V jazyce objektově orientované jako je C# typický program se skládá z více objektů dynamicky interakci.</span><span class="sxs-lookup"><span data-stu-id="f90a7-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f90a7-109">Statické typy chovat jinak než jak je popsán tady.</span><span class="sxs-lookup"><span data-stu-id="f90a7-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="f90a7-110">Další informace najdete v tématu [statické třídy a statické členy třídy](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="f90a7-110">For more information, see [Static Classes and Static Class Members](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span></span>  
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="f90a7-111">Struktura instance vs. Instance třídy</span><span class="sxs-lookup"><span data-stu-id="f90a7-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="f90a7-112">Vzhledem k tomu, že třídy jsou odkazové typy, proměnné objektu třídy obsahuje odkaz na adresu objektu na spravované haldě.</span><span class="sxs-lookup"><span data-stu-id="f90a7-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="f90a7-113">Pokud se první objekt, který je přiřazen druhému objektu stejného typu, pak obě proměnné odkazovat na objekt na této adrese.</span><span class="sxs-lookup"><span data-stu-id="f90a7-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="f90a7-114">Tento bod je podrobněji popsány dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="f90a7-115">Instance třídy se vytvářejí pomocí [operátor new](../../../csharp/language-reference/keywords/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="f90a7-115">Instances of classes are created by using the [new operator](../../../csharp/language-reference/keywords/new-operator.md).</span></span> <span data-ttu-id="f90a7-116">V následujícím příkladu `Person` je typ a `person1` a `person 2` instance ani objekty daného typu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="f90a7-117">Protože struktury jsou typy hodnot, proměnné objektu struktura obsahuje kopii celého objektu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="f90a7-118">Instance struktury můžete vytvořit také pomocí `new` operátoru, ale to se nevyžaduje, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="f90a7-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="f90a7-119">Paměť pro obě `p1` a `p2` přidělené v zásobníku vlákna.</span><span class="sxs-lookup"><span data-stu-id="f90a7-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="f90a7-120">Tuto paměť je uvolněn spolu se tento typ nebo metoda, ve kterém je deklarována.</span><span class="sxs-lookup"><span data-stu-id="f90a7-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="f90a7-121">Toto je jedním z důvodů, proč strukturách kopírují na přiřazení.</span><span class="sxs-lookup"><span data-stu-id="f90a7-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="f90a7-122">Naopak paměti přidělené pro instanci třídy, je automaticky uvolňovaného (uvolněna z paměti) modul common language runtime při všech odkazů na objekt nepřejdou mimo rozsah.</span><span class="sxs-lookup"><span data-stu-id="f90a7-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="f90a7-123">Není možné nedeterministicky zničit objekt třídy jako můžete v jazyce C++.</span><span class="sxs-lookup"><span data-stu-id="f90a7-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="f90a7-124">Další informace o uvolňování paměti v rozhraní .NET Framework najdete v tématu [uvolňování](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="f90a7-124">For more information about garbage collection in the .NET Framework, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f90a7-125">V modulu common language runtime je vysoce optimalizovaných přidělování a navracení zpět paměti na spravované haldě.</span><span class="sxs-lookup"><span data-stu-id="f90a7-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="f90a7-126">Ve většině případů není žádný velký rozdíl náklady na výkon spojeným s přidělováním instance třídy v haldě a přidělování struktury instance v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="f90a7-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>  
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="f90a7-127">Objekt Identity vs. Hodnota rovnosti</span><span class="sxs-lookup"><span data-stu-id="f90a7-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="f90a7-128">Když porovnáte dva objekty z hlediska rovnosti, musí nejprve rozlišit, jestli chcete zjistit, jestli dvě proměnné, které představují stejný objekt v paměti nebo zda jsou ekvivalentní hodnoty jedné nebo více z jejich polí.</span><span class="sxs-lookup"><span data-stu-id="f90a7-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="f90a7-129">Pokud je máte v úmyslu porovnat hodnoty, musíte zvážit, zda jsou objekty instance typů hodnot (struktury) nebo typy odkazů (tříd, delegátů, pole).</span><span class="sxs-lookup"><span data-stu-id="f90a7-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="f90a7-130">K určení, zda dvě instance třídy odkazují na stejné místo v paměti (což znamená, že mají stejnou *identity*), použít statické <xref:System.Object.Equals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f90a7-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="f90a7-131">(<xref:System.Object?displayProperty=nameWithType> je implicitní základní třída pro všechny typy hodnot a odkazové typy, včetně uživatelem definované strukturám a třídám.)</span><span class="sxs-lookup"><span data-stu-id="f90a7-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="f90a7-132">Chcete-li zjistit, zda pole instancí ve dvou instancí struktury mají stejné hodnoty, použijte <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f90a7-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f90a7-133">Protože implicitně dědí všechny struktury <xref:System.ValueType?displayProperty=nameWithType>, zavolejte metodu přímo na objekt, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="f90a7-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="f90a7-134"><xref:System.ValueType?displayProperty=nameWithType> Provádění `Equals` používá reflexi, protože musí být schopní určit pole jsou v libovolné struktury.</span><span class="sxs-lookup"><span data-stu-id="f90a7-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="f90a7-135">Při vytváření vlastních struktur, přepsat `Equals` metodu k dispozici efektivní rovnosti algoritmus, který je specifický pro váš typ.</span><span class="sxs-lookup"><span data-stu-id="f90a7-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="f90a7-136">Pokud chcete zjistit, zda jsou stejné hodnoty polí v dvě instance třídy, je možné použít <xref:System.Object.Equals%2A> metoda nebo [== – operátor](../../../csharp/language-reference/operators/equality-operators.md#equality-operator-).</span><span class="sxs-lookup"><span data-stu-id="f90a7-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../../csharp/language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="f90a7-137">Ale pouze používejte, je pokud třída má přepsat nebo přetížené jim poskytnout vlastní definici z jaké "rovnosti" znamená, že objekty tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="f90a7-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="f90a7-138">Třída může implementovat taky <xref:System.IEquatable%601> rozhraní nebo <xref:System.Collections.Generic.IEqualityComparer%601> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f90a7-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="f90a7-139">Obě rozhraní poskytuje metody, které můžete použít k testování rovnosti hodnoty.</span><span class="sxs-lookup"><span data-stu-id="f90a7-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="f90a7-140">Při navrhování vlastních tříd toto přepsání `Equals`, ujistěte se, že dodržovat pokyny uvedené v [jak: Definování rovnosti hodnoty pro typ](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) a <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f90a7-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to: Define Value Equality for a Type](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="related-sections"></a><span data-ttu-id="f90a7-141">Související oddíly</span><span class="sxs-lookup"><span data-stu-id="f90a7-141">Related Sections</span></span>  
 <span data-ttu-id="f90a7-142">Další informace:</span><span class="sxs-lookup"><span data-stu-id="f90a7-142">For more information:</span></span>  
  
- [<span data-ttu-id="f90a7-143">Třídy</span><span class="sxs-lookup"><span data-stu-id="f90a7-143">Classes</span></span>](../../../csharp/programming-guide/classes-and-structs/classes.md)  
  
- [<span data-ttu-id="f90a7-144">Struktury</span><span class="sxs-lookup"><span data-stu-id="f90a7-144">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
  
- [<span data-ttu-id="f90a7-145">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="f90a7-145">Constructors</span></span>](../../../csharp/programming-guide/classes-and-structs/constructors.md)  
  
- [<span data-ttu-id="f90a7-146">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="f90a7-146">Finalizers</span></span>](../../../csharp/programming-guide/classes-and-structs/destructors.md)  
  
- [<span data-ttu-id="f90a7-147">Události</span><span class="sxs-lookup"><span data-stu-id="f90a7-147">Events</span></span>](../../../csharp/programming-guide/events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="f90a7-148">Viz také:</span><span class="sxs-lookup"><span data-stu-id="f90a7-148">See also</span></span>

- [<span data-ttu-id="f90a7-149">Průvodce programováním v jazyce C#</span><span class="sxs-lookup"><span data-stu-id="f90a7-149">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="f90a7-150">object</span><span class="sxs-lookup"><span data-stu-id="f90a7-150">object</span></span>](../../../csharp/language-reference/keywords/object.md)
- [<span data-ttu-id="f90a7-151">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="f90a7-151">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="f90a7-152">class</span><span class="sxs-lookup"><span data-stu-id="f90a7-152">class</span></span>](../../../csharp/language-reference/keywords/class.md)
- [<span data-ttu-id="f90a7-153">struct</span><span class="sxs-lookup"><span data-stu-id="f90a7-153">struct</span></span>](../../../csharp/language-reference/keywords/struct.md)
- [<span data-ttu-id="f90a7-154">new – operátor</span><span class="sxs-lookup"><span data-stu-id="f90a7-154">new Operator</span></span>](../../../csharp/language-reference/keywords/new-operator.md)
- [<span data-ttu-id="f90a7-155">Obecný systém typů</span><span class="sxs-lookup"><span data-stu-id="f90a7-155">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
