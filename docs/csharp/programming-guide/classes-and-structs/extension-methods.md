---
title: Rozšiřující metody - C# Průvodce programováním
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: c231533604b4ebadfb709295b5a8b877f87bba1c
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54493415"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="e7342-102">Metody rozšíření (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="e7342-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="e7342-103">Metody rozšíření umožňují „přidávat“ metody ke stávajícím typům bez vytváření nového odvozeného typu, rekompilace nebo jiné změny původního typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="e7342-104">Metody rozšíření jsou zvláštním druhem statické metody, jsou však volány tak, jako kdyby byly metodami instance rozšířeného typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="e7342-105">Pro klientský kód napsaný v C#, F# a Visual Basic neexistuje žádný zjevný rozdíl mezi voláním metody rozšíření a metody, které jsou ve skutečnosti definovány v rámci typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="e7342-106">Nejběžnějšími metodami rozšíření jsou [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] operátory standardního dotazu, které přidávají funkce dotazu ke stávající <xref:System.Collections.IEnumerable?displayProperty=nameWithType> a <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> typy.</span><span class="sxs-lookup"><span data-stu-id="e7342-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="e7342-107">Pokud chcete použít operátory standardního dotazu, nejdříve je převeďte do rozsahu pomocí `using System.Linq` směrnice.</span><span class="sxs-lookup"><span data-stu-id="e7342-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="e7342-108">Poté bude libovolný typ, který implementuje <xref:System.Collections.Generic.IEnumerable%601> zřejmě má metody instance <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, a tak dále.</span><span class="sxs-lookup"><span data-stu-id="e7342-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="e7342-109">Zobrazí se tyto další metody v doplňování příkazů IntelliSense po zadání "tečky" za instanci typu <xref:System.Collections.Generic.IEnumerable%601> jako <xref:System.Collections.Generic.List%601> nebo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="e7342-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="e7342-110">Následující příklad ukazuje, jak volat operátor standardního dotazu `OrderBy` metodu na pole celých čísel.</span><span class="sxs-lookup"><span data-stu-id="e7342-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="e7342-111">Výraz v závorkách je výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="e7342-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="e7342-112">Velký počet operátorů standardního dotazu používá výrazy lambda jako parametry. To však metody rozšíření nepožadují.</span><span class="sxs-lookup"><span data-stu-id="e7342-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="e7342-113">Další informace najdete v tématu [výrazy Lambda](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e7342-113">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]  
  
 <span data-ttu-id="e7342-114">Metody rozšíření jsou definovány jako statické metody, ale jsou volány pomocí syntaxe metody instance.</span><span class="sxs-lookup"><span data-stu-id="e7342-114">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="e7342-115">První parametr určuje, jakým typem metoda pracuje, a parametru předchází [to](../../../csharp/language-reference/keywords/this.md) modifikátor.</span><span class="sxs-lookup"><span data-stu-id="e7342-115">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../../csharp/language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="e7342-116">Rozšiřující metody jsou pouze v rozsahu, kdy explicitně importujete obor názvů do zdrojového kódu s `using` směrnice.</span><span class="sxs-lookup"><span data-stu-id="e7342-116">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="e7342-117">Následující příklad ukazuje metodu rozšíření definovanou pro <xref:System.String?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="e7342-117">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="e7342-118">Tato třída je definována uvnitř nevnořené, neobecné statické třídy:</span><span class="sxs-lookup"><span data-stu-id="e7342-118">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]  
  
 <span data-ttu-id="e7342-119">`WordCount` – Metoda rozšíření může být přenesena do rozsahu pomocí této `using` – direktiva:</span><span class="sxs-lookup"><span data-stu-id="e7342-119">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```csharp  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="e7342-120">A může být volána z aplikace pomocí následující syntaxe:</span><span class="sxs-lookup"><span data-stu-id="e7342-120">And it can be called from an application by using this syntax:</span></span>  
  
```csharp  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="e7342-121">V kódu je možné vyvolat metodu rozšíření pomocí syntaxe metody instance.</span><span class="sxs-lookup"><span data-stu-id="e7342-121">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="e7342-122">Jazyk IL (Intermediate Language) generovaný kompilátorem však přeloží váš kód do volání statické metody.</span><span class="sxs-lookup"><span data-stu-id="e7342-122">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="e7342-123">Princip zapouzdření tedy není ve skutečnosti porušen.</span><span class="sxs-lookup"><span data-stu-id="e7342-123">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="e7342-124">Metody rozšíření ve skutečnosti nemají přístup k proměnným v typu, který rozšiřují.</span><span class="sxs-lookup"><span data-stu-id="e7342-124">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="e7342-125">Další informace najdete v tématu [jak: Implementace a volání vlastní metody rozšíření](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="e7342-125">For more information, see [How to: Implement and Call a Custom  Extension Method](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span></span>  
  
 <span data-ttu-id="e7342-126">Metody rozšíření budete pravděpodobně mnohem častěji volat, než implementovat své vlastní.</span><span class="sxs-lookup"><span data-stu-id="e7342-126">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="e7342-127">Vzhledem k tomu, že metody rozšíření jsou volány pomocí syntaxe metody instance, není vyžadována žádná zvláštní znalost, abyste je mohli použít v klientském kódu.</span><span class="sxs-lookup"><span data-stu-id="e7342-127">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="e7342-128">Pokud chcete povolit rozšíření metod pro konkrétní typ, stačí přidat elementy `using` direktivu pro obor názvů, ve kterém jsou definovány metody.</span><span class="sxs-lookup"><span data-stu-id="e7342-128">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="e7342-129">Například pokud chcete použít operátory standardního dotazu, přidejte tuto `using` direktiv kódu:</span><span class="sxs-lookup"><span data-stu-id="e7342-129">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```csharp  
using System.Linq;  
```  
  
 <span data-ttu-id="e7342-130">(Budete také pravděpodobně muset přidat odkaz na knihovnu System.Core.dll.) Všimnete si, že operátory standardního dotazu se nyní zobrazí v IntelliSense jako další metody dostupné pro většinu <xref:System.Collections.Generic.IEnumerable%601> typy.</span><span class="sxs-lookup"><span data-stu-id="e7342-130">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="e7342-131">Vytváření vazeb na metody rozšíření v době kompilace</span><span class="sxs-lookup"><span data-stu-id="e7342-131">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="e7342-132">Metody rozšíření můžete použít k rozšíření třídy nebo rozhraní, nikoli však k jejich přepsání.</span><span class="sxs-lookup"><span data-stu-id="e7342-132">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="e7342-133">Metoda rozšíření se stejným názvem a signaturou, jako má rozhraní nebo metoda třídy, nebude nikdy volána.</span><span class="sxs-lookup"><span data-stu-id="e7342-133">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="e7342-134">V době kompilace mají metody rozšíření vždy nižší prioritu než metody instance definované v samotném typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-134">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="e7342-135">Jinými slovy, pokud typ nemá pojmenovanou metodu `Process(int i)`a máte rozšiřující metodu se stejnou signaturou, kompilátor vytvoří vždy vazbu na metodu instance.</span><span class="sxs-lookup"><span data-stu-id="e7342-135">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="e7342-136">Pokud kompilátor narazí na vyvolání metody, nejprve vyhledá shodu v metodách instance tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-136">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="e7342-137">Pokud není nalezena žádná shoda, budou vyhledány jakékoli metody rozšíření, které jsou definovány pro daný typ, a budou připojeny k první vyhledané metodě rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e7342-137">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="e7342-138">Následující příklad znázorňuje, jakým způsobem kompilátor určuje, se kterou metodou rozšíření nebo metodou instance má vytvořit vazbu.</span><span class="sxs-lookup"><span data-stu-id="e7342-138">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="e7342-139">Příklad</span><span class="sxs-lookup"><span data-stu-id="e7342-139">Example</span></span>  
 <span data-ttu-id="e7342-140">Následující příklad znázorňuje pravidla, které u kompilátoru jazyka C# určují, zda vytvořit vazbu volání metody s metodou instance v rámci typu, nebo s metodou rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e7342-140">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="e7342-141">Statická třída `Extensions` obsahuje metody rozšíření definované pro každý typ, který implementuje `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="e7342-141">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="e7342-142">Třídy `A`, `B`, a `C` implementují rozhraní.</span><span class="sxs-lookup"><span data-stu-id="e7342-142">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="e7342-143">`MethodB` – Metoda rozšíření se nikdy nevolá, protože jeho název a signaturu přesně shodují s metodami již implementovanými třídami.</span><span class="sxs-lookup"><span data-stu-id="e7342-143">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="e7342-144">Pokud kompilátor nemůže najít metodu instance s odpovídající signaturou, vytvoří vazbu s odpovídající metodou rozšíření, je-li k dispozici.</span><span class="sxs-lookup"><span data-stu-id="e7342-144">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]  
  
## <a name="general-guidelines"></a><span data-ttu-id="e7342-145">Obecné pokyny</span><span class="sxs-lookup"><span data-stu-id="e7342-145">General Guidelines</span></span>  
 <span data-ttu-id="e7342-146">Většinou doporučujeme implementovat metody rozšíření opatrně a pouze tehdy, je-li to třeba.</span><span class="sxs-lookup"><span data-stu-id="e7342-146">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="e7342-147">Kdykoli to je možné, měl by klientský kód, který musí rozšířit stávající typ, provést toto rozšíření vytvořením nového typu odvozeného ze stávajícího typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-147">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="e7342-148">Další informace najdete v tématu [dědičnosti](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="e7342-148">For more information, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
 <span data-ttu-id="e7342-149">Pokud použijete metodu rozšíření k rozšíření typu, jehož zdrojový kód nelze změnit, podstupujete riziko, že změna implementace typu způsobí poškození metody rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e7342-149">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="e7342-150">Pokud implementujete metody rozšíření pro daný typ, mějte na paměti následující body:</span><span class="sxs-lookup"><span data-stu-id="e7342-150">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
-   <span data-ttu-id="e7342-151">Metoda rozšíření nebude nikdy volána, pokud má stejnou signaturu jako metoda definovaná v typu.</span><span class="sxs-lookup"><span data-stu-id="e7342-151">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
-   <span data-ttu-id="e7342-152">Dále jsou metody rozšíření přeneseny do rozsahu na úrovni oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="e7342-152">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="e7342-153">Například, pokud máte větší počet statických tříd, které obsahují rozšiřující metody do jednoho oboru názvů s názvem `Extensions`, se budou všechny přeneseny do rozsahu pomocí `using Extensions;` směrnice.</span><span class="sxs-lookup"><span data-stu-id="e7342-153">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="e7342-154">Chcete-li zamezit zvýšení čísla verze sestavení, neměli byste pro implementovanou knihovnu metody rozšíření používat.</span><span class="sxs-lookup"><span data-stu-id="e7342-154">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="e7342-155">Pokud chcete přidat významné funkce do knihovny, jejíž zdrojový kód vlastníte, měli byste postupovat podle standardních pokynů pro rozhraní .NET Framework pro správu verzí sestavení.</span><span class="sxs-lookup"><span data-stu-id="e7342-155">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="e7342-156">Další informace najdete v tématu [Správa verzí sestavení](../../../../docs/framework/app-domains/assembly-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="e7342-156">For more information, see [Assembly Versioning](../../../../docs/framework/app-domains/assembly-versioning.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7342-157">Viz také:</span><span class="sxs-lookup"><span data-stu-id="e7342-157">See also</span></span>

- [<span data-ttu-id="e7342-158">Průvodce programováním v jazyce C#</span><span class="sxs-lookup"><span data-stu-id="e7342-158">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="e7342-159">Ukázky paralelního programování (včetně mnoha příkladů metod rozšíření)</span><span class="sxs-lookup"><span data-stu-id="e7342-159">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="e7342-160">Výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="e7342-160">Lambda Expressions</span></span>](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="e7342-161">Přehled standardních operátorů dotazu</span><span class="sxs-lookup"><span data-stu-id="e7342-161">Standard Query Operators Overview</span></span>](../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="e7342-162">Pravidla převodu pro instanci parametrů a jejich dopad</span><span class="sxs-lookup"><span data-stu-id="e7342-162">Conversion rules for Instance parameters and their impact</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="e7342-163">Interoperabilita metod rozšíření mezi jazyky</span><span class="sxs-lookup"><span data-stu-id="e7342-163">Extension methods Interoperability between languages</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="e7342-164">Metody rozšíření a Curryfikované delegáty</span><span class="sxs-lookup"><span data-stu-id="e7342-164">Extension methods and Curried Delegates</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)
- [<span data-ttu-id="e7342-165">Rozšiřující metoda vazby a hlášení chyb</span><span class="sxs-lookup"><span data-stu-id="e7342-165">Extension method Binding and Error reporting</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)
