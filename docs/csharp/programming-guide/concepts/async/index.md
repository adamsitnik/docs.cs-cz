---
title: Asynchronní programování v jazyce C#
description: Přehled C# jazykovou podporu pro asynchronní programování pomocí asynchronní, await, úloh a úkolů<T>
ms.date: 03/18/2019
ms.openlocfilehash: a306ff75357f9f61ec9b086485472d99de5ad083
ms.sourcegitcommit: a970268118ea61ce14207e0916e17243546a491f
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/21/2019
ms.locfileid: "67307130"
---
# <a name="the-task-asynchronous-programming-model-in-c"></a><span data-ttu-id="5756a-103">Asynchronní programovací model úkolu v jazyce C\#</span><span class="sxs-lookup"><span data-stu-id="5756a-103">The Task asynchronous programming model in C\#</span></span>

<span data-ttu-id="5756a-104">Asynchronní programovací model úloh (TAP) poskytuje abstrakci přes asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="5756a-104">The Task asynchronous programming model (TAP) provides an abstraction over asynchronous code.</span></span> <span data-ttu-id="5756a-105">Při psaní kódu jako sekvenci příkazů, stejně jako vždy.</span><span class="sxs-lookup"><span data-stu-id="5756a-105">You write code as a sequence of statements, just like always.</span></span> <span data-ttu-id="5756a-106">Tento kód si můžete přečíst, jakoby dokončení každého příkazu před zahájením na další.</span><span class="sxs-lookup"><span data-stu-id="5756a-106">You can read that code as though each statement completes before the next begins.</span></span> <span data-ttu-id="5756a-107">Kompilátor provede několik transformace, protože některé z těchto příkazů může zahájit práci a vrátí <xref:System.Threading.Tasks.Task> , která představuje probíhající práci.</span><span class="sxs-lookup"><span data-stu-id="5756a-107">The compiler performs a number of transformations because some of those statements may start work and return a <xref:System.Threading.Tasks.Task> that represents the ongoing work.</span></span>

<span data-ttu-id="5756a-108">To je ten cíl této syntaxe: Povolit kód, který čte jako posloupnost příkazy, ale spustí mnohem složitější pořadí podle přidělení externích prostředků, a po dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-108">That's the goal of this syntax: enable code that reads like a sequence of statements, but executes in a much more complicated order based on external resource allocation and when tasks complete.</span></span> <span data-ttu-id="5756a-109">Je analogické k tom, jak lidé poskytují pokyny pro procesy, které zahrnují asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-109">It's analogous to how people give instructions for processes that include asynchronous tasks.</span></span> <span data-ttu-id="5756a-110">V celém tomto článku budete používat příkladem pokyny pro provedení snídani zobrazíte jak `async` a `await` klíčová slova usnadňují argumentovat o kód, který obsahuje řadu asynchronní pokyny.</span><span class="sxs-lookup"><span data-stu-id="5756a-110">Throughout this article, you'll use an example of instructions for making a breakfast to see how the `async` and `await` keywords make it easier to reason about code that includes a series of asynchronous instructions.</span></span> <span data-ttu-id="5756a-111">Měli byste napsat pokynů něco jako vysvětlují, jak je nechat snídani následujícího seznamu:</span><span class="sxs-lookup"><span data-stu-id="5756a-111">You'd write the instructions something like the following list to explain how to make a breakfast:</span></span>

1. <span data-ttu-id="5756a-112">Přidá Šálek kávy.</span><span class="sxs-lookup"><span data-stu-id="5756a-112">Pour a cup of coffee.</span></span>
1. <span data-ttu-id="5756a-113">Zahřívá se nahoru posun a pak ratifikoval dvě vajíčka.</span><span class="sxs-lookup"><span data-stu-id="5756a-113">Heat up a pan, then fry two eggs.</span></span>
1. <span data-ttu-id="5756a-114">Ratifikoval tři kolekce obsahuje nějaké řezy slanina.</span><span class="sxs-lookup"><span data-stu-id="5756a-114">Fry three slices of bacon.</span></span>
1. <span data-ttu-id="5756a-115">Informační zprávu dva druhy chléb.</span><span class="sxs-lookup"><span data-stu-id="5756a-115">Toast two pieces of bread.</span></span>
1. <span data-ttu-id="5756a-116">Přidání másle a zaseknutý do informační zprávy.</span><span class="sxs-lookup"><span data-stu-id="5756a-116">Add butter and jam to the toast.</span></span>
1. <span data-ttu-id="5756a-117">Přidá skla oranžové šťávu.</span><span class="sxs-lookup"><span data-stu-id="5756a-117">Pour a glass of orange juice.</span></span>

<span data-ttu-id="5756a-118">Pokud máte zkušenosti s dá uvařit, by se spustit tyto pokyny **asynchronně**.</span><span class="sxs-lookup"><span data-stu-id="5756a-118">If you have experience with cooking, you'd execute those instructions **asynchronously**.</span></span> <span data-ttu-id="5756a-119">by start připravuje pan vejce a pak spusťte slanina.</span><span class="sxs-lookup"><span data-stu-id="5756a-119">You'd start warming the pan for eggs, then start the bacon.</span></span> <span data-ttu-id="5756a-120">Byste umístit toaster chléb a pak spusťte vejce.</span><span class="sxs-lookup"><span data-stu-id="5756a-120">You'd put the bread in the toaster, then start the eggs.</span></span> <span data-ttu-id="5756a-121">V každém kroku procesu by spuštění úlohy a pak pozornost na úlohy, které jsou připravené pro vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="5756a-121">At each step of the process, you'd start a task, then turn your attention to tasks that are ready for your attention.</span></span>

<span data-ttu-id="5756a-122">Dá uvařit snídani je dobrý příklad asynchronní práce, která není paralelní.</span><span class="sxs-lookup"><span data-stu-id="5756a-122">Cooking breakfast is a good example of asynchronous work that isn't parallel.</span></span> <span data-ttu-id="5756a-123">Všechny tyto úlohy může zpracovat jenom jedna osoba (nebo vlákno).</span><span class="sxs-lookup"><span data-stu-id="5756a-123">One person (or thread) can handle all these tasks.</span></span> <span data-ttu-id="5756a-124">Pokračování snídani matric, jedna osoba může být snídani asynchronně pomocí před dokončením prvního spuštění další úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-124">Continuing the breakfast analogy, one person can make breakfast asynchronously by starting the next task before the first completes.</span></span> <span data-ttu-id="5756a-125">Dá uvařit, postupuje jestli někdo ho sleduje.</span><span class="sxs-lookup"><span data-stu-id="5756a-125">The cooking progresses whether or not someone is watching it.</span></span> <span data-ttu-id="5756a-126">Jakmile začnete připravuje posun pro vejce, můžete začít frying slanina.</span><span class="sxs-lookup"><span data-stu-id="5756a-126">As soon as you start warming the pan for the eggs, you can begin frying the bacon.</span></span> <span data-ttu-id="5756a-127">Po spuštění slanina můžete umístit chléb do toaster.</span><span class="sxs-lookup"><span data-stu-id="5756a-127">Once the bacon starts, you can put the bread into the toaster.</span></span>

<span data-ttu-id="5756a-128">Pro paralelní algoritmus budete potřebovat více můžeme (nebo vláken).</span><span class="sxs-lookup"><span data-stu-id="5756a-128">For a parallel algorithm, you'd need multiple cooks (or threads).</span></span> <span data-ttu-id="5756a-129">Jeden s žádným vajíčka, jeden slanina, a tak dále.</span><span class="sxs-lookup"><span data-stu-id="5756a-129">One would make the eggs, one the bacon, and so on.</span></span> <span data-ttu-id="5756a-130">Každý z nich by zaměřuje na právě jednu úlohu.</span><span class="sxs-lookup"><span data-stu-id="5756a-130">Each one would be focused on just that one task.</span></span> <span data-ttu-id="5756a-131">Každý Cookovy (nebo vlákno) by být blokován při synchronním čekání slanina až bude připravená k převrácení nebo informační zprávy na vyvolat přes pop.</span><span class="sxs-lookup"><span data-stu-id="5756a-131">Each cook (or thread) would be blocked synchronously waiting for bacon to be ready to flip, or the toast to pop.</span></span> 

<span data-ttu-id="5756a-132">Nyní, vezměte v úvahu tyto stejné pokyny jako C# příkazy:</span><span class="sxs-lookup"><span data-stu-id="5756a-132">Now, consider those same instructions written as C# statements:</span></span>

[!code-csharp[SynchronousBreakfast](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-starter/Program.cs#Main)]

<span data-ttu-id="5756a-133">Počítače není interpretovat tyto pokyny, které stejný způsob, jak lidé dělají.</span><span class="sxs-lookup"><span data-stu-id="5756a-133">Computers don't interpret those instructions the same way people do.</span></span> <span data-ttu-id="5756a-134">Počítač bude blokovat u každého příkazu, dokud před přechodem na další příkaz dokončení práce.</span><span class="sxs-lookup"><span data-stu-id="5756a-134">The computer will block on each statement until the work is complete before moving on to the next statement.</span></span> <span data-ttu-id="5756a-135">Který vytváří unsatisfying snídani.</span><span class="sxs-lookup"><span data-stu-id="5756a-135">That creates an unsatisfying breakfast.</span></span> <span data-ttu-id="5756a-136">Dalších úlohách nebude možné spustit až do dokončení předchozích úkolů.</span><span class="sxs-lookup"><span data-stu-id="5756a-136">The later tasks wouldn't be started until the earlier tasks had completed.</span></span> <span data-ttu-id="5756a-137">Bude trvat déle vytvářet snídani a některé položky by jste získali studenou před používané pro služby.</span><span class="sxs-lookup"><span data-stu-id="5756a-137">It would take much longer to create the breakfast, and some items would have gotten cold before being served.</span></span> 

<span data-ttu-id="5756a-138">Pokud chcete počítač spustit asynchronně viz pokyny výše, psaní asynchronního kódu.</span><span class="sxs-lookup"><span data-stu-id="5756a-138">If you want the computer to execute the above instructions asynchronously, you must write asynchronous code.</span></span>

<span data-ttu-id="5756a-139">Tyto problémy jsou důležité pro programy, které napíšete ještě dnes.</span><span class="sxs-lookup"><span data-stu-id="5756a-139">These concerns are important for the programs you write today.</span></span> <span data-ttu-id="5756a-140">Při psaní klientských programů služby má uživatelské rozhraní bude reagovat na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="5756a-140">When you write client programs, you want the UI to be responsive to user input.</span></span> <span data-ttu-id="5756a-141">Vaše aplikace by neměla provést telefonu zdát, zatímco je stahování dat z webu.</span><span class="sxs-lookup"><span data-stu-id="5756a-141">Your application shouldn't make a phone appear frozen while it's downloading data from the web.</span></span> <span data-ttu-id="5756a-142">Při psaní serverových programů nechcete vlákna blokované.</span><span class="sxs-lookup"><span data-stu-id="5756a-142">When you write server programs, you don't want threads blocked.</span></span> <span data-ttu-id="5756a-143">Tato vlákna může poskytovat další požadavky.</span><span class="sxs-lookup"><span data-stu-id="5756a-143">Those threads could be serving other requests.</span></span> <span data-ttu-id="5756a-144">Použití synchronního kódu existovat asynchronní alternativy neuškodí jednu možnost možnost pro horizontální navýšení kapacity menší vytištěny.</span><span class="sxs-lookup"><span data-stu-id="5756a-144">Using synchronous code when asynchronous alternatives exist hurts your ability to scale out less expensively.</span></span> <span data-ttu-id="5756a-145">Platíte za tyto blokovaná vlákna.</span><span class="sxs-lookup"><span data-stu-id="5756a-145">You pay for those blocked threads.</span></span>

<span data-ttu-id="5756a-146">Úspěšné moderní aplikace vyžadují asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="5756a-146">Successful modern applications require asynchronous code.</span></span> <span data-ttu-id="5756a-147">Bez podpory jazyka psaní asynchronního kódu vyžaduje zpětná volání, dokončení události nebo jiným způsobem, který zakryto původní záměr kódu.</span><span class="sxs-lookup"><span data-stu-id="5756a-147">Without language support, writing asynchronous code required callbacks, completion events, or other means that obscured the original intent of the code.</span></span> <span data-ttu-id="5756a-148">Výhodou synchronního kódu je, že je snadno pochopitelný.</span><span class="sxs-lookup"><span data-stu-id="5756a-148">The advantage of the synchronous code is that it's easy to understand.</span></span> <span data-ttu-id="5756a-149">Podrobné akce, které umožňují snadno prohledávat a pochopit.</span><span class="sxs-lookup"><span data-stu-id="5756a-149">The step-by-step actions make it easy to scan and understand.</span></span> <span data-ttu-id="5756a-150">Tradiční asynchronní modely vynutit můžete zaměřit na asynchronní povaze kód, nikoli na základní akce kódu.</span><span class="sxs-lookup"><span data-stu-id="5756a-150">Traditional asynchronous models forced you to focus on the asynchronous nature of the code, not on the fundamental actions of the code.</span></span>

## <a name="dont-block-await-instead"></a><span data-ttu-id="5756a-151">Není blokovat, místo toho await</span><span class="sxs-lookup"><span data-stu-id="5756a-151">Don't block, await instead</span></span>

<span data-ttu-id="5756a-152">Předchozí kód ukazuje špatné postupy: vytváření synchronního kódu k provádění asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="5756a-152">The preceding code demonstrates a bad practice: constructing synchronous code to perform asynchronous operations.</span></span> <span data-ttu-id="5756a-153">Jak je uvedená, tento kód blokuje vlákno provádění z provádění jiné práce.</span><span class="sxs-lookup"><span data-stu-id="5756a-153">As written, this code blocks the thread executing it from doing any other work.</span></span> <span data-ttu-id="5756a-154">Nebudou přerušeny, zatímco všechny úlohy probíhají.</span><span class="sxs-lookup"><span data-stu-id="5756a-154">It won't be interrupted while any of the tasks are in progress.</span></span> <span data-ttu-id="5756a-155">Bylo by jakoby stared na Toaster byl po vložení chléb.</span><span class="sxs-lookup"><span data-stu-id="5756a-155">It would be as though you stared at the toaster after putting the bread in.</span></span> <span data-ttu-id="5756a-156">Bude ignorovat kdokoli se mluví, dokud informační zpráva odebrány.</span><span class="sxs-lookup"><span data-stu-id="5756a-156">You'd ignore anyone talking to you until the toast popped.</span></span> 

<span data-ttu-id="5756a-157">Začněme tím, že aktualizace tento kód tak, aby vlákno nebrání v běhu úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-157">Let's start by updating this code so that the thread doesn't block while tasks are running.</span></span> <span data-ttu-id="5756a-158">`await` – Klíčové slovo poskytuje neblokující způsob, jak spustit úlohu a potom pokračovat v provádění po dokončení této úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-158">The `await` keyword provides a non-blocking way to start a task, then continue execution when that task completes.</span></span> <span data-ttu-id="5756a-159">Jednoduchá asynchronní verze bylo možné vytvořit kód snídani by vypadalo podobně jako následující fragment kódu:</span><span class="sxs-lookup"><span data-stu-id="5756a-159">A simple asynchronous version of the make a breakfast code would look like the following snippet:</span></span>

[!code-csharp[SimpleAsyncBreakfast](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V2/Program.cs#Main)]

<span data-ttu-id="5756a-160">Tento kód nebude blokovat, když se dá uvařit vejce nebo slanina.</span><span class="sxs-lookup"><span data-stu-id="5756a-160">This code doesn't block while the eggs or the bacon are cooking.</span></span> <span data-ttu-id="5756a-161">Tento kód nespustí všechny úkoly, i když.</span><span class="sxs-lookup"><span data-stu-id="5756a-161">This code won't start any other tasks though.</span></span> <span data-ttu-id="5756a-162">Stále byste umístit informační zprávy toaster a stare na to, až se zobrazí místní okno.</span><span class="sxs-lookup"><span data-stu-id="5756a-162">You'd still put the toast in the toaster and stare at it until it pops.</span></span> <span data-ttu-id="5756a-163">Ale nejméně, by Odpovědět všem uživatelům chtěla vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="5756a-163">But at least, you'd respond to anyone that wanted your attention.</span></span> <span data-ttu-id="5756a-164">V restaurace, kde jsou umístěny více objednávek může Cookovy zahájit jiného snídani, dokud se dá uvařit, první.</span><span class="sxs-lookup"><span data-stu-id="5756a-164">In a restaurant where multiple orders are placed, the cook could start another breakfast while the first is cooking.</span></span>

<span data-ttu-id="5756a-165">Vlákno pracují snídani se zablokují během čekání na spuštěná úloha, která ještě nebyla dokončena.</span><span class="sxs-lookup"><span data-stu-id="5756a-165">Now, the thread working on the breakfast isn't blocked while awaiting any started task that hasn't yet finished.</span></span> <span data-ttu-id="5756a-166">Tato změna u některých aplikací je vše, co potřebujete.</span><span class="sxs-lookup"><span data-stu-id="5756a-166">For some applications, this change is all that's needed.</span></span> <span data-ttu-id="5756a-167">Grafické uživatelské rozhraní aplikace stále odpovídá uživateli s právě tuto změnu.</span><span class="sxs-lookup"><span data-stu-id="5756a-167">A GUI application still responds to the user with just this change.</span></span> <span data-ttu-id="5756a-168">V tomto scénáři má však další.</span><span class="sxs-lookup"><span data-stu-id="5756a-168">However, for this scenario, you want more.</span></span> <span data-ttu-id="5756a-169">Nechcete, aby každá komponenta úkoly, které mají být prováděny postupně.</span><span class="sxs-lookup"><span data-stu-id="5756a-169">You don't want each of the component tasks to be executed sequentially.</span></span> <span data-ttu-id="5756a-170">Je lepší pro spuštění jednotlivých úloh součásti před čekáním na dokončení předchozí úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-170">It's better to start each of the component tasks before awaiting the previous task's completion.</span></span>

## <a name="start-tasks-concurrently"></a><span data-ttu-id="5756a-171">Souběžné spuštění úlohy</span><span class="sxs-lookup"><span data-stu-id="5756a-171">Start tasks concurrently</span></span>

<span data-ttu-id="5756a-172">V mnoha případech budete chtít několik nezávislých úloh spustit okamžitě.</span><span class="sxs-lookup"><span data-stu-id="5756a-172">In many scenarios, you want to start several independent tasks immediately.</span></span> <span data-ttu-id="5756a-173">Potom když každý úkol dokončí, můžete pokračovat v další práci, která je připravená.</span><span class="sxs-lookup"><span data-stu-id="5756a-173">Then, as each task finishes, you can continue other work that's ready.</span></span> <span data-ttu-id="5756a-174">Analogicky snídani, který se dá dosáhnout snídani provádí rychleji.</span><span class="sxs-lookup"><span data-stu-id="5756a-174">In the breakfast analogy, that's how you get breakfast done more quickly.</span></span> <span data-ttu-id="5756a-175">Také získáte všechno, co udělat blízko stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="5756a-175">You also get everything done close to the same time.</span></span> <span data-ttu-id="5756a-176">Získáte horké snídani.</span><span class="sxs-lookup"><span data-stu-id="5756a-176">You'll get a hot breakfast.</span></span>

<span data-ttu-id="5756a-177"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> a souvisejících typů jsou třídy, které vám umožní důvod o úlohách, které probíhají.</span><span class="sxs-lookup"><span data-stu-id="5756a-177">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and related types are classes you can use to reason about tasks that are in progress.</span></span> <span data-ttu-id="5756a-178">Která umožňuje napsat kód, který lépe vypadá podobně jako způsob, vytvořili byste ve skutečnosti snídani.</span><span class="sxs-lookup"><span data-stu-id="5756a-178">That enables you to write code that more closely resembles the way you'd actually create breakfast.</span></span> <span data-ttu-id="5756a-179">Byste začali dá uvařit vajíčka, slanina a informačních zpráv ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="5756a-179">You'd start cooking the eggs, bacon, and toast at the same time.</span></span> <span data-ttu-id="5756a-180">Jako každý vyžaduje akci, by pozornost tento úkol, postará o další akci a operátoru await na něco jiného, který vyžaduje vaši pozornost.</span><span class="sxs-lookup"><span data-stu-id="5756a-180">As each requires action, you'd turn your attention to that task, take care of the next action, then await for something else that requires your attention.</span></span>

<span data-ttu-id="5756a-181">Spuštění úlohy a k uložení <xref:System.Threading.Tasks.Task> objekt, který reprezentuje práce.</span><span class="sxs-lookup"><span data-stu-id="5756a-181">You start a task and hold on to the <xref:System.Threading.Tasks.Task> object that represents the work.</span></span> <span data-ttu-id="5756a-182">Budete `await` každý úkol před zahájením práce s jeho výsledek.</span><span class="sxs-lookup"><span data-stu-id="5756a-182">You'll `await` each task before working with its result.</span></span>

<span data-ttu-id="5756a-183">Pojďme provést tyto změny kódu snídani.</span><span class="sxs-lookup"><span data-stu-id="5756a-183">Let's make these changes to the breakfast code.</span></span> <span data-ttu-id="5756a-184">Prvním krokem je pro uložení úlohy pro operace při spuštění, nikoli čeká se na nich:</span><span class="sxs-lookup"><span data-stu-id="5756a-184">The first step is to store the tasks for operations when they start, rather than awaiting them:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggTask = FryEggs(2);
Egg eggs = await eggTask;
Console.WriteLine("eggs are ready");
Task<Bacon> baconTask = FryBacon(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");
Task<Toast> toastTask = ToastBread(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="5756a-185">V dalším kroku přesunete `await` příkazy pro slanina a vejce na konec metody, ještě před obsluhou snídani:</span><span class="sxs-lookup"><span data-stu-id="5756a-185">Next, you can move the `await` statements for the bacon and eggs to the end of the method, before serving breakfast:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggTask = FryEggs(2);
Task<Bacon> baconTask = FryBacon(3);
Task<Toast> toastTask = ToastBread(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Egg eggs = await eggTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="5756a-186">Předchozí kód lépe funguje.</span><span class="sxs-lookup"><span data-stu-id="5756a-186">The preceding code works better.</span></span> <span data-ttu-id="5756a-187">Spuštění asynchronních úloh současně.</span><span class="sxs-lookup"><span data-stu-id="5756a-187">You start all the asynchronous tasks at once.</span></span> <span data-ttu-id="5756a-188">Každý úkol await, pouze v případě, že potřebujete výsledky.</span><span class="sxs-lookup"><span data-stu-id="5756a-188">You await each task only when you need the results.</span></span> <span data-ttu-id="5756a-189">Předcházející kód může být podobná kódu ve webové aplikaci, který zadává požadavky do různých mikroslužeb a pak sloučí výsledky do jediné stránce.</span><span class="sxs-lookup"><span data-stu-id="5756a-189">The preceding code may be similar to code in a web application that makes requests of different microservices, then combines the results into a single page.</span></span> <span data-ttu-id="5756a-190">Provede všechny požadavky okamžitě, pak `await` všechny úlohy a vytvářet webové stránky.</span><span class="sxs-lookup"><span data-stu-id="5756a-190">You'll make all the requests immediately, then `await` all those tasks and compose the web page.</span></span>

## <a name="composition-with-tasks"></a><span data-ttu-id="5756a-191">Kompozice s úkoly</span><span class="sxs-lookup"><span data-stu-id="5756a-191">Composition with tasks</span></span>

 <span data-ttu-id="5756a-192">Máte vše připraveno k snídani současně s výjimkou informační zprávy.</span><span class="sxs-lookup"><span data-stu-id="5756a-192">You have everything ready for breakfast at the same time except the toast.</span></span> <span data-ttu-id="5756a-193">Provádění informační zprávy je složení asynchronní operaci (toasting chléb) a synchronní operace (přidání v másle a zaseknutý).</span><span class="sxs-lookup"><span data-stu-id="5756a-193">Making the toast is the composition of an asynchronous operation (toasting the bread), and synchronous operations (adding the butter and the jam).</span></span> <span data-ttu-id="5756a-194">Aktualizuje se tento kód ukazuje důležitý koncept:</span><span class="sxs-lookup"><span data-stu-id="5756a-194">Updating this code illustrates an important concept:</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5756a-195">Složení asynchronní operace, za nímž následuje synchronní práce je asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="5756a-195">The composition of an asynchronous operation followed by synchronous work is an asynchronous operation.</span></span> <span data-ttu-id="5756a-196">Uvádí další způsob, pokud operace jakékoli její části je asynchronní, celá operace je asynchronní.</span><span class="sxs-lookup"><span data-stu-id="5756a-196">Stated another way, if any portion of an operation is asynchronous, the entire operation is asynchronous.</span></span>

<span data-ttu-id="5756a-197">Předchozí kód ukázala, že můžete použít <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> objekty pro uložení spuštěné úkoly.</span><span class="sxs-lookup"><span data-stu-id="5756a-197">The preceding code showed you that you can use <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to hold running tasks.</span></span> <span data-ttu-id="5756a-198">Můžete `await` každý úkol před použitím jeho výsledek.</span><span class="sxs-lookup"><span data-stu-id="5756a-198">You `await` each task before using its result.</span></span> <span data-ttu-id="5756a-199">Dalším krokem je vytvoření metody, které představují kombinaci další práci.</span><span class="sxs-lookup"><span data-stu-id="5756a-199">The next step is to create methods that represent the combination of other work.</span></span> <span data-ttu-id="5756a-200">Ještě před obsluhou snídani, budete chtít await úloha, která představuje toasting chléb před přidáním másle a zaseknutý.</span><span class="sxs-lookup"><span data-stu-id="5756a-200">Before serving breakfast, you want to await the task that represents toasting the bread before adding butter and jam.</span></span> <span data-ttu-id="5756a-201">Může představovat, které pracují s následujícím kódem:</span><span class="sxs-lookup"><span data-stu-id="5756a-201">You can represent that work with the following code:</span></span>

[!code-csharp[ComposeToastTask](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V3/Program.cs#ComposeToastTask)]

<span data-ttu-id="5756a-202">Předchozí metoda má `async` modifikátor v podpisu.</span><span class="sxs-lookup"><span data-stu-id="5756a-202">The preceding method has the `async` modifier in its signature.</span></span> <span data-ttu-id="5756a-203">Který signalizuje kompilátoru, že tato metoda obsahuje `await` příkazu; obsahuje asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="5756a-203">That signals to the compiler that this method contains an `await` statement; it contains asynchronous operations.</span></span> <span data-ttu-id="5756a-204">Tato metoda představuje úloha, která toasts chléb, poté přičte másle a zaseknutý.</span><span class="sxs-lookup"><span data-stu-id="5756a-204">This method represents the task that toasts the bread, then adds butter and jam.</span></span> <span data-ttu-id="5756a-205">Tato metoda vrátí hodnotu <xref:System.Threading.Tasks.Task%601> , která představuje složení těchto tří operací.</span><span class="sxs-lookup"><span data-stu-id="5756a-205">This method returns a <xref:System.Threading.Tasks.Task%601> that represents the composition of those three operations.</span></span> <span data-ttu-id="5756a-206">Teď bude hlavní blok kódu:</span><span class="sxs-lookup"><span data-stu-id="5756a-206">The main block of code now becomes:</span></span>

[!code-csharp[StartConcurrentTasks](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-V3/Program.cs#Main)]

<span data-ttu-id="5756a-207">Předchozí Změna zobrazené důležitou technikou pro práci s asynchronní kód.</span><span class="sxs-lookup"><span data-stu-id="5756a-207">The previous change illustrated an important technique for working with asynchronous code.</span></span> <span data-ttu-id="5756a-208">Vytvořit úkolů tak, že oddělíte operací do nové metody, která vrátí úkol.</span><span class="sxs-lookup"><span data-stu-id="5756a-208">You compose tasks by separating the operations into a new method that returns a task.</span></span> <span data-ttu-id="5756a-209">Můžete při await pro tuto úlohu.</span><span class="sxs-lookup"><span data-stu-id="5756a-209">You can choose when to await that task.</span></span> <span data-ttu-id="5756a-210">Současně můžete spustit další úkoly.</span><span class="sxs-lookup"><span data-stu-id="5756a-210">You can start other tasks concurrently.</span></span>

## <a name="await-tasks-efficiently"></a><span data-ttu-id="5756a-211">Efektivně await úlohy</span><span class="sxs-lookup"><span data-stu-id="5756a-211">Await tasks efficiently</span></span>

<span data-ttu-id="5756a-212">Řadu `await` příkazy na konci předchozí kód lze zvýšit pomocí metody `Task` třídy.</span><span class="sxs-lookup"><span data-stu-id="5756a-212">The series of `await` statements at the end of the preceding code can be improved by using methods of the `Task` class.</span></span> <span data-ttu-id="5756a-213">Jedním z těchto rozhraní API je <xref:System.Threading.Tasks.Task.WhenAll%2A>, který vrátí hodnotu <xref:System.Threading.Tasks.Task> , která se dokončí po dokončení všech úkolů v seznamu argumentů, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="5756a-213">One of those APIs is <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns a <xref:System.Threading.Tasks.Task> that completes when all the tasks in its argument list have completed, as shown in the following code:</span></span>

```csharp
await Task.WhenAll(eggTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="5756a-214">Další možností je použít <xref:System.Threading.Tasks.Task.WhenAny%2A>, který vrátí hodnotu `Task<Task>` , která se dokončí při dokončení kterýkoliv z jejích argumentů.</span><span class="sxs-lookup"><span data-stu-id="5756a-214">Another option is to use <xref:System.Threading.Tasks.Task.WhenAny%2A>, which returns a `Task<Task>` that completes when any of its arguments completes.</span></span> <span data-ttu-id="5756a-215">Můžete očekávat vrácené úlohy vědomím, že již byla dokončena.</span><span class="sxs-lookup"><span data-stu-id="5756a-215">You can await the returned task, knowing that it has already finished.</span></span> <span data-ttu-id="5756a-216">Následující kód ukazuje, jak můžete použít <xref:System.Threading.Tasks.Task.WhenAny%2A> await pro čekání na dokončení a následně zpracovat výsledek první úlohy.</span><span class="sxs-lookup"><span data-stu-id="5756a-216">The following code shows how you could use <xref:System.Threading.Tasks.Task.WhenAny%2A> to await the first task to finish and then process its result.</span></span> <span data-ttu-id="5756a-217">Po zpracování výsledku dokončeného úkolu, odeberete ze seznamu úkolů předán dokončeného úkolu `WhenAny`.</span><span class="sxs-lookup"><span data-stu-id="5756a-217">After processing the result from the completed task, you remove that completed task from the list of tasks passed to `WhenAny`.</span></span>

[!code-csharp[AwaitAnyTask](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-final/Program.cs#AwaitAnyTask)]

<span data-ttu-id="5756a-218">Za všechny tyto změny, finální verzi `Main` vypadá podobně jako následující kód:</span><span class="sxs-lookup"><span data-stu-id="5756a-218">After all those changes, the final version of `Main` looks like the following code:</span></span>

[!code-csharp[Final](~/samples/snippets/csharp/tour-of-async/AsyncBreakfast-final/Program.cs#Main)]

<span data-ttu-id="5756a-219">Tento poslední kód je asynchronní.</span><span class="sxs-lookup"><span data-stu-id="5756a-219">This final code is asynchronous.</span></span> <span data-ttu-id="5756a-220">Přesněji odráží, jak by osoba Cookovy snídani.</span><span class="sxs-lookup"><span data-stu-id="5756a-220">It more accurately reflects how a person would cook a breakfast.</span></span> <span data-ttu-id="5756a-221">Porovnání předchozí kód s první příklad v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="5756a-221">Compare the preceding code with the first code sample in this article.</span></span> <span data-ttu-id="5756a-222">Základní akce jsou stále zřejmé z čtení kódu.</span><span class="sxs-lookup"><span data-stu-id="5756a-222">The core actions are still clear from reading the code.</span></span> <span data-ttu-id="5756a-223">Tento kód si můžete přečíst stejně jako byste si přečíst tyto pokyny pro vytváření snídani na začátku tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="5756a-223">You can read this code the same way you'd read those instructions for making a breakfast at the beginning of this article.</span></span> <span data-ttu-id="5756a-224">Funkce jazyka `async` a `await` poskytnout překlad každá osoba díky dodržovat ty písemných pokynů: zahájení úloh můžete a nemusíte blokovat čekání na dokončení úloh.</span><span class="sxs-lookup"><span data-stu-id="5756a-224">The language features for `async` and `await` provide the translation every person makes to follow those written instructions: start tasks as you can and don't block waiting for tasks to complete.</span></span>
