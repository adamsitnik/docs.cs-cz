---
title: Rozlišování delegátů a událostí
description: Přečtěte si rozdíl mezi delegáty a událostmi a kdy použít každou z těchto funkcí .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: ff90af1d2b1a92f06eed58228f8e8ca5ff6b93ca
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/29/2019
ms.locfileid: "73037322"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="9603a-103">Rozlišování delegátů a událostí</span><span class="sxs-lookup"><span data-stu-id="9603a-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="9603a-104">Předchozí</span><span class="sxs-lookup"><span data-stu-id="9603a-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="9603a-105">Vývojáři, kteří jsou noví na platformě .NET Core, se často bojovat při rozhodování mezi návrhem založeným na `delegates` a návrhem na základě `events`.</span><span class="sxs-lookup"><span data-stu-id="9603a-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="9603a-106">Toto je obtížné koncept, protože tyto dvě jazykové funkce jsou velmi podobné.</span><span class="sxs-lookup"><span data-stu-id="9603a-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="9603a-107">Události jsou dokonce vytvořené pomocí jazykové podpory pro delegáty.</span><span class="sxs-lookup"><span data-stu-id="9603a-107">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="9603a-108">Nabízí jak scénář pozdní vazby: umožňuje scénáře, kdy komponenta komunikuje, voláním metody, která je známá pouze za běhu.</span><span class="sxs-lookup"><span data-stu-id="9603a-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="9603a-109">Obě tyto metody podporují jednu i více předplatitelů.</span><span class="sxs-lookup"><span data-stu-id="9603a-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="9603a-110">Můžete to zjistit jako singlecast a podpora vícesměrového vysílání.</span><span class="sxs-lookup"><span data-stu-id="9603a-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="9603a-111">Obě podporují podobnou syntaxi pro přidávání a odebírání obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="9603a-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="9603a-112">Nakonec vyvolání události a volání delegáta používá přesně stejnou syntaxi volání metody.</span><span class="sxs-lookup"><span data-stu-id="9603a-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="9603a-113">I oba podporují stejnou syntaxi metody `Invoke()` pro použití s operátorem `?.`.</span><span class="sxs-lookup"><span data-stu-id="9603a-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="9603a-114">U všech podobných funkcí je snadné mít problémy s určením, kdy se má použít.</span><span class="sxs-lookup"><span data-stu-id="9603a-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="9603a-115">Naslouchat události je nepovinné.</span><span class="sxs-lookup"><span data-stu-id="9603a-115">Listening to Events is Optional</span></span>

<span data-ttu-id="9603a-116">Nejdůležitějším aspektem při rozhodování o tom, kterou jazykovou funkci použít, je, zda musí být připojen předplatitel.</span><span class="sxs-lookup"><span data-stu-id="9603a-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="9603a-117">Pokud váš kód musí volat kód dodaný předplatitelem, měli byste použít návrh založený na delegátech.</span><span class="sxs-lookup"><span data-stu-id="9603a-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="9603a-118">Pokud váš kód může dokončit veškerou práci bez volání jakýchkoli předplatitelů, měli byste použít návrh založený na událostech.</span><span class="sxs-lookup"><span data-stu-id="9603a-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="9603a-119">Vezměte v úvahu příklady vytvořené v této části.</span><span class="sxs-lookup"><span data-stu-id="9603a-119">Consider the examples built during this section.</span></span> <span data-ttu-id="9603a-120">Kód, který jste vytvořili pomocí `List.Sort()`, musí být předána funkci Comparer, aby bylo možné správně seřadit prvky.</span><span class="sxs-lookup"><span data-stu-id="9603a-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="9603a-121">Dotazy LINQ musí být dodány s delegáty, aby bylo možné určit, jaké prvky se mají vrátit.</span><span class="sxs-lookup"><span data-stu-id="9603a-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="9603a-122">Používali jsme návrh sestavený s delegáty.</span><span class="sxs-lookup"><span data-stu-id="9603a-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="9603a-123">Zvažte `Progress` událost.</span><span class="sxs-lookup"><span data-stu-id="9603a-123">Consider the `Progress` event.</span></span> <span data-ttu-id="9603a-124">Oznamuje průběh úkolu.</span><span class="sxs-lookup"><span data-stu-id="9603a-124">It reports progress on a task.</span></span>
<span data-ttu-id="9603a-125">Úloha bude pokračovat bez ohledu na to, zda existují nějaké naslouchací procesy.</span><span class="sxs-lookup"><span data-stu-id="9603a-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="9603a-126">`FileSearcher` je další příklad.</span><span class="sxs-lookup"><span data-stu-id="9603a-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="9603a-127">Pořád bude hledat a najít všechny hledané soubory, a to i v případě, že nejsou připojeni žádní Odběratelé.</span><span class="sxs-lookup"><span data-stu-id="9603a-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="9603a-128">Ovládací prvky uživatelského rozhraní i nadále fungují správně, i když neexistují předplatitelé, kteří na ně naslouchajíi událostmi.</span><span class="sxs-lookup"><span data-stu-id="9603a-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="9603a-129">Používají návrhy založené na událostech.</span><span class="sxs-lookup"><span data-stu-id="9603a-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="9603a-130">Návratové hodnoty vyžadují delegáty.</span><span class="sxs-lookup"><span data-stu-id="9603a-130">Return Values Require Delegates</span></span>

<span data-ttu-id="9603a-131">Dalším aspektem je prototyp metody, který byste chtěli pro metodu delegáta.</span><span class="sxs-lookup"><span data-stu-id="9603a-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="9603a-132">Jak jste viděli, delegáti, kteří používají pro události, mají návratový typ void.</span><span class="sxs-lookup"><span data-stu-id="9603a-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="9603a-133">Viděli jste také, že jsou k dispozici idiomy k vytváření obslužných rutin událostí, které přecházejí informace zpět do zdrojů událostí prostřednictvím úprav vlastností objektu argumentu události.</span><span class="sxs-lookup"><span data-stu-id="9603a-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="9603a-134">I když tyto idiomy fungují, nejsou tak přirozené jako vrácení hodnoty z metody.</span><span class="sxs-lookup"><span data-stu-id="9603a-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="9603a-135">Všimněte si, že tyto dvě heuristiky mohou být často k dispozici: Pokud vaše metoda delegáta vrací hodnotu, bude pravděpodobně ovlivněn algoritmus nějakým způsobem.</span><span class="sxs-lookup"><span data-stu-id="9603a-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="9603a-136">Naslouchací procesy událostí mají často delší životnost</span><span class="sxs-lookup"><span data-stu-id="9603a-136">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="9603a-137">Jedná se o mírně slabší odůvodnění.</span><span class="sxs-lookup"><span data-stu-id="9603a-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="9603a-138">Můžete ale zjistit, že návrhy založené na událostech jsou přirozenější, když zdroj události vyvolává události v dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="9603a-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="9603a-139">V mnoha systémech si můžete prohlédnout příklady pro ovládací prvky UX.</span><span class="sxs-lookup"><span data-stu-id="9603a-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="9603a-140">Jakmile se přihlásíte k odběru události, může zdroj události vyvolat události po celou dobu životnosti programu.</span><span class="sxs-lookup"><span data-stu-id="9603a-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="9603a-141">(Odběr událostí můžete zrušit, pokud je už nepotřebujete.)</span><span class="sxs-lookup"><span data-stu-id="9603a-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="9603a-142">Na rozdíl od mnoha návrhů založených na delegátech, kde je delegát použit jako argument metody a delegát se nepoužívá poté, co metoda vrátí.</span><span class="sxs-lookup"><span data-stu-id="9603a-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="9603a-143">Pečlivě vyhodnoťte</span><span class="sxs-lookup"><span data-stu-id="9603a-143">Evaluate Carefully</span></span>

<span data-ttu-id="9603a-144">Výše uvedené požadavky nejsou pevná a rychlá pravidla.</span><span class="sxs-lookup"><span data-stu-id="9603a-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="9603a-145">Místo toho představují pokyny, které vám mohou pomoci při rozhodování, která volba je nejvhodnější pro vaše konkrétní využití.</span><span class="sxs-lookup"><span data-stu-id="9603a-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="9603a-146">Vzhledem k tomu, že jsou podobné, můžete dokonce prototypovat jak obojí, tak zvážit, který by byl přirozený pro práci s.</span><span class="sxs-lookup"><span data-stu-id="9603a-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="9603a-147">Oba zpracovávají i pozdní spojování scénářů.</span><span class="sxs-lookup"><span data-stu-id="9603a-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="9603a-148">Použijte ten, který komunikuje s návrhem nejlépe.</span><span class="sxs-lookup"><span data-stu-id="9603a-148">Use the one that communicates your design the best.</span></span>
