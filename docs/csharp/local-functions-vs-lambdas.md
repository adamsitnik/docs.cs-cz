---
title: Lokální funkce vs. výrazy lambda
description: Zjistěte, proč lokální funkce může být vhodnější než výrazů lambda.
ms.date: 06/27/2016
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 17ad1e8782adbf9e0f892d72849e58ef9c5ddce1
ms.sourcegitcommit: 16aefeb2d265e69c0d80967580365fabf0c5d39a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/16/2019
ms.locfileid: "58125769"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="d088c-103">Lokální funkce ve srovnání s výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="d088c-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="d088c-104">Na první pohled [lokální funkce](programming-guide/classes-and-structs/local-functions.md) a [výrazy lambda](./programming-guide/statements-expressions-operators/lambda-expressions.md) jsou velmi podobné.</span><span class="sxs-lookup"><span data-stu-id="d088c-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="d088c-105">V mnoha případech mezi pomocí výrazů lambda a lokální funkce je otázkou styl a osobních preferencích.</span><span class="sxs-lookup"><span data-stu-id="d088c-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="d088c-106">Existují však skutečné rozdíly ve které můžete použít jeden z nich, kterých byste měli vědět.</span><span class="sxs-lookup"><span data-stu-id="d088c-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="d088c-107">Podívejme se na rozdíly mezi lokální funkcí a implementací výraz lambda faktoriálu algoritmu.</span><span class="sxs-lookup"><span data-stu-id="d088c-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="d088c-108">První verze pomocí lokální funkce:</span><span class="sxs-lookup"><span data-stu-id="d088c-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="d088c-109">Kontrast tuto implementaci s verzí, který používá výrazy lambda:</span><span class="sxs-lookup"><span data-stu-id="d088c-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="d088c-110">Lokální funkce mají názvy.</span><span class="sxs-lookup"><span data-stu-id="d088c-110">The local functions have names.</span></span> <span data-ttu-id="d088c-111">Výrazy lambda jsou anonymní metody, které jsou přiřazeny proměnné, které jsou `Func` nebo `Action` typy.</span><span class="sxs-lookup"><span data-stu-id="d088c-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="d088c-112">Při deklaraci lokální funkce typy argumentů a návratový typ jsou součástí deklarace funkce.</span><span class="sxs-lookup"><span data-stu-id="d088c-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="d088c-113">Namísto část těla výrazu lambda výraz, typ argumentu a návratový typ jsou součástí deklarace proměnné typu výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="d088c-114">Tyto dva rozdíly může vést k srozumitelnější kód.</span><span class="sxs-lookup"><span data-stu-id="d088c-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="d088c-115">Místní funkce mají jiná pravidla pro jednoznačného přiřazení než výrazů lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="d088c-116">Deklarace lokální funkce lze odkazovat z libovolného kódu místa, kde se nachází v oboru.</span><span class="sxs-lookup"><span data-stu-id="d088c-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="d088c-117">Výraz lambda musí být přiřazen proměnné delegáta předtím, než ho můžete získat přístup (nebo ji volat prostřednictvím delegáta odkazující na výraz lambda.) Všimněte si, že verze použití výrazu lambda musí deklarovat a inicializovat výraz lambda `nthFactorial` před potřeba ho definovat.</span><span class="sxs-lookup"><span data-stu-id="d088c-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="d088c-118">Pokud to neuděláte má za následek chybu v době kompilace pro odkazování na `nthFactorial` před přiřazením.</span><span class="sxs-lookup"><span data-stu-id="d088c-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="d088c-119">Tyto rozdíly znamená, že jsou rekurzivní algoritmy vytvářel pomocí místních funkcí.</span><span class="sxs-lookup"><span data-stu-id="d088c-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="d088c-120">Můžete deklarovat a definovat místní funkci, která se zavolá sama sebe.</span><span class="sxs-lookup"><span data-stu-id="d088c-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="d088c-121">Výrazy lambda musí být deklarovány a přiřadit výchozí hodnotu dříve, než je možné znovu přiřazen do textu, který odkazuje na stejný výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="d088c-122">Pravidla jednoznačného přiřazení také vliv na všechny proměnné, které jsou zachyceny na základě místní funkce nebo lambda výraz.</span><span class="sxs-lookup"><span data-stu-id="d088c-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="d088c-123">Lambda výraz pravidla i lokální funkce vyžadují, že všechny zachycené proměnné jsou jednoznačně přiřazena v okamžiku, když místní funkce nebo lambda výraz je převeden na delegáta.</span><span class="sxs-lookup"><span data-stu-id="d088c-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="d088c-124">Rozdíl je, že výrazy lambda jsou převedeny na delegáty, pokud jsou deklarovány.</span><span class="sxs-lookup"><span data-stu-id="d088c-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="d088c-125">Lokální funkce jsou převedeny na delegáty pouze při použití jako delegát.</span><span class="sxs-lookup"><span data-stu-id="d088c-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="d088c-126">Je-li deklarovat lokální funkce a jenom na něj odkazovat pomocí volání jako metodu, nebudou převedeny na delegáta.</span><span class="sxs-lookup"><span data-stu-id="d088c-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="d088c-127">Toto pravidlo umožňuje deklarovat lokální funkce v libovolném vhodné umístění ve svém nadřazeném oboru.</span><span class="sxs-lookup"><span data-stu-id="d088c-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="d088c-128">Je běžné, chcete-li deklarovat lokální funkce na konci nadřazenou metodu po všechny návratové příkazy.</span><span class="sxs-lookup"><span data-stu-id="d088c-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="d088c-129">Třetí kompilátor může provádět statické analýzy umožňující místní funkce jednoznačně přiřadit zachyceným proměnným v nadřazeném oboru.</span><span class="sxs-lookup"><span data-stu-id="d088c-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="d088c-130">Podívejte se například:</span><span class="sxs-lookup"><span data-stu-id="d088c-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="d088c-131">Kompilátor může určit, který `LocalFunction` jednoznačně přiřadí `y` při volání.</span><span class="sxs-lookup"><span data-stu-id="d088c-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="d088c-132">Protože `LocalFunction` je volána před provedením `return` příkazu `y` je jednoznačně přiřazena v `return` příkazu.</span><span class="sxs-lookup"><span data-stu-id="d088c-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="d088c-133">Analýzy, která umožňuje analýzu příklad umožňuje čtvrtý rozdíl.</span><span class="sxs-lookup"><span data-stu-id="d088c-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="d088c-134">V závislosti na jejich používání se můžete vyhnout místních funkcí přidělení haldy, které jsou vždy nezbytné pro výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="d088c-135">Pokud je lokální funkce nikdy převeden na delegáta a žádné zachycené ve funkci místní proměnné nezachytává dalších výrazů lambda nebo místní funkce, které jsou převedeny na delegáty, kompilátor se vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="d088c-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="d088c-136">Podívejte se například asynchronní:</span><span class="sxs-lookup"><span data-stu-id="d088c-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="d088c-137">Obsahuje uzavření pro tento výraz lambda `address`, `index` a `name` proměnné.</span><span class="sxs-lookup"><span data-stu-id="d088c-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="d088c-138">V případě místních funkcí, může být objekt, který implementuje uzavření `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="d088c-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="d088c-139">Tento typ struktury by být předány podle odkazu na místní funkci.</span><span class="sxs-lookup"><span data-stu-id="d088c-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="d088c-140">Tento rozdíl v implementaci byste uložit na přidělení.</span><span class="sxs-lookup"><span data-stu-id="d088c-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="d088c-141">Instance, které jsou nezbytné pro výrazy lambda znamená, že paměť navíc přidělení, které mohou být faktor výkonu v cestách časově kritického kódu.</span><span class="sxs-lookup"><span data-stu-id="d088c-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="d088c-142">Lokální funkce nejsou tato dodatečná režie spojené.</span><span class="sxs-lookup"><span data-stu-id="d088c-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="d088c-143">V předchozím příkladu má lokální funkce verze 2 přidělení méně než verze výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="d088c-144">Lokální funkce ekvivalent tato metoda také používá třídu pro uzavření.</span><span class="sxs-lookup"><span data-stu-id="d088c-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="d088c-145">Zda uzávěru lokální funkce je implementovaná jako `class` nebo `struct` je podrobnost implementace.</span><span class="sxs-lookup"><span data-stu-id="d088c-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="d088c-146">Použít lokální funkci `struct` že výraz lambda bude vždy používat `class`.</span><span class="sxs-lookup"><span data-stu-id="d088c-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="d088c-147">Jednou z výhod konečné není ukázáno v tomto příkladu je, že je lokální funkce implementovat jako iterátory, přičemž pomocí `yield return` syntaxi pro vytvoření sekvenci hodnot.</span><span class="sxs-lookup"><span data-stu-id="d088c-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="d088c-148">`yield return` Nejsou povoleny ve výrazech lambda.</span><span class="sxs-lookup"><span data-stu-id="d088c-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="d088c-149">Zatímco lokální funkce se může zdát redundantní pro výrazy lambda, jsou ve skutečnosti slouží k jiným účelům a mají různá použití.</span><span class="sxs-lookup"><span data-stu-id="d088c-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="d088c-150">Lokální funkce jsou efektivnější pro případ, když chcete vytvořit funkci, která je volána pouze z kontextu jinou metodu.</span><span class="sxs-lookup"><span data-stu-id="d088c-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
