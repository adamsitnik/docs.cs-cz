---
title: Lokální funkce vs. výrazy lambda
description: Přečtěte si, proč místní funkce mohou být lepší volbou než výrazy lambda.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: a644b6868a37b3d6231a514dc37030cae062785a
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/29/2019
ms.locfileid: "73038803"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="cabf9-103">Místní funkce ve srovnání s lambda výrazy</span><span class="sxs-lookup"><span data-stu-id="cabf9-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="cabf9-104">Na první pohled jsou [místní funkce](programming-guide/classes-and-structs/local-functions.md) a [výrazy lambda](./programming-guide/statements-expressions-operators/lambda-expressions.md) velmi podobné.</span><span class="sxs-lookup"><span data-stu-id="cabf9-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="cabf9-105">V mnoha případech je volba mezi používáním výrazů lambda a místními funkcemi v oblasti stylu a osobní preference.</span><span class="sxs-lookup"><span data-stu-id="cabf9-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="cabf9-106">Existují však reálné rozdíly v tom, kde můžete použít jednu nebo druhou, o které byste měli vědět.</span><span class="sxs-lookup"><span data-stu-id="cabf9-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="cabf9-107">Pojďme se podívat na rozdíly mezi implementací algoritmu faktoriál lokální funkce a výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="cabf9-108">První verze pomocí místní funkce:</span><span class="sxs-lookup"><span data-stu-id="cabf9-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="cabf9-109">Naproti tomu implementace s verzí, která používá výrazy lambda:</span><span class="sxs-lookup"><span data-stu-id="cabf9-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="cabf9-110">Místní funkce mají názvy.</span><span class="sxs-lookup"><span data-stu-id="cabf9-110">The local functions have names.</span></span> <span data-ttu-id="cabf9-111">Výrazy lambda jsou anonymní metody, které jsou přiřazeny k proměnným, které jsou `Func` nebo `Action` typech.</span><span class="sxs-lookup"><span data-stu-id="cabf9-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="cabf9-112">Při deklaraci místní funkce jsou typy argumentů a návratový typ součástí deklarace funkce.</span><span class="sxs-lookup"><span data-stu-id="cabf9-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="cabf9-113">Namísto části těla výrazu lambda jsou typy argumentů a návratový typ součástí deklarace typu proměnné výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="cabf9-114">Tyto dvě rozdíly mohou být způsobeny jasným kódem.</span><span class="sxs-lookup"><span data-stu-id="cabf9-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="cabf9-115">Místní funkce mají různá pravidla pro jednoznačné přiřazení než výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="cabf9-116">Na deklaraci místní funkce se dá odkazovat z libovolného umístění kódu, kde se nachází v oboru.</span><span class="sxs-lookup"><span data-stu-id="cabf9-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="cabf9-117">Výraz lambda musí být přiřazen proměnné delegáta před tím, než může být k němu přistupný (nebo volán prostřednictvím delegáta odkazujícího na výraz lambda.) Všimněte si, že verze s výrazem lambda musí deklarovat a inicializovat výraz lambda `nthFactorial` před jeho definováním.</span><span class="sxs-lookup"><span data-stu-id="cabf9-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="cabf9-118">To nevede k chybě kompilace pro odkazování `nthFactorial` před jejich přiřazením.</span><span class="sxs-lookup"><span data-stu-id="cabf9-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="cabf9-119">Tyto rozdíly znamenají, že rekurzivní algoritmy je snazší vytvořit pomocí místních funkcí.</span><span class="sxs-lookup"><span data-stu-id="cabf9-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="cabf9-120">Můžete deklarovat a definovat místní funkci, která volá sama sebe.</span><span class="sxs-lookup"><span data-stu-id="cabf9-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="cabf9-121">Lambda výrazy musí být deklarovány a přiřazena výchozí hodnota, aby bylo možné je znovu přiřadit k těle, který odkazuje na stejný výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="cabf9-122">Pravidla přiřazení mají vliv také na všechny proměnné, které jsou zachyceny místní funkcí nebo výrazem lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="cabf9-123">Místní funkce i pravidla výrazů lambda vyžadují, aby všechny zachycené proměnné byly jednoznačně přiřazeny v okamžiku, kdy je místní funkce nebo lambda výraz převedena na delegáta.</span><span class="sxs-lookup"><span data-stu-id="cabf9-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="cabf9-124">Rozdílem je, že výrazy lambda jsou převedeny na delegáty při jejich deklaraci.</span><span class="sxs-lookup"><span data-stu-id="cabf9-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="cabf9-125">Lokální funkce jsou převedeny na delegáty pouze v případě, že se používají jako delegát.</span><span class="sxs-lookup"><span data-stu-id="cabf9-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="cabf9-126">Deklarujete-li místní funkci a pouze na ni odkazujete tak, že ji zavoláte jako metodu, nebude převedena na delegáta.</span><span class="sxs-lookup"><span data-stu-id="cabf9-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="cabf9-127">Toto pravidlo umožňuje deklarovat místní funkci v jakémkoli vhodném umístění v jeho ohraničujícím oboru.</span><span class="sxs-lookup"><span data-stu-id="cabf9-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="cabf9-128">Je běžné deklarovat místní funkce na konci nadřazené metody za libovolnými návratovými příkazy.</span><span class="sxs-lookup"><span data-stu-id="cabf9-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="cabf9-129">Třetí, kompilátor může provádět statickou analýzu, která umožňuje místním funkcím omezit přiřazení zachycených proměnných v ohraničujícím oboru.</span><span class="sxs-lookup"><span data-stu-id="cabf9-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="cabf9-130">Vezměte v úvahu tento příklad:</span><span class="sxs-lookup"><span data-stu-id="cabf9-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="cabf9-131">Kompilátor může určit, že `LocalFunction` jednoznačně přiřadí `y` při volání.</span><span class="sxs-lookup"><span data-stu-id="cabf9-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="cabf9-132">Vzhledem k tomu, že `LocalFunction` je volána před příkazem `return`, `y` je jednoznačně přiřazeno v příkazu `return`.</span><span class="sxs-lookup"><span data-stu-id="cabf9-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="cabf9-133">Analýza, která umožňuje ukázkovou analýzu, umožňuje čtvrtý rozdíl.</span><span class="sxs-lookup"><span data-stu-id="cabf9-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="cabf9-134">V závislosti na jejich použití se můžou místní funkce vyhnout přidělení haldy, které jsou vždy nutné pro výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="cabf9-135">Pokud místní funkce není nikdy převedena na delegáta a žádná z proměnných zachycených lokální funkcí není zachycena jinými výrazy lambda nebo místními funkcemi, které jsou převedeny na delegáty, kompilátor může vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="cabf9-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="cabf9-136">Vezměte v úvahu tento asynchronní příklad:</span><span class="sxs-lookup"><span data-stu-id="cabf9-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="cabf9-137">Uzavření tohoto výrazu lambda obsahuje proměnné `address`, `index` a `name`.</span><span class="sxs-lookup"><span data-stu-id="cabf9-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="cabf9-138">V případě místních funkcí může být objekt, který implementuje uzávěr, `struct` typ.</span><span class="sxs-lookup"><span data-stu-id="cabf9-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="cabf9-139">Tento typ struktury by byl předán odkazem na místní funkci.</span><span class="sxs-lookup"><span data-stu-id="cabf9-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="cabf9-140">Tento rozdíl v implementaci by byl uložen při přidělení.</span><span class="sxs-lookup"><span data-stu-id="cabf9-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="cabf9-141">Vytváření instancí nezbytných pro výrazy lambda znamená dodatečné přidělení paměti, což může být výkonový faktor v časově důležitých cestách kódu.</span><span class="sxs-lookup"><span data-stu-id="cabf9-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="cabf9-142">Místní funkce tyto režie neúčtují.</span><span class="sxs-lookup"><span data-stu-id="cabf9-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="cabf9-143">V příkladu výše má verze lokálních funkcí 2 méně přidělení než verze výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="cabf9-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="cabf9-144">Lokální funkce ekvivalentní této metodě používá také třídu pro uzavření.</span><span class="sxs-lookup"><span data-stu-id="cabf9-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="cabf9-145">Určuje, zda je uzavření místní funkce implementováno jako `class` nebo `struct` je podrobnosti implementace.</span><span class="sxs-lookup"><span data-stu-id="cabf9-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="cabf9-146">Místní funkce může použít `struct`, zatímco lambda bude vždy používat `class`.</span><span class="sxs-lookup"><span data-stu-id="cabf9-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="cabf9-147">Jedna poslední výhoda není v této ukázce znázorněná, protože místní funkce se dají implementovat jako iterátory pomocí syntaxe `yield return` k vytvoření sekvence hodnot.</span><span class="sxs-lookup"><span data-stu-id="cabf9-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="cabf9-148">Ve výrazech lambda není povolený příkaz `yield return`.</span><span class="sxs-lookup"><span data-stu-id="cabf9-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="cabf9-149">I když se místní funkce můžou jevit jako redundantní pro lambda výrazy, mají ve skutečnosti různé účely a mají odlišná použití.</span><span class="sxs-lookup"><span data-stu-id="cabf9-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="cabf9-150">Lokální funkce jsou efektivnější pro případ, když chcete napsat funkci, která je volána pouze z kontextu jiné metody.</span><span class="sxs-lookup"><span data-stu-id="cabf9-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
