---
title: Obecné vzory pro delegáty
description: Další informace o běžných vzorů pro použití delegátů v kódu, aby silné párování mezi komponentami vaší.
ms.date: 06/20/2016
ms.assetid: 0ff8fdfd-6a11-4327-b061-0f2526f35b43
ms.openlocfilehash: ea0e0b7af361b76c4b46b0a180e07b44c1fa07e1
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/08/2019
ms.locfileid: "59095695"
---
# <a name="common-patterns-for-delegates"></a><span data-ttu-id="bd509-103">Obecné vzory pro delegáty</span><span class="sxs-lookup"><span data-stu-id="bd509-103">Common Patterns for Delegates</span></span>

[<span data-ttu-id="bd509-104">Předchozí</span><span class="sxs-lookup"><span data-stu-id="bd509-104">Previous</span></span>](delegates-strongly-typed.md)

<span data-ttu-id="bd509-105">Delegáti poskytují mechanismus, který umožňuje software návrhů týkajících se minimální párování mezi komponentami.</span><span class="sxs-lookup"><span data-stu-id="bd509-105">Delegates provide a mechanism that enables software designs involving minimal coupling between components.</span></span>

<span data-ttu-id="bd509-106">Jedním z příkladů vynikající pro tento druh návrhu je LINQ.</span><span class="sxs-lookup"><span data-stu-id="bd509-106">One excellent example for this kind of design is LINQ.</span></span> <span data-ttu-id="bd509-107">Vzor výrazu dotazu LINQ spoléhá na delegáty pro všechny jeho funkce.</span><span class="sxs-lookup"><span data-stu-id="bd509-107">The LINQ Query Expression Pattern relies on delegates for all of its features.</span></span> <span data-ttu-id="bd509-108">Vezměte v úvahu tomto jednoduchém příkladu:</span><span class="sxs-lookup"><span data-stu-id="bd509-108">Consider this simple example:</span></span>

```csharp
var smallNumbers = numbers.Where(n => n < 10);
```

<span data-ttu-id="bd509-109">Tím se vyfiltrují posloupnost čísel pouze ty menší než hodnota 10.</span><span class="sxs-lookup"><span data-stu-id="bd509-109">This filters the sequence of numbers to only those less than the value 10.</span></span>
<span data-ttu-id="bd509-110">`Where` Metoda používá delegáta, který určuje, které prvky pořadí předání filtru.</span><span class="sxs-lookup"><span data-stu-id="bd509-110">The `Where` method uses a delegate that determines which elements of a sequence pass the filter.</span></span> <span data-ttu-id="bd509-111">Když vytvoříte dotaz LINQ, je třeba zadat implementace delegáta pro tento konkrétní účel.</span><span class="sxs-lookup"><span data-stu-id="bd509-111">When you create a LINQ query, you supply the implementation of the delegate for this specific purpose.</span></span>

<span data-ttu-id="bd509-112">Prototyp, kde Metoda je:</span><span class="sxs-lookup"><span data-stu-id="bd509-112">The prototype for the Where method is:</span></span>

```csharp
public static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool> predicate);
```

<span data-ttu-id="bd509-113">V tomto příkladu se opakuje se všechny metody, které jsou součástí LINQ.</span><span class="sxs-lookup"><span data-stu-id="bd509-113">This example is repeated with all the methods that are part of LINQ.</span></span> <span data-ttu-id="bd509-114">Všechny spoléhají na delegáty pro kód, který spravuje konkrétní dotaz.</span><span class="sxs-lookup"><span data-stu-id="bd509-114">They all rely on delegates for the code that manages the specific query.</span></span> <span data-ttu-id="bd509-115">Tento vzor návrhu rozhraní API je velmi efektivní informace a pochopení.</span><span class="sxs-lookup"><span data-stu-id="bd509-115">This API design pattern is a very powerful one to learn and understand.</span></span>

<span data-ttu-id="bd509-116">Tento jednoduchý příklad ukazuje, jak delegáti vyžadovat velmi málo párování mezi komponentami.</span><span class="sxs-lookup"><span data-stu-id="bd509-116">This simple example illustrates how delegates require very little coupling between components.</span></span> <span data-ttu-id="bd509-117">Není nutné vytvořit třídu, která je odvozena z určité základní třídy.</span><span class="sxs-lookup"><span data-stu-id="bd509-117">You don't need to create a class that derives from a particular base class.</span></span> <span data-ttu-id="bd509-118">Není nutné provádět konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="bd509-118">You don't need to implement a specific interface.</span></span>
<span data-ttu-id="bd509-119">Jediným požadavkem je k dispozici implementace metod, které je zásadní pro daný úkol.</span><span class="sxs-lookup"><span data-stu-id="bd509-119">The only requirement is to provide the implementation of one method that is fundamental to the task at hand.</span></span>

## <a name="building-your-own-components-with-delegates"></a><span data-ttu-id="bd509-120">Vytváření vlastních komponent pomocí delegátů</span><span class="sxs-lookup"><span data-stu-id="bd509-120">Building Your Own Components with Delegates</span></span>

<span data-ttu-id="bd509-121">Vytvořme v tomto příkladu tak, že vytvoříte komponenty pomocí návrh, který závisí na delegáty.</span><span class="sxs-lookup"><span data-stu-id="bd509-121">Let's build on that example by creating a component using a design that relies on delegates.</span></span>

<span data-ttu-id="bd509-122">Umožňuje definovat komponentu, která se dá použít pro zprávy protokolu v rozsáhlém systému.</span><span class="sxs-lookup"><span data-stu-id="bd509-122">Let's define a component that could be used for log messages in a large system.</span></span> <span data-ttu-id="bd509-123">Knihovna komponent lze použít v mnoha různých prostředích na více různých platformách.</span><span class="sxs-lookup"><span data-stu-id="bd509-123">The library components could be used in many different environments, on multiple different platforms.</span></span> <span data-ttu-id="bd509-124">Existuje mnoho běžných funkcí v komponentě, která spravuje protokoly.</span><span class="sxs-lookup"><span data-stu-id="bd509-124">There are a lot of common features in the component that manages the logs.</span></span> <span data-ttu-id="bd509-125">Bude je nutné přijmout zprávy z libovolné součásti v systému.</span><span class="sxs-lookup"><span data-stu-id="bd509-125">It will need to accept messages from any component in the system.</span></span> <span data-ttu-id="bd509-126">Tyto zprávy budou mít různé priority, které můžete spravovat součásti core.</span><span class="sxs-lookup"><span data-stu-id="bd509-126">Those messages will have different priorities, which the core component can manage.</span></span> <span data-ttu-id="bd509-127">Zprávy by měl mít časové razítko v jejich poslední archivované formuláře.</span><span class="sxs-lookup"><span data-stu-id="bd509-127">The messages should have timestamps in their final archived form.</span></span> <span data-ttu-id="bd509-128">Pro pokročilejší scénáře může filtrovat zprávy zdrojovou součástí.</span><span class="sxs-lookup"><span data-stu-id="bd509-128">For more advanced scenarios, you could filter messages by the source component.</span></span>

<span data-ttu-id="bd509-129">Existuje jeden aspekt funkce, která se často změní: kde zprávy prošly.</span><span class="sxs-lookup"><span data-stu-id="bd509-129">There is one aspect of the feature that will change often: where messages are written.</span></span> <span data-ttu-id="bd509-130">V některých prostředích může být zapsána do konzoly chyby.</span><span class="sxs-lookup"><span data-stu-id="bd509-130">In some environments, they may be written to the error console.</span></span> <span data-ttu-id="bd509-131">V jiných případech souboru.</span><span class="sxs-lookup"><span data-stu-id="bd509-131">In others, a file.</span></span> <span data-ttu-id="bd509-132">Další možnosti zahrnují úložiště databáze, protokoly událostí operačního systému nebo jiné úložiště dokumentů.</span><span class="sxs-lookup"><span data-stu-id="bd509-132">Other possibilities include database storage, OS event logs, or other document storage.</span></span>

<span data-ttu-id="bd509-133">Existují také kombinace různých typů výstup, který může použít v různých scénářích.</span><span class="sxs-lookup"><span data-stu-id="bd509-133">There are also combinations of output that might be used in different scenarios.</span></span> <span data-ttu-id="bd509-134">Můžete chtít zápis zpráv do konzoly a do souboru.</span><span class="sxs-lookup"><span data-stu-id="bd509-134">You may want to write messages to the console and to a file.</span></span>

<span data-ttu-id="bd509-135">Architekturu založenou na delegáty se poskytují velkou flexibilitu a usnadňují Podpora úložiště mechanismy, které lze přidat v budoucnosti.</span><span class="sxs-lookup"><span data-stu-id="bd509-135">A design based on delegates will provide a great deal of flexibility, and make it easy to support storage mechanisms that may be added in the future.</span></span>

<span data-ttu-id="bd509-136">U tohoto návrhu může být primární protokolu součásti nevirtuální, dokonce i zapečetěné třídy.</span><span class="sxs-lookup"><span data-stu-id="bd509-136">Under this design, the primary log component can be a non-virtual, even sealed class.</span></span> <span data-ttu-id="bd509-137">Můžete připojit v žádné sadě delegátů k zápisu zprávy do různých úložných médií.</span><span class="sxs-lookup"><span data-stu-id="bd509-137">You can plug in any set of delegates to write the messages to different storage media.</span></span> <span data-ttu-id="bd509-138">Integrované podpory pro vícesměroví delegáti usnadňuje podporu scénáře, ve kterém musí být zprávy zapisovány do víc umístění (soubor a konzoly).</span><span class="sxs-lookup"><span data-stu-id="bd509-138">The built in support for multicast delegates makes it easy to support scenarios where messages must be written to multiple locations (a file, and a console).</span></span>

## <a name="a-first-implementation"></a><span data-ttu-id="bd509-139">První provedení</span><span class="sxs-lookup"><span data-stu-id="bd509-139">A First Implementation</span></span>

<span data-ttu-id="bd509-140">Pojďme začít v malém: počáteční implementace bude přijímat nové zprávy a zapíše je použití žádné připojené delegáta.</span><span class="sxs-lookup"><span data-stu-id="bd509-140">Let's start small: the initial implementation will accept new messages, and write them using any attached delegate.</span></span> <span data-ttu-id="bd509-141">Můžete začít s jeden delegáta, který zapisuje zprávy do konzoly.</span><span class="sxs-lookup"><span data-stu-id="bd509-141">You can start with one delegate that writes messages to the console.</span></span>

[!code-csharp[LoggerImplementation](../../samples/csharp/delegates-and-events/Logger.cs#FirstImplementation "A first Logger implementation.")]

<span data-ttu-id="bd509-142">Statická třída výše je nejjednodušší věcí, které může fungovat.</span><span class="sxs-lookup"><span data-stu-id="bd509-142">The static class above is the simplest thing that can work.</span></span> <span data-ttu-id="bd509-143">Musíme napsat jednu implementaci pro metodu, která zapisuje zprávy do konzoly:</span><span class="sxs-lookup"><span data-stu-id="bd509-143">We need to write the single implementation for the method that writes messages to the console:</span></span> 

[!code-csharp[LogToConsole](../../samples/csharp/delegates-and-events/Program.cs#LogToConsole "A Console logger.")]

<span data-ttu-id="bd509-144">Nakonec je třeba připojení delegáta pomocí připojení k WriteMessage delegáta deklarovaného v protokolovacího nástroje:</span><span class="sxs-lookup"><span data-stu-id="bd509-144">Finally, you need to hook up the delegate by attaching it to the WriteMessage delegate declared in the logger:</span></span>

[!code-csharp[ConnectDelegate](../../samples/csharp/delegates-and-events/Program.cs#ConnectDelegate "Connect to the delegate")]

## <a name="practices"></a><span data-ttu-id="bd509-145">Postupy</span><span class="sxs-lookup"><span data-stu-id="bd509-145">Practices</span></span>

<span data-ttu-id="bd509-146">Naše ukázka zatím je docela jednoduché, ale stále ukazuje některé důležité pokyny pro návrhů týkajících se delegátů.</span><span class="sxs-lookup"><span data-stu-id="bd509-146">Our sample so far is fairly simple, but it still demonstrates some of the important guidelines for designs involving delegates.</span></span>

<span data-ttu-id="bd509-147">Použití delegáta typy definované v rámci jádra usnadňuje uživatelům pracovat s delegáty.</span><span class="sxs-lookup"><span data-stu-id="bd509-147">Using the delegate types defined in the Core Framework makes it easier for users to work with the delegates.</span></span> <span data-ttu-id="bd509-148">Není nutné definovat nové typy a není potřeba další typy delegátů nové, specializované vývojářům, kteří používají knihovny.</span><span class="sxs-lookup"><span data-stu-id="bd509-148">You don't need to define new types, and developers using your library do not need to learn new, specialized delegate types.</span></span>

<span data-ttu-id="bd509-149">Rozhraní používá se jako minimální a je to možné nejpružnější: Pokud chcete vytvořit nový protokolovací nástroj výstupu, musíte vytvořit jednu metodu.</span><span class="sxs-lookup"><span data-stu-id="bd509-149">The interfaces used are as minimal and as flexible as possible: To create a new output logger, you must create one method.</span></span> <span data-ttu-id="bd509-150">Tato metoda může být statickou metodu nebo metodu instance.</span><span class="sxs-lookup"><span data-stu-id="bd509-150">That method may be a static method, or an instance method.</span></span> <span data-ttu-id="bd509-151">Může mít přístup.</span><span class="sxs-lookup"><span data-stu-id="bd509-151">It may have any access.</span></span>

## <a name="formatting-output"></a><span data-ttu-id="bd509-152">Formátování výstupu</span><span class="sxs-lookup"><span data-stu-id="bd509-152">Formatting Output</span></span>

<span data-ttu-id="bd509-153">Vytvoříme tato první verze bit robustnější a poté spusťte vytváření jiných mechanismů protokolování.</span><span class="sxs-lookup"><span data-stu-id="bd509-153">Let's make this first version a bit more robust, and then start creating other logging mechanisms.</span></span>

<span data-ttu-id="bd509-154">V dalším kroku přidáme několik argumentů `LogMessage()` metodu tak, aby vaše třída protokolu vytváří více strukturovaných zprávy:</span><span class="sxs-lookup"><span data-stu-id="bd509-154">Next, let's add a few arguments to the `LogMessage()` method so that your log class creates more structured messages:</span></span>

[!code-csharp[Severity](../../samples/csharp/delegates-and-events/Logger.cs#Severity "Define severities")]
[!code-csharp[NextLogger](../../samples/csharp/delegates-and-events/Logger.cs#LoggerTwo "Refine the Logger")]

<span data-ttu-id="bd509-155">V dalším kroku vytvoříme využívání, která `Severity` výstupní argument pro filtrování zpráv, které se odesílají do protokolu.</span><span class="sxs-lookup"><span data-stu-id="bd509-155">Next, let's make use of that `Severity` argument to filter the messages that are sent to the log's output.</span></span> 

[!code-csharp[FinalLogger](../../samples/csharp/delegates-and-events/Logger.cs#LoggerFinal "Finish the Logger")]

## <a name="practices"></a><span data-ttu-id="bd509-156">Postupy</span><span class="sxs-lookup"><span data-stu-id="bd509-156">Practices</span></span>

<span data-ttu-id="bd509-157">Protokolování infrastruktury jsme přidali nové funkce.</span><span class="sxs-lookup"><span data-stu-id="bd509-157">You've added new features to the logging infrastructure.</span></span> <span data-ttu-id="bd509-158">Protože komponenta protokolovacího nástroje je velmi volně propojené na každý použitý mechanizmus výstupu a je možné přidat tyto nové funkce bez jakéhokoli dopadu na kód implementace delegáta protokolovacího nástroje.</span><span class="sxs-lookup"><span data-stu-id="bd509-158">Because the logger component is very loosely coupled to any output mechanism, these new features can be added with no impact on any of the code implementing the logger delegate.</span></span>

<span data-ttu-id="bd509-159">Jak vám pokračujte v sestavování to, uvidíte Další příklady, jak tento volné párování umožňuje větší flexibilitu při aktualizaci části webu bez uložení změn do jiných umístění.</span><span class="sxs-lookup"><span data-stu-id="bd509-159">As you keep building this, you'll see more examples of how this loose coupling enables greater flexibility in updating parts of the site without any changes to other locations.</span></span> <span data-ttu-id="bd509-160">Ve skutečnosti ve větší aplikace, třídy výstupu protokolovacího nástroje může být v jiném sestavení a dokonce ani je třeba znovu sestavit.</span><span class="sxs-lookup"><span data-stu-id="bd509-160">In fact, in a larger application, the logger output classes might be in a different assembly, and not even need to be rebuilt.</span></span>

## <a name="building-a-second-output-engine"></a><span data-ttu-id="bd509-161">Druhý modul výstupu sestavení</span><span class="sxs-lookup"><span data-stu-id="bd509-161">Building a Second Output Engine</span></span>

<span data-ttu-id="bd509-162">Součást protokolu pochází spolu dobře.</span><span class="sxs-lookup"><span data-stu-id="bd509-162">The Log component is coming along well.</span></span> <span data-ttu-id="bd509-163">Přidejme jeden další modul výstupu, který zaznamenává zprávy do souboru.</span><span class="sxs-lookup"><span data-stu-id="bd509-163">Let's add one more output engine that logs messages to a file.</span></span> <span data-ttu-id="bd509-164">Bude jím zapojí o něco víc modul výstupu.</span><span class="sxs-lookup"><span data-stu-id="bd509-164">This will be a slightly more involved output engine.</span></span> <span data-ttu-id="bd509-165">Je třída, která zapouzdřuje operací se soubory a zajišťuje, že soubor je vždy uzavřen, po každém zápisu.</span><span class="sxs-lookup"><span data-stu-id="bd509-165">It will be a class that encapsulates the file operations, and ensures that the file is always closed after each write.</span></span> <span data-ttu-id="bd509-166">Který zajistí, že všechna data vyprazdňuje na disk po vygenerování každé zprávy.</span><span class="sxs-lookup"><span data-stu-id="bd509-166">That ensures that all the data is flushed to disk after each message is generated.</span></span>

<span data-ttu-id="bd509-167">Tady je tento soubor na základě protokolovacího nástroje:</span><span class="sxs-lookup"><span data-stu-id="bd509-167">Here is that file based logger:</span></span>

[!code-csharp[FileLogger](../../samples/csharp/delegates-and-events/FileLogger.cs#FileLogger "Log to files")]

<span data-ttu-id="bd509-168">Po vytvoření této třídy, můžete vytvořit jeho instanci a připojování jeho LogMessage – metoda komponenta protokolovacího nástroje:</span><span class="sxs-lookup"><span data-stu-id="bd509-168">Once you've created this class, you can instantiate it and it attaches its LogMessage method to the Logger component:</span></span>

[!code-csharp[FileLogger](../../samples/csharp/delegates-and-events/Program.cs#FileLogger "Log to files")]

<span data-ttu-id="bd509-169">Tyto dvě se vzájemně nevylučují.</span><span class="sxs-lookup"><span data-stu-id="bd509-169">These two are not mutually exclusive.</span></span> <span data-ttu-id="bd509-170">Můžete připojit obě metody protokolu a vygenerování zprávy do konzoly a do souboru:</span><span class="sxs-lookup"><span data-stu-id="bd509-170">You could attach both log methods and generate messages to the console and a file:</span></span>

```csharp
var fileOutput = new FileLogger("log.txt");
Logger.WriteMessage += LogToConsole;
```

<span data-ttu-id="bd509-171">Později dokonce i ve stejné aplikaci, můžete odebrat jeden delegátů bez problémů v systému:</span><span class="sxs-lookup"><span data-stu-id="bd509-171">Later, even in the same application, you can remove one of the delegates without any other issues to the system:</span></span>

```csharp
Logger.WriteMessage -= LogToConsole;
```

## <a name="practices"></a><span data-ttu-id="bd509-172">Postupy</span><span class="sxs-lookup"><span data-stu-id="bd509-172">Practices</span></span>

<span data-ttu-id="bd509-173">Nyní že jste přidali Druhá obslužná rutina výstup pro protokolování subsystémů.</span><span class="sxs-lookup"><span data-stu-id="bd509-173">Now, you've added a second output handler for the logging sub-system.</span></span>
<span data-ttu-id="bd509-174">Tohle vyžaduje trochu další infrastrukturu pro podporu správně systému souborů.</span><span class="sxs-lookup"><span data-stu-id="bd509-174">This one needs a bit more infrastructure to correctly support the file system.</span></span> <span data-ttu-id="bd509-175">Delegát je metoda instance.</span><span class="sxs-lookup"><span data-stu-id="bd509-175">The delegate is an instance method.</span></span> <span data-ttu-id="bd509-176">Je také privátní metodu.</span><span class="sxs-lookup"><span data-stu-id="bd509-176">It's also a private method.</span></span>
<span data-ttu-id="bd509-177">Není nutné většího usnadnění, protože infrastruktura delegáta se můžete připojit delegáty.</span><span class="sxs-lookup"><span data-stu-id="bd509-177">There's no need for greater accessibility because the delegate infrastructure can connect the delegates.</span></span>

<span data-ttu-id="bd509-178">Za druhé návrh delegáta umožňuje více metod výstupu bez nějaký zvláštní kód.</span><span class="sxs-lookup"><span data-stu-id="bd509-178">Second, the delegate-based design enables multiple output methods without any extra code.</span></span> <span data-ttu-id="bd509-179">Není nutné žádnou další infrastrukturu pro podporu více metod výstupu sestavení.</span><span class="sxs-lookup"><span data-stu-id="bd509-179">You don't need to build any additional infrastructure to support multiple output methods.</span></span> <span data-ttu-id="bd509-180">Jednoduše stanou jinou metodu na seznamu vyvolání.</span><span class="sxs-lookup"><span data-stu-id="bd509-180">They simply become another method on the invocation list.</span></span>

<span data-ttu-id="bd509-181">Věnujte zvláštní pozornost kód v souboru protokolování metoda výstupu.</span><span class="sxs-lookup"><span data-stu-id="bd509-181">Pay special attention to the code in the file logging output method.</span></span> <span data-ttu-id="bd509-182">Ujistěte se, že nevyvolá žádné výjimky je kódován.</span><span class="sxs-lookup"><span data-stu-id="bd509-182">It is coded to ensure that it does not throw any exceptions.</span></span> <span data-ttu-id="bd509-183">Když to není vždy nezbytně nutné, je vhodné.</span><span class="sxs-lookup"><span data-stu-id="bd509-183">While this isn't always strictly necessary, it's often a good practice.</span></span> <span data-ttu-id="bd509-184">Pokud některou z metod delegáta vyvolá výjimku, nebude vyvolána zbývající delegáty, které jsou pro vyvolání.</span><span class="sxs-lookup"><span data-stu-id="bd509-184">If either of the delegate methods throws an exception, the remaining delegates that are on the invocation won't be invoked.</span></span>

<span data-ttu-id="bd509-185">Jako poslední Poznámka protokolovacího nástroje souboru musí spravovat její prostředky otevírání a zavírání souboru v každé zprávě protokolu.</span><span class="sxs-lookup"><span data-stu-id="bd509-185">As a last note, the file logger must manage its resources by opening and closing the file on each log message.</span></span> <span data-ttu-id="bd509-186">Můžete se rozhodnout ho nechat otevřené a implementovat rozhraní IDisposable a zavřete soubor, když se dokončí.</span><span class="sxs-lookup"><span data-stu-id="bd509-186">You could choose to keep the file open and implement IDisposable to close the file when you are completed.</span></span>
<span data-ttu-id="bd509-187">Některé z metod má své výhody a nevýhody.</span><span class="sxs-lookup"><span data-stu-id="bd509-187">Either method has its advantages and disadvantages.</span></span> <span data-ttu-id="bd509-188">Obě vytváří o trochu výkonnější párování mezi třídami.</span><span class="sxs-lookup"><span data-stu-id="bd509-188">Both do create a bit more coupling between the classes.</span></span>

<span data-ttu-id="bd509-189">Žádný kód ve třídě protokolovací nástroj se musel být aktualizované kvůli podpoře obou scénářích.</span><span class="sxs-lookup"><span data-stu-id="bd509-189">None of the code in the Logger class would need to be updated in order to support either scenario.</span></span>

## <a name="handling-null-delegates"></a><span data-ttu-id="bd509-190">Zpracování Null delegátů</span><span class="sxs-lookup"><span data-stu-id="bd509-190">Handling Null Delegates</span></span>

<span data-ttu-id="bd509-191">A konečně můžeme aktualizovat LogMessage – metoda tak, aby je robustní pro případy, pokud žádný výstup mechanismus, který je vybrána.</span><span class="sxs-lookup"><span data-stu-id="bd509-191">Finally, let's update the LogMessage method so that it is robust for those cases when no output mechanism is selected.</span></span> <span data-ttu-id="bd509-192">Aktuální implementace vyvolá výjimku `NullReferenceException` při `WriteMessage` delegát nemá seznam vyvolání připojen.</span><span class="sxs-lookup"><span data-stu-id="bd509-192">The current implementation will throw a `NullReferenceException` when the `WriteMessage` delegate does not have an invocation list attached.</span></span>
<span data-ttu-id="bd509-193">Návrh, který při byly připojeny žádné metody tiše pokračovat možná dáte přednost.</span><span class="sxs-lookup"><span data-stu-id="bd509-193">You may prefer a design that silently continues when no methods have been attached.</span></span> <span data-ttu-id="bd509-194">Je to snadné použití null podmíněného operátoru v kombinaci s `Delegate.Invoke()` metody:</span><span class="sxs-lookup"><span data-stu-id="bd509-194">This is easy using the null conditional operator, combined with the `Delegate.Invoke()` method:</span></span>

```csharp
public static void LogMessage(string msg)
{
    WriteMessage?.Invoke(msg);
}
```

<span data-ttu-id="bd509-195">Podmíněný operátor s hodnotou null (`?.`) při zkratům levý operand (`WriteMessage` v tomto případě) má hodnotu null, což znamená, že k zaznamenání zprávy nejsou provedeny žádné pokusy.</span><span class="sxs-lookup"><span data-stu-id="bd509-195">The null conditional operator (`?.`) short-circuits when the left operand (`WriteMessage` in this case) is null, which means no attempt is made to log a message.</span></span>

<span data-ttu-id="bd509-196">Nebude `Invoke()` metody uvedené v dokumentaci k `System.Delegate` nebo `System.MulticastDelegate`.</span><span class="sxs-lookup"><span data-stu-id="bd509-196">You won't find the `Invoke()` method listed in the documentation for `System.Delegate` or `System.MulticastDelegate`.</span></span> <span data-ttu-id="bd509-197">Kompilátor generuje bezpečnost typů `Invoke` typ deklarovat delegáta metodu pro všechny.</span><span class="sxs-lookup"><span data-stu-id="bd509-197">The compiler generates a type safe `Invoke` method for any delegate type declared.</span></span> <span data-ttu-id="bd509-198">V tomto příkladu to znamená, že `Invoke` přebírá jediný `string` argument, a má typ vrácené hodnoty void.</span><span class="sxs-lookup"><span data-stu-id="bd509-198">In this example, that means `Invoke` takes a single `string` argument, and has a void return type.</span></span>

## <a name="summary-of-practices"></a><span data-ttu-id="bd509-199">Přehled postupů</span><span class="sxs-lookup"><span data-stu-id="bd509-199">Summary of Practices</span></span>

<span data-ttu-id="bd509-200">Už víte, začátku protokolu komponentu, která by mohla být rozšířena s další uživatelé vytvářející obsah a další funkce.</span><span class="sxs-lookup"><span data-stu-id="bd509-200">You've seen the beginnings of a log component that could be expanded with other writers, and other features.</span></span> <span data-ttu-id="bd509-201">Pomocí delegátů v návrhu jsou velmi volně propojené těchto různých komponent.</span><span class="sxs-lookup"><span data-stu-id="bd509-201">By using delegates in the design these different components are very loosely coupled.</span></span> <span data-ttu-id="bd509-202">To poskytuje několik výhod.</span><span class="sxs-lookup"><span data-stu-id="bd509-202">This provides several advantages.</span></span> <span data-ttu-id="bd509-203">Je velmi snadné vytvořit nový výstup mechanismy a připojte je k systému.</span><span class="sxs-lookup"><span data-stu-id="bd509-203">It's very easy to create new output mechanisms and attach them to the system.</span></span> <span data-ttu-id="bd509-204">Tyto mechanismy stačí jenom jedna metoda: metoda, která zapíše zprávu protokolu.</span><span class="sxs-lookup"><span data-stu-id="bd509-204">These other mechanisms only need one method: the method that writes the log message.</span></span> <span data-ttu-id="bd509-205">Je návrh, který je velmi odolné, když se přidají nové funkce.</span><span class="sxs-lookup"><span data-stu-id="bd509-205">It's a design that is very resilient when new features are added.</span></span> <span data-ttu-id="bd509-206">Smlouva vyžaduje se pro všechny zapisovače je implementovat jednu metodu.</span><span class="sxs-lookup"><span data-stu-id="bd509-206">The contract required for any writer is to implement one method.</span></span> <span data-ttu-id="bd509-207">Tato metoda může být statickou metodu nebo metodu instance.</span><span class="sxs-lookup"><span data-stu-id="bd509-207">That method could be a static or instance method.</span></span> <span data-ttu-id="bd509-208">To může být veřejný, privátní nebo jiné právní přístup.</span><span class="sxs-lookup"><span data-stu-id="bd509-208">It could be public, private, or any other legal access.</span></span>

<span data-ttu-id="bd509-209">Třída protokolovacího nástroje mohli libovolný počet rozšíření nebo změny bez vnášení nejnovější změny.</span><span class="sxs-lookup"><span data-stu-id="bd509-209">The Logger class can make any number of enhancements or changes without introducing breaking changes.</span></span> <span data-ttu-id="bd509-210">Stejně jako všechny třídy nelze upravit veřejné rozhraní API bez riziko rozbíjející změny.</span><span class="sxs-lookup"><span data-stu-id="bd509-210">Like any class, you cannot modify the public API without the risk of breaking changes.</span></span> <span data-ttu-id="bd509-211">Ale protože párování mezi protokolovací nástroj a všechny moduly pro výstup je pouze prostřednictvím delegáta, necháváte žádné jiné typy (jako je rozhraní nebo základní třídy).</span><span class="sxs-lookup"><span data-stu-id="bd509-211">But, because the coupling between the logger and any output engines is only through the delegate, no other types (like interfaces or base classes) are involved.</span></span> <span data-ttu-id="bd509-212">Vazba je co nejmenší.</span><span class="sxs-lookup"><span data-stu-id="bd509-212">The coupling is as small as possible.</span></span>

[<span data-ttu-id="bd509-213">Next</span><span class="sxs-lookup"><span data-stu-id="bd509-213">Next</span></span>](events-overview.md)
