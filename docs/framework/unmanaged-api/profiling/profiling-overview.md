---
title: Přehled profilace
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 889a9b74bf0b2f2ef029dd622c7ddbbd9b844fa0
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/28/2019
ms.locfileid: "64651190"
---
# <a name="profiling-overview"></a><span data-ttu-id="56ffa-102">Přehled profilace</span><span class="sxs-lookup"><span data-stu-id="56ffa-102">Profiling Overview</span></span>
<a name="top"></a> <span data-ttu-id="56ffa-103">Profiler je nástroj, který sleduje spuštění jiné aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="56ffa-104">Common language runtime (CLR) profiler je dynamická knihovna (DLL), který obsahuje funkce, které přijímají zprávy z a odesílání zpráv do CLR pomocí Profilování rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="56ffa-105">Knihovna DLL profileru je načtena modulem CLR za běhu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-105">The profiler DLL is loaded by the CLR at run time.</span></span>  
  
 <span data-ttu-id="56ffa-106">Tradiční nástroje profilování se zaměřují na měření provádění aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="56ffa-107">To znamená že měří čas, který byl stráven v každé funkci nebo využití paměti aplikace v čase.</span><span class="sxs-lookup"><span data-stu-id="56ffa-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="56ffa-108">Rozhraní API pro profilaci, zaměřuje na širší třídu diagnostických nástrojů, jako jsou nástroje pro průchod kódem a dokonce i pokročilé pomůcky ladění.</span><span class="sxs-lookup"><span data-stu-id="56ffa-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="56ffa-109">Tato použití jsou všechna z podstaty diagnostická.</span><span class="sxs-lookup"><span data-stu-id="56ffa-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="56ffa-110">Rozhraní API profilování nejen měří, ale také sleduje provádění aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="56ffa-111">Z tohoto důvodu profilování rozhraní API byste nikdy neměli používat samotné aplikaci a spuštění aplikace nemělo záviset (nebo být ovlivněno) profilerem.</span><span class="sxs-lookup"><span data-stu-id="56ffa-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>  
  
 <span data-ttu-id="56ffa-112">Profilování aplikace CLR vyžaduje větší podporu než profilování konvenčně zkompilovaného strojového kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="56ffa-113">Důvodem je, že modul CLR zavádí pojmy jako domény aplikace, uvolňování, spravované zpracování výjimek, just-in-time (JIT) kompilaci kódu (převod jazyka Microsoft intermediate language, nebo MSIL do nativního strojového kódu) a podobné funkce.</span><span class="sxs-lookup"><span data-stu-id="56ffa-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="56ffa-114">Konvenční mechanismy profilování nelze identifikovat ani poskytnout užitečné informace o těchto funkcích.</span><span class="sxs-lookup"><span data-stu-id="56ffa-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="56ffa-115">Rozhraní API profilování poskytuje tyto chybějící informace efektivně s minimálním vlivem na výkon modulu CLR a profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>  
  
 <span data-ttu-id="56ffa-116">Kompilace JIT za běhu poskytuje dobrou příležitostí pro profilování.</span><span class="sxs-lookup"><span data-stu-id="56ffa-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="56ffa-117">Rozhraní profilování API umožňuje profileru změnit stream kódu v paměti MSIL pro rutinu před kompilací JIT.</span><span class="sxs-lookup"><span data-stu-id="56ffa-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="56ffa-118">Tímto způsobem profiler dynamicky přidá kód instrumentace do konkrétních rutin, které vyžadují hlubší šetření.</span><span class="sxs-lookup"><span data-stu-id="56ffa-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="56ffa-119">Přestože tento přístup je možný v běžných situacích, je mnohem snazší implementovat pro CLR pomocí Profilování rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>  
  
 <span data-ttu-id="56ffa-120">Tento přehled obsahuje následující části:</span><span class="sxs-lookup"><span data-stu-id="56ffa-120">This overview consists of the following sections:</span></span>  
  
- [<span data-ttu-id="56ffa-121">Rozhraní API pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-121">The Profiling API</span></span>](#profiling_api)  
  
- [<span data-ttu-id="56ffa-122">Podporované funkce</span><span class="sxs-lookup"><span data-stu-id="56ffa-122">Supported Features</span></span>](#support)  
  
- [<span data-ttu-id="56ffa-123">Vlákna oznámení</span><span class="sxs-lookup"><span data-stu-id="56ffa-123">Notification Threads</span></span>](#notification_threads)  
  
- [<span data-ttu-id="56ffa-124">Zabezpečení</span><span class="sxs-lookup"><span data-stu-id="56ffa-124">Security</span></span>](#security)  
  
- [<span data-ttu-id="56ffa-125">Kombinace spravovaného a nespravovaného kódu v Profiler kódu</span><span class="sxs-lookup"><span data-stu-id="56ffa-125">Combining Managed and Unmanaged Code in a Code Profiler</span></span>](#combining_managed_unmanaged)  
  
- [<span data-ttu-id="56ffa-126">Profilování nespravovaného kódu</span><span class="sxs-lookup"><span data-stu-id="56ffa-126">Profiling Unmanaged Code</span></span>](#unmanaged)  
  
- [<span data-ttu-id="56ffa-127">Používání modelu COM</span><span class="sxs-lookup"><span data-stu-id="56ffa-127">Using COM</span></span>](#com)  
  
- [<span data-ttu-id="56ffa-128">Zásobníky volání</span><span class="sxs-lookup"><span data-stu-id="56ffa-128">Call stacks</span></span>](#call_stacks)  
  
- [<span data-ttu-id="56ffa-129">Zpětná volání a hloubka zásobníku</span><span class="sxs-lookup"><span data-stu-id="56ffa-129">Callbacks and Stack Depth</span></span>](#callbacks)  
  
- [<span data-ttu-id="56ffa-130">Související témata</span><span class="sxs-lookup"><span data-stu-id="56ffa-130">Related Topics</span></span>](#related_topics)  
  
<a name="profiling_api"></a>   
## <a name="the-profiling-api"></a><span data-ttu-id="56ffa-131">Rozhraní API pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-131">The Profiling API</span></span>  
 <span data-ttu-id="56ffa-132">Rozhraní API profilování se obvykle používá k zápisu *profileru kód*, což je program, který sleduje běh spravované aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-132">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>  
  
 <span data-ttu-id="56ffa-133">Rozhraní API profilování je používáno profilerem knihovny DLL, který je zaveden ve stejném procesu jako aplikace, která je právě profilována.</span><span class="sxs-lookup"><span data-stu-id="56ffa-133">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="56ffa-134">Knihovna DLL profileru implementuje rozhraní zpětného volání ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) v rozhraní .NET Framework verze 1.0 a 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) ve verzi 2.0 a novější).</span><span class="sxs-lookup"><span data-stu-id="56ffa-134">The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="56ffa-135">CLR volá metody v tomto rozhraní pro oznámení profileru událostí PROFILOVANÉHO procesu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-135">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="56ffa-136">Profiler volat zpět do modulu runtime pomocí metod v [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) a [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) rozhraní k získání informací o stavu profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-136">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="56ffa-137">Pouze část shromažďování dat řešení profileru by měl běžet ve stejném procesu jako profilovaná aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-137">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="56ffa-138">Všechny analýzy uživatelského rozhraní a dat je třeba provést v samostatném procesu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-138">All user interface and data analysis should be performed in a separate process.</span></span>  
  
 <span data-ttu-id="56ffa-139">Následující obrázek znázorňuje interakci profileru DLL s aplikací, která je právě profilována a CLR.</span><span class="sxs-lookup"><span data-stu-id="56ffa-139">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>  
  
 ![Snímek obrazovky zobrazující profilování architektury.](./media/profiling-overview/profiling-architecture.png)  
  
### <a name="the-notification-interfaces"></a><span data-ttu-id="56ffa-141">Rozhraní oznámení</span><span class="sxs-lookup"><span data-stu-id="56ffa-141">The Notification Interfaces</span></span>  
 <span data-ttu-id="56ffa-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) a [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) lze považovat za rozhraní upozornění.</span><span class="sxs-lookup"><span data-stu-id="56ffa-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="56ffa-143">Tato rozhraní se skládají z metod, jako [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), a [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="56ffa-143">These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="56ffa-144">Pokaždé, když modul CLR načte nebo zruší načtení třídy, zkompiluje funkci, a tak dále, zavolá odpovídající metodu v profileru `ICorProfilerCallback` nebo `ICorProfilerCallback2` rozhraní.</span><span class="sxs-lookup"><span data-stu-id="56ffa-144">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>  
  
 <span data-ttu-id="56ffa-145">Například profilování může měřit výkon kódu přes dvě funkce oznámení: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) a [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="56ffa-145">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span></span> <span data-ttu-id="56ffa-146">Prostě časová razítka každého oznámení, shromáždí výsledky a vypíše seznam, který určuje, které funkce spotřebované nejvíce procesoru nebo v nastavenou času během spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-146">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>  
  
### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="56ffa-147">Rozhraní načítání informací</span><span class="sxs-lookup"><span data-stu-id="56ffa-147">The Information Retrieval Interfaces</span></span>  
 <span data-ttu-id="56ffa-148">Další hlavní rozhraní součástí profilování jsou [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) a [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="56ffa-148">The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="56ffa-149">Profiler volá tato rozhraní podle potřeby k získání dalších informací usnadňujících analýzu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-149">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="56ffa-150">Například pokaždé, když kterou volá CLR [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) funkce, poskytne funkci identifikátor.</span><span class="sxs-lookup"><span data-stu-id="56ffa-150">For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="56ffa-151">Profiler můžete získat další informace o této funkci voláním [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) metoda ke zjištění nadřazené třídy funkce, název a tak dále.</span><span class="sxs-lookup"><span data-stu-id="56ffa-151">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>  
  
 [<span data-ttu-id="56ffa-152">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-152">Back to top</span></span>](#top)  
  
<a name="support"></a>   
## <a name="supported-features"></a><span data-ttu-id="56ffa-153">Podporované funkce</span><span class="sxs-lookup"><span data-stu-id="56ffa-153">Supported Features</span></span>  
 <span data-ttu-id="56ffa-154">Rozhraní API profilování poskytuje informace o různých událostech a akcích, které se vyskytují v modulu common language runtime.</span><span class="sxs-lookup"><span data-stu-id="56ffa-154">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="56ffa-155">Tyto informace můžete použít ke sledování vnitřního chodu procesů a k analýze výkonu aplikace .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="56ffa-155">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>  
  
 <span data-ttu-id="56ffa-156">Rozhraní API profilování načítá informace o následujících akcích a událostech, které se vyskytují v CLR:</span><span class="sxs-lookup"><span data-stu-id="56ffa-156">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>  
  
- <span data-ttu-id="56ffa-157">Události spuštění a vypnutí CLR.</span><span class="sxs-lookup"><span data-stu-id="56ffa-157">CLR startup and shutdown events.</span></span>  
  
- <span data-ttu-id="56ffa-158">Aplikace domain událost vytvoření a ukončení.</span><span class="sxs-lookup"><span data-stu-id="56ffa-158">Application domain creation and shutdown events.</span></span>  
  
- <span data-ttu-id="56ffa-159">Načítání a uvolňování události sestavení.</span><span class="sxs-lookup"><span data-stu-id="56ffa-159">Assembly loading and unloading events.</span></span>  
  
- <span data-ttu-id="56ffa-160">Modul události načítání a uvolňování.</span><span class="sxs-lookup"><span data-stu-id="56ffa-160">Module loading and unloading events.</span></span>  
  
- <span data-ttu-id="56ffa-161">Vytváření a ničení událostí serveru COM vtable.</span><span class="sxs-lookup"><span data-stu-id="56ffa-161">COM vtable creation and destruction events.</span></span>  
  
- <span data-ttu-id="56ffa-162">Just-in-time (JIT) kompilaci a události odsazování kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-162">Just-in-time (JIT) compilation and code-pitching events.</span></span>  
  
- <span data-ttu-id="56ffa-163">Události načítání a uvolňování třídy.</span><span class="sxs-lookup"><span data-stu-id="56ffa-163">Class loading and unloading events.</span></span>  
  
- <span data-ttu-id="56ffa-164">Události vytváření a ničení vlákna.</span><span class="sxs-lookup"><span data-stu-id="56ffa-164">Thread creation and destruction events.</span></span>  
  
- <span data-ttu-id="56ffa-165">Vstupní a výstupní události funkce.</span><span class="sxs-lookup"><span data-stu-id="56ffa-165">Function entry and exit events.</span></span>  
  
- <span data-ttu-id="56ffa-166">Výjimky.</span><span class="sxs-lookup"><span data-stu-id="56ffa-166">Exceptions.</span></span>  
  
- <span data-ttu-id="56ffa-167">Přechody mezi spravovaným a nespravovaným kódem provádění.</span><span class="sxs-lookup"><span data-stu-id="56ffa-167">Transitions between managed and unmanaged code execution.</span></span>  
  
- <span data-ttu-id="56ffa-168">Přechody mezi různými kontexty za běhu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-168">Transitions between different runtime contexts.</span></span>  
  
- <span data-ttu-id="56ffa-169">Informace o pozastavení běhu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-169">Information about runtime suspensions.</span></span>  
  
- <span data-ttu-id="56ffa-170">Informace o modulu runtime paměti haldy a uvolňování paměti kolekce aktivity.</span><span class="sxs-lookup"><span data-stu-id="56ffa-170">Information about the runtime memory heap and garbage collection activity.</span></span>  
  
 <span data-ttu-id="56ffa-171">Rozhraní API profilování lze volat z libovolného (nespravovaného) jazyka kompatibilního s modelem COM.</span><span class="sxs-lookup"><span data-stu-id="56ffa-171">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>  
  
 <span data-ttu-id="56ffa-172">Rozhraní API je efektivní z hlediska spotřeby procesoru a paměti.</span><span class="sxs-lookup"><span data-stu-id="56ffa-172">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="56ffa-173">Profilování nezahrnuje změny profilované aplikace, které jsou natolik závažné, aby způsobovaly zavádějící výsledky.</span><span class="sxs-lookup"><span data-stu-id="56ffa-173">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>  
  
 <span data-ttu-id="56ffa-174">Rozhraní API profilování je užitečné pro vzorkovací i nevzorkovací profilovací programy.</span><span class="sxs-lookup"><span data-stu-id="56ffa-174">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="56ffa-175">A *vzorkování profileru* kontroluje profil při pravidelných taktech, například 5 milisekund od sebe.</span><span class="sxs-lookup"><span data-stu-id="56ffa-175">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="56ffa-176">A *profiler bez vzorkování* je informován o události synchronně s vláknem, které událost způsobilo.</span><span class="sxs-lookup"><span data-stu-id="56ffa-176">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>  
  
### <a name="unsupported-functionality"></a><span data-ttu-id="56ffa-177">Nepodporované funkce</span><span class="sxs-lookup"><span data-stu-id="56ffa-177">Unsupported Functionality</span></span>  
 <span data-ttu-id="56ffa-178">Rozhraní profilování API nepodporuje následující funkce:</span><span class="sxs-lookup"><span data-stu-id="56ffa-178">The profiling API does not support the following functionality:</span></span>  
  
- <span data-ttu-id="56ffa-179">Nespravovaný kód, který musí být profilován použitím konvenčních metod Win32.</span><span class="sxs-lookup"><span data-stu-id="56ffa-179">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="56ffa-180">Profiler modulu CLR však zahrnuje události přechodu k určení hranic mezi spravovaným a nespravovaným kódem.</span><span class="sxs-lookup"><span data-stu-id="56ffa-180">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>  
  
- <span data-ttu-id="56ffa-181">Aplikace, které upravují vlastní kód pro účely, jako je aspektově orientované programování upravující samy sebe.</span><span class="sxs-lookup"><span data-stu-id="56ffa-181">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>  
  
- <span data-ttu-id="56ffa-182">Kontrola hranic, protože profilování rozhraní API neposkytuje tyto informace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-182">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="56ffa-183">CLR poskytuje vnitřní podporu pro kontrolu veškerého spravovaného kódu hranic.</span><span class="sxs-lookup"><span data-stu-id="56ffa-183">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>  
  
- <span data-ttu-id="56ffa-184">Vzdálené profilování, což není podporováno z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="56ffa-184">Remote profiling, which is not supported for the following reasons:</span></span>  
  
    - <span data-ttu-id="56ffa-185">Vzdálené profilování prodlužuje dobu provádění.</span><span class="sxs-lookup"><span data-stu-id="56ffa-185">Remote profiling extends execution time.</span></span> <span data-ttu-id="56ffa-186">Při použití rozhraní profilování musíte minimalizovat čas spuštění, aby výsledky profilování nepřiměřeně ovlivněny.</span><span class="sxs-lookup"><span data-stu-id="56ffa-186">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="56ffa-187">To platí zejména při sledování výkonu provádění.</span><span class="sxs-lookup"><span data-stu-id="56ffa-187">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="56ffa-188">Ale vzdálené profilování není omezení při rozhraní profilování se používají ke sledování využití paměti nebo k získání informací o rámce zásobníku, objekty a tak dále.</span><span class="sxs-lookup"><span data-stu-id="56ffa-188">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>  
  
    - <span data-ttu-id="56ffa-189">Profiler kódu CLR musí zaregistrovat jedno nebo více rozhraní zpětného volání s modulem runtime v místním počítači, na kterém je spuštěný profilované aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-189">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="56ffa-190">To omezuje schopnost vytvářet profiler vzdáleného kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-190">This limits the ability to create a remote code profiler.</span></span>  
  
- <span data-ttu-id="56ffa-191">Profilování v provozním prostředí s požadavky na vysokou dostupnost.</span><span class="sxs-lookup"><span data-stu-id="56ffa-191">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="56ffa-192">Rozhraní API profilování bylo vytvořeno pro podporu diagnostiky v době vývoje.</span><span class="sxs-lookup"><span data-stu-id="56ffa-192">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="56ffa-193">Nebylo podrobeno, přísnému testování potřebnému pro podporu výrobních prostředí.</span><span class="sxs-lookup"><span data-stu-id="56ffa-193">It has not undergone the rigorous testing required to support production environments.</span></span>  
  
 [<span data-ttu-id="56ffa-194">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-194">Back to top</span></span>](#top)  
  
<a name="notification_threads"></a>   
## <a name="notification-threads"></a><span data-ttu-id="56ffa-195">Vlákna oznámení</span><span class="sxs-lookup"><span data-stu-id="56ffa-195">Notification Threads</span></span>  
 <span data-ttu-id="56ffa-196">Ve většině případů vlákno, které generuje událost spustí oznámení.</span><span class="sxs-lookup"><span data-stu-id="56ffa-196">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="56ffa-197">Taková oznámení (například [functionenter –](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) a [functionleave –](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) nemusí poskytovat explicitní `ThreadID`.</span><span class="sxs-lookup"><span data-stu-id="56ffa-197">Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="56ffa-198">Také profiler může rozhodnout použít místní úložiště vláken k ukládání a aktualizaci bloků analýzy namísto indexování bloků analýzy v globálním úložišti, na základě `ThreadID` ovlivněného vlákna.</span><span class="sxs-lookup"><span data-stu-id="56ffa-198">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>  
  
 <span data-ttu-id="56ffa-199">Všimněte si, že tato zpětná volání nejsou serializována.</span><span class="sxs-lookup"><span data-stu-id="56ffa-199">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="56ffa-200">Uživatelé musí chránit svůj kód vytvořením vláknově bezpečných datových struktur a uzamčením kódu profileru v případě potřeby k zabránění paralelního přístupu z více vláken.</span><span class="sxs-lookup"><span data-stu-id="56ffa-200">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="56ffa-201">Proto v některých případech je možné přijímat neobvyklou sekvenci zpětných volání.</span><span class="sxs-lookup"><span data-stu-id="56ffa-201">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="56ffa-202">Předpokládejme například, že spravovaná aplikace vyvolává dvě vlákna, která spouští stejný kód.</span><span class="sxs-lookup"><span data-stu-id="56ffa-202">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="56ffa-203">V takovém případě je možné přijímat [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) událost pro některé funkce z jednoho podprocesu a `FunctionEnter` zpětného volání z jiného podprocesu před přijetím [ ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="56ffa-203">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="56ffa-204">V tomto případě uživatel obdrží `FunctionEnter` zpětné volání pro funkci, která pravděpodobně ještě nebyla plně just-in-time (JIT) zkompilována.</span><span class="sxs-lookup"><span data-stu-id="56ffa-204">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>  
  
 [<span data-ttu-id="56ffa-205">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-205">Back to top</span></span>](#top)  
  
<a name="security"></a>   
## <a name="security"></a><span data-ttu-id="56ffa-206">Zabezpečení</span><span class="sxs-lookup"><span data-stu-id="56ffa-206">Security</span></span>  
 <span data-ttu-id="56ffa-207">Profiler DLL je nespravovaná knihovna DLL, která se spouští jako součást common language runtime prováděcí modul.</span><span class="sxs-lookup"><span data-stu-id="56ffa-207">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="56ffa-208">V důsledku toho kód v profileru DLL není v souladu s omezením zabezpečení přístupu spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-208">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="56ffa-209">Jediná omezení profileru knihoven DLL jsou ta uvalená operační systém na uživatele, který se spouští profilovanou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="56ffa-209">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>  
  
 <span data-ttu-id="56ffa-210">Autoři Profiler by měl přijmout vhodná opatření k zamezení problémů souvisejících se zabezpečením.</span><span class="sxs-lookup"><span data-stu-id="56ffa-210">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="56ffa-211">Například během instalace, knihovna DLL profileru by měl přidat na seznam řízení přístupu (ACL) tak, aby ho nemohli měnit uživatel se zlými úmysly.</span><span class="sxs-lookup"><span data-stu-id="56ffa-211">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>  
  
 [<span data-ttu-id="56ffa-212">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-212">Back to top</span></span>](#top)  
  
<a name="combining_managed_unmanaged"></a>   
## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="56ffa-213">Kombinace spravovaného a nespravovaného kódu v Profiler kódu</span><span class="sxs-lookup"><span data-stu-id="56ffa-213">Combining Managed and Unmanaged Code in a Code Profiler</span></span>  
 <span data-ttu-id="56ffa-214">Chybně napsaný profiler může způsobit cyklické odkazy na sebe sama, v důsledku nepředvídatelného chování.</span><span class="sxs-lookup"><span data-stu-id="56ffa-214">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>  
  
 <span data-ttu-id="56ffa-215">Přehled rozhraní API profilování CLR může vytvořit dojem, že píšete profiler, který obsahuje spravované a nespravované součásti, které volají navzájem prostřednictvím volání spolupráce nebo nepřímých COM.</span><span class="sxs-lookup"><span data-stu-id="56ffa-215">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>  
  
 <span data-ttu-id="56ffa-216">I když je to možné z hlediska návrhu, nepodporuje profilování rozhraní API spravované součásti.</span><span class="sxs-lookup"><span data-stu-id="56ffa-216">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="56ffa-217">CLR profiler musí být zcela nespravovaný.</span><span class="sxs-lookup"><span data-stu-id="56ffa-217">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="56ffa-218">Pokusy spojit v profileru CLR spravovaný a nespravovaný kód mohou způsobit narušení přístupu, selhání program nebo zablokování.</span><span class="sxs-lookup"><span data-stu-id="56ffa-218">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="56ffa-219">Spravované součásti profileru vrátí události zpět nespravovaným součástem, které následně zavolal spravované součásti, výsledkem jsou cyklické odkazy.</span><span class="sxs-lookup"><span data-stu-id="56ffa-219">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>  
  
 <span data-ttu-id="56ffa-220">Je jediným umístěním, kde CLR profiler může volat spravovaný kód bezpečně v těle Microsoft intermediate language (MSIL) metody.</span><span class="sxs-lookup"><span data-stu-id="56ffa-220">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="56ffa-221">Doporučený postup pro úpravu textu jazyka MSIL je použít metody rekompilace JIT v [icorprofilercallback4 –](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) rozhraní.</span><span class="sxs-lookup"><span data-stu-id="56ffa-221">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.</span></span>  
  
 <span data-ttu-id="56ffa-222">Je také možné použít starší metody instrumentace ke změně jazyka MSIL.</span><span class="sxs-lookup"><span data-stu-id="56ffa-222">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="56ffa-223">Před dokončením kompilace just-in-time (JIT) funkce může profiler vložit spravovaná volání do těla MSIL metody a poté ji JIT-kompilovat ji (viz [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) metoda).</span><span class="sxs-lookup"><span data-stu-id="56ffa-223">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="56ffa-224">Tato technika lze úspěšně použít pro selektivní instrumentaci spravovaného kódu nebo ke shromáždění dat statistiky a výkonu o JIT.</span><span class="sxs-lookup"><span data-stu-id="56ffa-224">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>  
  
 <span data-ttu-id="56ffa-225">Alternativně může profiler kódu vložit nativní háky do těla MSIL každé spravované funkce, která volá nespravovaný kód.</span><span class="sxs-lookup"><span data-stu-id="56ffa-225">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="56ffa-226">Tento postup můžete použít pro instrumentaci a pokrytí.</span><span class="sxs-lookup"><span data-stu-id="56ffa-226">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="56ffa-227">Například profiler kódu může vložit háky instrumentace za každý blok MSIL k zajištění, že blok byl proveden.</span><span class="sxs-lookup"><span data-stu-id="56ffa-227">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="56ffa-228">Modifikace těla MSIL metody je velmi Jemná operace a existuje celá řada faktorů, které by měl brát v úvahu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-228">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>  
  
 [<span data-ttu-id="56ffa-229">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-229">Back to top</span></span>](#top)  
  
<a name="unmanaged"></a>   
## <a name="profiling-unmanaged-code"></a><span data-ttu-id="56ffa-230">Profilování nespravovaného kódu</span><span class="sxs-lookup"><span data-stu-id="56ffa-230">Profiling Unmanaged Code</span></span>  
 <span data-ttu-id="56ffa-231">Common language runtime (CLR) rozhraní API profilování poskytuje minimální podporu pro profilování nespravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-231">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="56ffa-232">Je k dispozici následující funkce:</span><span class="sxs-lookup"><span data-stu-id="56ffa-232">The following functionality is provided:</span></span>  
  
- <span data-ttu-id="56ffa-233">Výčet řetězů zásobníku.</span><span class="sxs-lookup"><span data-stu-id="56ffa-233">Enumeration of stack chains.</span></span> <span data-ttu-id="56ffa-234">Tato funkce umožňuje profileru kódu stanovit hranici mezi spravovaným kódem a nespravovaným kódem.</span><span class="sxs-lookup"><span data-stu-id="56ffa-234">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>  
  
- <span data-ttu-id="56ffa-235">Určení, zda řetěz zásobníku odpovídá spravovanému kódu nebo nativním kódu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-235">Determination whether a stack chain corresponds to managed code or native code.</span></span>  
  
 <span data-ttu-id="56ffa-236">V rozhraní .NET Framework verze 1.0 a 1.1 tyto metody jsou k dispozici prostřednictvím podmnožinu API ladění CLR v procesu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-236">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="56ffa-237">Jsou definovány v souboru CorDebug.idl.</span><span class="sxs-lookup"><span data-stu-id="56ffa-237">They are defined in the CorDebug.idl file.</span></span>  
  
 <span data-ttu-id="56ffa-238">V rozhraní .NET Framework 2.0 nebo novější, můžete použít [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) metodu pro tuto funkci.</span><span class="sxs-lookup"><span data-stu-id="56ffa-238">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>  
  
 [<span data-ttu-id="56ffa-239">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-239">Back to top</span></span>](#top)  
  
<a name="com"></a>   
## <a name="using-com"></a><span data-ttu-id="56ffa-240">Používání modelu COM</span><span class="sxs-lookup"><span data-stu-id="56ffa-240">Using COM</span></span>  
 <span data-ttu-id="56ffa-241">Přestože rozhraní profilování jsou definována jako rozhraní modelu COM, modul CLR (CLR) skutečně neinicializuje COM k použití těchto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="56ffa-241">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="56ffa-242">Důvodem je, abyste se vyhnuli nutnosti nastavit model vláken pomocí [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) funkce předtím, než spravovaná aplikace dostala příležitost k určení požadovaného modelu vlákna.</span><span class="sxs-lookup"><span data-stu-id="56ffa-242">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="56ffa-243">Podobně, profiler samotný neměl volat `CoInitialize`, protože může vybrat model vlákna, která není kompatibilní s profilovanou aplikací a může způsobit selhání aplikace.</span><span class="sxs-lookup"><span data-stu-id="56ffa-243">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>  
  
 [<span data-ttu-id="56ffa-244">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-244">Back to top</span></span>](#top)  
  
<a name="call_stacks"></a>   
## <a name="call-stacks"></a><span data-ttu-id="56ffa-245">Zásobníky volání</span><span class="sxs-lookup"><span data-stu-id="56ffa-245">Call Stacks</span></span>  
 <span data-ttu-id="56ffa-246">Rozhraní API profilování poskytuje dva způsoby, jak získat zásobníky volání: metodu snímku zásobníku, umožňující řídké shromažďování zásobníků volání a metodu stínového zásobníku, která sleduje zásobník volání v každém okamžiku.</span><span class="sxs-lookup"><span data-stu-id="56ffa-246">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>  
  
### <a name="stack-snapshot"></a><span data-ttu-id="56ffa-247">Snímek zásobníku</span><span class="sxs-lookup"><span data-stu-id="56ffa-247">Stack Snapshot</span></span>  
 <span data-ttu-id="56ffa-248">Snímek zásobníku je trasování zásobníku vlákna v okamžiku v čase.</span><span class="sxs-lookup"><span data-stu-id="56ffa-248">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="56ffa-249">Rozhraní API profilování podporuje trasování spravovaných funkcí v zásobníku, ale ponechává trasování nespravovaných funkcí na zásobníkem profileru vlastní.</span><span class="sxs-lookup"><span data-stu-id="56ffa-249">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>  
  
 <span data-ttu-id="56ffa-250">Další informace o tom, jak programovat profiler, aby procházel spravované zásobníky, najdete v článku [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) metody v této sadě dokumentace a [Profiler procházení zásobníku v rozhraní .NET Framework 2.0: Základy i mimo ně](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="56ffa-250">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>
  
### <a name="shadow-stack"></a><span data-ttu-id="56ffa-251">Stínový zásobník</span><span class="sxs-lookup"><span data-stu-id="56ffa-251">Shadow Stack</span></span>  
 <span data-ttu-id="56ffa-252">Příliš časté používání metody snímku může rychle vytvořit potíže s výkonem.</span><span class="sxs-lookup"><span data-stu-id="56ffa-252">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="56ffa-253">Pokud chcete často přebírat trasování zásobníku, váš profiler by měl místo toho vytvořit stín zásobníku pomocí [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [functiontailcall2 –](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), a [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) zpětných volání výjimky.</span><span class="sxs-lookup"><span data-stu-id="56ffa-253">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="56ffa-254">Stínový zásobník je vždy aktuální a lze ho snadno zkopírovat do úložiště vždy, když je potřeba snímek zásobníku.</span><span class="sxs-lookup"><span data-stu-id="56ffa-254">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>  
  
 <span data-ttu-id="56ffa-255">Stínový zásobník může získat argumenty funkce, vrácené hodnoty a informace o obecných instancích.</span><span class="sxs-lookup"><span data-stu-id="56ffa-255">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="56ffa-256">Tyto informace jsou k dispozici pouze prostřednictvím stínového zásobníku a mohou být získány při předání řízení funkci.</span><span class="sxs-lookup"><span data-stu-id="56ffa-256">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="56ffa-257">Tyto informace však nemusí být k dispozici později při spuštění funkce.</span><span class="sxs-lookup"><span data-stu-id="56ffa-257">However, this information may not be available later during the run of the function.</span></span>  
  
 [<span data-ttu-id="56ffa-258">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-258">Back to top</span></span>](#top)  
  
<a name="callbacks"></a>   
## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="56ffa-259">Zpětná volání a hloubka zásobníku</span><span class="sxs-lookup"><span data-stu-id="56ffa-259">Callbacks and Stack Depth</span></span>  
 <span data-ttu-id="56ffa-260">Zpětná volání Profiler mohou být vydána při velmi omezeném zásobníku a přetečení zásobníku při zpětném volání profileru povede k okamžitému ukončení procesu.</span><span class="sxs-lookup"><span data-stu-id="56ffa-260">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="56ffa-261">Profiler by měl Ujistěte se, že použije co nejmenší zásobník v reakci na zpětná volání.</span><span class="sxs-lookup"><span data-stu-id="56ffa-261">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="56ffa-262">Pokud profiler je určen pro použití s procesy, které jsou odolnější proti přetečení zásobníku, profiler sám by také se vyhnout neměl spouštět přetečení zásobníku.</span><span class="sxs-lookup"><span data-stu-id="56ffa-262">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>  
  
 [<span data-ttu-id="56ffa-263">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="56ffa-263">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="56ffa-264">Související témata</span><span class="sxs-lookup"><span data-stu-id="56ffa-264">Related Topics</span></span>  
  
|<span data-ttu-id="56ffa-265">Název</span><span class="sxs-lookup"><span data-stu-id="56ffa-265">Title</span></span>|<span data-ttu-id="56ffa-266">Popis</span><span class="sxs-lookup"><span data-stu-id="56ffa-266">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="56ffa-267">Nastavení prostředí profilace</span><span class="sxs-lookup"><span data-stu-id="56ffa-267">Setting Up a Profiling Environment</span></span>](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|<span data-ttu-id="56ffa-268">Vysvětluje, jak inicializovat profilování, nastavit oznámení událostí a Profilovat službu Windows.</span><span class="sxs-lookup"><span data-stu-id="56ffa-268">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|  
|[<span data-ttu-id="56ffa-269">Rozhraní pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-269">Profiling Interfaces</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|<span data-ttu-id="56ffa-270">Popisuje nespravovaná rozhraní, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-270">Describes the unmanaged interfaces that the profiling API uses.</span></span>|  
|[<span data-ttu-id="56ffa-271">Globální statické funkce pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-271">Profiling Global Static Functions</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|<span data-ttu-id="56ffa-272">Popisuje nespravované globální statické funkce, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-272">Describes the unmanaged global static functions that the profiling API uses.</span></span>|  
|[<span data-ttu-id="56ffa-273">Výčty pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-273">Profiling Enumerations</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|<span data-ttu-id="56ffa-274">Popisuje nespravované výčty, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-274">Describes the unmanaged enumerations that the profiling API uses.</span></span>|  
|[<span data-ttu-id="56ffa-275">Struktury pro profilaci</span><span class="sxs-lookup"><span data-stu-id="56ffa-275">Profiling Structures</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|<span data-ttu-id="56ffa-276">Popisuje nespravované struktury, které používá profilování API.</span><span class="sxs-lookup"><span data-stu-id="56ffa-276">Describes the unmanaged structures that the profiling API uses.</span></span>|
