---
title: Spolehlivost – doporučené postupy
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 37e6b995a84a54dfcb52460d11e9843a933a5684
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/05/2019
ms.locfileid: "57353072"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="bb55a-102">Spolehlivost – doporučené postupy</span><span class="sxs-lookup"><span data-stu-id="bb55a-102">Reliability Best Practices</span></span>

<span data-ttu-id="bb55a-103">Následující pravidla spolehlivosti jsou orientované na SQL serveru. Nicméně jsou také použity jakékoli aplikace založené na hostiteli serveru.</span><span class="sxs-lookup"><span data-stu-id="bb55a-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="bb55a-104">Je velmi důležité, aby servery, jako je SQL Server není způsobit únik těchto prostředků a nebudou snížila.</span><span class="sxs-lookup"><span data-stu-id="bb55a-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="bb55a-105">Který však nelze provést napsáním zálohující kód pro každou metodu, která mění stav objektu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="bb55a-106">Cílem je nikoli k zápisu na 100 % spolehlivý spravovaný kód, který bude obnoven. všechny chyby v jakémkoliv místě s zálohující kód.</span><span class="sxs-lookup"><span data-stu-id="bb55a-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="bb55a-107">Bylo by složitý úkol s malou pravděpodobnost úspěchu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="bb55a-108">Modul CLR (CLR) nemůže poskytnout snadno dostatečně silné záruky pro spravovaný kód k psaní udělá v kódu proveditelné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="bb55a-109">Všimněte si, že na rozdíl od technologie ASP.NET, používá systém SQL Server pouze jednoho procesu, kterou nelze recyklovat, a to bez nutnosti přepínat databázi nepřijatelně dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="bb55a-110">Tyto slabší záruky a spuštěné v jednom procesu spolehlivost podle ukončení vláken nebo recyklaci aplikační domény, pokud nedošlo k úniku nezbytné a přijímá opatření k zajištění prostředky operačního systému, jako je například obslužné rutiny nebo paměti.</span><span class="sxs-lookup"><span data-stu-id="bb55a-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="bb55a-111">Dokonce i s tímto omezením jednodušší spolehlivost stále existuje výrazné spolehlivost požadavek:</span><span class="sxs-lookup"><span data-stu-id="bb55a-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="bb55a-112">Nikdy způsobit únik těchto prostředků operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-112">Never leak operating system resources.</span></span>

- <span data-ttu-id="bb55a-113">Identifikujte všechny spravované uzamčení v všechny formuláře modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="bb55a-113">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="bb55a-114">Nikdy přerušení domény mezi aplikacemi – sdílené stavu, což <xref:System.AppDomain> recyklace fungovat bez problémů.</span><span class="sxs-lookup"><span data-stu-id="bb55a-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="bb55a-115">I když je teoreticky může, psaní spravovaného kódu pro zpracování <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, a <xref:System.OutOfMemoryException> výjimky, očekává se vývojářům umožňuje psát takového robustního kódu v rámci celé aplikace je odpor.</span><span class="sxs-lookup"><span data-stu-id="bb55a-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="bb55a-116">Z tohoto důvodu out-of-band výjimky za následek spuštěné vlákno ukončí; a pokud ukončení vlákna byl úpravy sdílený stav, které se dají určit pomocí Určuje, zda vlákno drží zámek, pak bude <xref:System.AppDomain> je uvolněna.</span><span class="sxs-lookup"><span data-stu-id="bb55a-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="bb55a-117">Při ukončení metodu, která upravuje sdílený stav, stav bude poškozený, protože není možné k zápisu do sdíleného stavu reliable zálohující kód pro aktualizace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="bb55a-118">V rozhraní .NET Framework verze 2.0 je jediným hostitelem, která vyžaduje spolehlivost systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bb55a-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="bb55a-119">Pokud vaše sestavení se spustí na SQL serveru byste měli dělat spolehlivost práce pro každý jsou součástí sestavení, i v případě, že existují určité funkce, které jsou zakázané při provozování v databázi.</span><span class="sxs-lookup"><span data-stu-id="bb55a-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="bb55a-120">Se totiž v modulu analýzy kódu zkontroluje kód na úrovni sestavení a nelze rozlišit zakázané kódu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="bb55a-121">Jiné programovací aspektem je, že SQL Server všechno, co běží v jednom procesu systému SQL Server a <xref:System.AppDomain> recyklace se používá pro všechny prostředky, jako je například paměť a operační systém zpracovává čištění.</span><span class="sxs-lookup"><span data-stu-id="bb55a-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="bb55a-122">Nemůže záviset na finalizační metody a destruktory nebo `try/finally` bloků zálohující kód.</span><span class="sxs-lookup"><span data-stu-id="bb55a-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="bb55a-123">Může být přerušeno nebo se nevolala.</span><span class="sxs-lookup"><span data-stu-id="bb55a-123">They might be interrupted or not called.</span></span>

<span data-ttu-id="bb55a-124">Mohou být vyvolány asynchronní výjimky v neočekávaných umístěních, může být každý počítač instrukce: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, a <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="bb55a-125">Spravovaná vlákna, nemusí nutně být Win32 vlákna v SQL, mohou být vlákna.</span><span class="sxs-lookup"><span data-stu-id="bb55a-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="bb55a-126">Proměnlivé sdílený stav celého procesu nebo meziaplikační doménu je velmi obtížné alter bezpečně a mělo by se vyhnout, kdykoli je to možné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="bb55a-127">Limit paměti nejsou výjimečných v systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bb55a-127">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="bb55a-128">Pokud knihovny hostované v systému SQL Server správně neaktualizuje jejich sdílený stav, je vysoká pravděpodobnost, že kód neobnoví až po restartování databáze.</span><span class="sxs-lookup"><span data-stu-id="bb55a-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="bb55a-129">Kromě toho někdy extreme je možné, že tato akce může způsobit selhání, procesu systému SQL Server způsobuje, že databáze k restartování.</span><span class="sxs-lookup"><span data-stu-id="bb55a-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="bb55a-130">Restartování databáze můžete vypnout webový server nebo by ovlivnily provoz společnosti, nespokojené dostupnosti.</span><span class="sxs-lookup"><span data-stu-id="bb55a-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="bb55a-131">Pomalé nevrácení prostředků operačního systému, jako jsou paměti nebo popisovače může způsobit, že server nakonec selhání přidělení popisovače se žádná možnost obnovení nebo potenciálně serveru pomalu může snížit výkon a snižuje na základě aplikace dostupnost.</span><span class="sxs-lookup"><span data-stu-id="bb55a-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="bb55a-132">Chceme, aby jasně, aby tyto scénáře.</span><span class="sxs-lookup"><span data-stu-id="bb55a-132">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="bb55a-133">Pravidel osvědčených postupů</span><span class="sxs-lookup"><span data-stu-id="bb55a-133">Best Practice Rules</span></span>

<span data-ttu-id="bb55a-134">Zavedení, zaměřuje na co revize kódu pro spravovaný kód, který běží na serveru museli byste zachytit pro zvýšení stability a spolehlivosti rozhraní Framework.</span><span class="sxs-lookup"><span data-stu-id="bb55a-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="bb55a-135">Všechny tyto kontroly jsou obecně vhodné a absolutní musí na serveru.</span><span class="sxs-lookup"><span data-stu-id="bb55a-135">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="bb55a-136">I v případě dead uzamčení nebo prostředek omezení systému SQL Server bude přerušit vlákno nebo dovolí <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="bb55a-137">Pokud k tomu dojde pouze zálohující kód v oblasti omezeného provádění (CER) je zaručen běh.</span><span class="sxs-lookup"><span data-stu-id="bb55a-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="bb55a-138">Použijte SafeHandle pro zabránit nedostatku prostředků</span><span class="sxs-lookup"><span data-stu-id="bb55a-138">Use SafeHandle to Avoid Resource Leaks</span></span>

<span data-ttu-id="bb55a-139">V případě třídy <xref:System.AppDomain> uvolnění, nemohou záviset na `finally` bloků nebo finalizační metody prováděný, takže je důležité abstraktní veškerý přístup prostředek operačního systému přes <xref:System.Runtime.InteropServices.SafeHandle> třídy spíše než <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, nebo Podobně jako třídy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="bb55a-140">To umožňuje sledovat a uzavření popisovače použijete i v modulu CLR <xref:System.AppDomain> vše případ.</span><span class="sxs-lookup"><span data-stu-id="bb55a-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="bb55a-141"><xref:System.Runtime.InteropServices.SafeHandle> budete používat kritickou finalizační metodu, která modul CLR bude vždy spuštěn.</span><span class="sxs-lookup"><span data-stu-id="bb55a-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="bb55a-142">Popisovač operačního systému se ukládají do bezpečného popisovače od okamžiku, kdy se vytvoří až do okamžiku, kdy se uvolní.</span><span class="sxs-lookup"><span data-stu-id="bb55a-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="bb55a-143">Neexistuje žádný časový interval naruší <xref:System.Threading.ThreadAbortException> může dojít k úniku popisovač.</span><span class="sxs-lookup"><span data-stu-id="bb55a-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="bb55a-144">Kromě toho vyvolání platformy se-počet odkazů popisovač, který umožňuje zavřít sledování životnosti popisovač, brání potíže se zabezpečením pomocí časování mezi `Dispose` a metodu, která se právě používá popisovač.</span><span class="sxs-lookup"><span data-stu-id="bb55a-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="bb55a-145">Většina tříd, které v tuto chvíli nemáte finalizační metody, jednoduše vyčistit operační systém zpracovávat už nebudete potřebovat finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="bb55a-146">Místo toho finalizační metodu bude <xref:System.Runtime.InteropServices.SafeHandle> odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="bb55a-147">Všimněte si, že <xref:System.Runtime.InteropServices.SafeHandle> není náhradou za <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="bb55a-148">Existují stále potenciální prostředku kolize a výkonu výhody explicitně uvolnit prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="bb55a-149">Pamatujte, že právě `finally` bloky, které explicitně uvolnění prostředků nemusí provést do dokončení.</span><span class="sxs-lookup"><span data-stu-id="bb55a-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="bb55a-150"><xref:System.Runtime.InteropServices.SafeHandle> umožňuje implementovat vlastní <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodu, která provádí uvolnit popisovač, jako je například stav předávání na popisovač operačního systému uvolnění rutiny nebo uvolnění sady obslužné rutiny ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="bb55a-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="bb55a-151">Modul CLR zaručuje, že tato metoda je spustit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="bb55a-152">Zodpovídá za autora <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace Ujistěte se, že popisovač vydání za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="bb55a-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="bb55a-153">Pokud tak neučiníte způsobí, že popisovač uniknout, což často vede k úniku nativní prostředky spojené s popisovačem.</span><span class="sxs-lookup"><span data-stu-id="bb55a-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="bb55a-154">Proto je důležité pro strukturu <xref:System.Runtime.InteropServices.SafeHandle> odvozené třídy tak, aby <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace nevyžaduje přidělení všechny prostředky, které nemusí být k dispozici v době vyvolání.</span><span class="sxs-lookup"><span data-stu-id="bb55a-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="bb55a-155">Všimněte si, že se dosáhlo volání metody, které může dojít k selhání v rámci implementace <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> za předpokladu, že váš kód může zpracovávat takové chyby a dokončete smlouvy k uvolnění nativní popisovač.</span><span class="sxs-lookup"><span data-stu-id="bb55a-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="bb55a-156">Pro účely ladění <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> má <xref:System.Boolean> návratovou hodnotu, která může být nastavená na `false` Pokud katastrofální chyba dochází, která znemožňuje uvolnění prostředku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="bb55a-157">Tím se budou aktivovat [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, pokud je povoleno, které vám pomůže odhalit příčinu problému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="bb55a-158">Nemá vliv na modul runtime žádným jiným způsobem; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nebude volána znovu pro stejný prostředek a v důsledku toho budou nevrácení popisovače.</span><span class="sxs-lookup"><span data-stu-id="bb55a-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="bb55a-159"><xref:System.Runtime.InteropServices.SafeHandle> není vhodné v některých kontextech.</span><span class="sxs-lookup"><span data-stu-id="bb55a-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="bb55a-160">Protože <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodu je možné spustit v <xref:System.GC> vlákna finalizační metody, všechny obslužné rutiny, které jsou vyžadovány k uvolnění na konkrétní vlákno by neměl být uzavřen do <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="bb55a-161">Pomocí modulu CLR bez dalšího kódu je možné vymazat obálek volatelných za běhu (RCW).</span><span class="sxs-lookup"><span data-stu-id="bb55a-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="bb55a-162">Pro kód, který používá platformu vyvolání a považuje za objekt modelu COM `IUnknown*` nebo <xref:System.IntPtr>, kód by měl být přepsán použití obálky RCW.</span><span class="sxs-lookup"><span data-stu-id="bb55a-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="bb55a-163"><xref:System.Runtime.InteropServices.SafeHandle> nemusí být vhodný pro tento scénář z důvodu možnost nespravovaná verze metody zpětné volání do spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-164">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-164">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-165">Použití <xref:System.Runtime.InteropServices.SafeHandle> k zapouzdření prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="bb55a-166">Nepoužívejte <xref:System.Runtime.InteropServices.HandleRef> nebo pole typu <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="bb55a-167">Ujistěte se, že finalizační metody není nutné spustit, aby se zabránilo nevrácení prostředků operačního systému</span><span class="sxs-lookup"><span data-stu-id="bb55a-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>

<span data-ttu-id="bb55a-168">Zkontrolujte vaše finalizační metody pečlivě zajistit, že i v případě, že nemají systém, není nevrácení prostředků kritické operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="bb55a-169">Na rozdíl od normální <xref:System.AppDomain> uvolnění z paměti aplikace spouští v stabilním stavem nebo serveru, jako je SQL Server se vypne a objekty nejsou dokončeny během náhlému <xref:System.AppDomain> uvolnit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="bb55a-170">Ujistěte se, že prostředky nedošlo k úniku v případě náhlé uvolnit, protože aplikace správnosti nemůže být zaručena, ale musí být zachová integrita serveru podle není nevrácení prostředků.</span><span class="sxs-lookup"><span data-stu-id="bb55a-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="bb55a-171">Použití <xref:System.Runtime.InteropServices.SafeHandle> uvolnit všechny prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="bb55a-172">Ujistěte se, který nakonec klauzule není nutné spustit zabránilo nevrácení prostředků operačního systému</span><span class="sxs-lookup"><span data-stu-id="bb55a-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>

<span data-ttu-id="bb55a-173">`finally` klauzule se zaručeně spustí mimo CERs, vyžadování vývojářům knihovny nespoléhala se na kód v rámci `finally` bloku pro uvolnění nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="bb55a-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="bb55a-174">Pomocí <xref:System.Runtime.InteropServices.SafeHandle> je doporučené řešení.</span><span class="sxs-lookup"><span data-stu-id="bb55a-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-175">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-175">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-176">Použití <xref:System.Runtime.InteropServices.SafeHandle> pro vyčištění prostředků operačního systému místo `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="bb55a-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="bb55a-177">Nepoužívejte <xref:System.IntPtr>; použijte <xref:System.Runtime.InteropServices.SafeHandle> pro zapouzdření prostředků.</span><span class="sxs-lookup"><span data-stu-id="bb55a-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="bb55a-178">Pokud nakonec klauzule musí spustit, umístěte CER.</span><span class="sxs-lookup"><span data-stu-id="bb55a-178">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="bb55a-179">Všech zámků by měl projít existující spravované uzamčení kód</span><span class="sxs-lookup"><span data-stu-id="bb55a-179">All Locks Should Go Through Existing Managed Locking Code</span></span>

<span data-ttu-id="bb55a-180">Modul CLR, musíte vědět, pokud kód je v zámek, bude věděli, že dovolí <xref:System.AppDomain> namísto pouze přerušení vlákna.</span><span class="sxs-lookup"><span data-stu-id="bb55a-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="bb55a-181">Přerušuje se vlákno může být nebezpečný, jak data provozovaná vlákno by mohla zůstat v nekonzistentním stavu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="bb55a-182">Proto se celý <xref:System.AppDomain> má provedení recyklace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="bb55a-183">Následky selhání k identifikaci zámku může být zablokování nebo nesprávné výsledky.</span><span class="sxs-lookup"><span data-stu-id="bb55a-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="bb55a-184">Použijte metody <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A> k identifikaci oblastí zámku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="bb55a-185">Jsou statické metody <xref:System.Threading.Thread> třídu, která se vztahují jenom na aktuální vlákno, a usnadnit tak bránit jedno vlákno v úpravách počet zámků jiné vlákno.</span><span class="sxs-lookup"><span data-stu-id="bb55a-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="bb55a-186"><xref:System.Threading.Monitor.Enter%2A> a <xref:System.Threading.Monitor.Exit%2A> mít toto oznámení CLR integrovanou, proto se doporučuje jejich používání a také použití [lock – příkaz](~/docs/csharp/language-reference/keywords/lock-statement.md), který používá tyto metody.</span><span class="sxs-lookup"><span data-stu-id="bb55a-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="bb55a-187">Další zamykání mechanismy, jako je typu číselník zámky a <xref:System.Threading.AutoResetEvent> musí volat tyto metody oznámit CLR zadání kritický oddíl.</span><span class="sxs-lookup"><span data-stu-id="bb55a-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="bb55a-188">Tyto metody nepřebírají žádné zámky; informují CLR, který je kód spouštěn v kritický oddíl a přerušení vlákna mohou způsobit sdílený stav nekonzistentní.</span><span class="sxs-lookup"><span data-stu-id="bb55a-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="bb55a-189">Pokud jste definovali vlastní typ zámku, jako jsou vlastní <xref:System.Threading.ReaderWriterLock> třídy, použijte tyto metody zamykací počet.</span><span class="sxs-lookup"><span data-stu-id="bb55a-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-190">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-190">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-191">Označit a identifikaci všech zámků pomocí <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="bb55a-192">Nepoužívejte <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, a <xref:System.Threading.Interlocked.Decrement%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="bb55a-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="bb55a-193">Neprovádějte platformu vyvolání variant Win32 z těchto metod.</span><span class="sxs-lookup"><span data-stu-id="bb55a-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="bb55a-194">Nepoužívejte <xref:System.Threading.Thread.Sleep%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="bb55a-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="bb55a-195">Nepoužívejte pole s modifikátorem volatile.</span><span class="sxs-lookup"><span data-stu-id="bb55a-195">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="bb55a-196">Vyčištění kód musí být v nakonec nebo catch bloku, nikoli následující bloku catch.</span><span class="sxs-lookup"><span data-stu-id="bb55a-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>

<span data-ttu-id="bb55a-197">Kód pro vyčištění nikdy postupujte podle `catch` blokovat; by měla být v `finally` nebo v `catch` blokovat samotný.</span><span class="sxs-lookup"><span data-stu-id="bb55a-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="bb55a-198">To by měl být normální vhodné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-198">This should be a normal good practice.</span></span>  <span data-ttu-id="bb55a-199">A `finally` blok je obecně upřednostňované, protože spouští stejný kód, když je vyvolána výjimka i když na konec `try` bloku obvykle dochází.</span><span class="sxs-lookup"><span data-stu-id="bb55a-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="bb55a-200">V případě neočekávané výjimky, například <xref:System.Threading.ThreadAbortException>, je kód čištění nelze spustit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="bb55a-201">Žádné nespravované prostředky, které by vyčištění v `finally` v ideálním případě by měl být uzavřen v <xref:System.Runtime.InteropServices.SafeHandle> zabránit úniku informací.</span><span class="sxs-lookup"><span data-stu-id="bb55a-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="bb55a-202">Poznámka: C# `using` – klíčové slovo lze účinně uvolnila objekty, včetně obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="bb55a-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="bb55a-203">I když <xref:System.AppDomain> recyklace můžete vyčistit prostředků na finalizační podproces, je stále potřeba vložit kód pro vyčištění na správné místo.</span><span class="sxs-lookup"><span data-stu-id="bb55a-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="bb55a-204">Všimněte si, že pokud vlákno obdrží asynchronní výjimky bez zámek, CLR se pokusí ukončit vlákno, samotný bez nutnosti recyklovat <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="bb55a-205">Zajištění, že prostředky se vyčistí dříve místo novější pomáhá tím, že k dispozici více prostředků a tím, že lepší spravuje životnost.</span><span class="sxs-lookup"><span data-stu-id="bb55a-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="bb55a-206">Pokud je explicitně nezavře popisovač souboru v cestě kódu některé chyby potom počkejte <xref:System.Runtime.InteropServices.SafeHandle> finalizační metody, při příštím spuštění kódu čištění, může dojít k selhání pokusu o přístup k přesně stejný soubor, pokud ještě nebyla spuštěna finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="bb55a-207">Z tohoto důvodu se vám pomůže zajistit, že kód pro vyčištění existuje a zda správně funguje zotavení z chyb při více čistě a rychle, i když to není nezbytně nutné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-208">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-208">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-209">Kód pro vyčištění po `catch` musí být v `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="bb55a-210">Umístěte volání zlikvidujte bloku finally.</span><span class="sxs-lookup"><span data-stu-id="bb55a-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="bb55a-211">`catch` pozastaví spuštění, by měl končit vyvolání nebo znovu vyvolejte.</span><span class="sxs-lookup"><span data-stu-id="bb55a-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="bb55a-212">Zatímco bude existovat výjimky, jako je například zjišťování, zda lze navázat připojení k síti kód kde některé z velkého počtu výjimek, veškerý kód, který vyžaduje zachytávání počet výjimek za normálních okolností může získat měl dát indikaci toho, že kód by měl být testován, pokud bude úspěšné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="bb55a-213">Celého procesu proměnlivý stav sdílené mezi doménami aplikace by měly být odstraněny nebo použijte oblasti omezeného provádění</span><span class="sxs-lookup"><span data-stu-id="bb55a-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>

<span data-ttu-id="bb55a-214">Jak je popsáno v úvodu, může být velmi obtížné je napsat spravovaný kód, který monitoruje sdílený stav celého procesu napříč doménami aplikace spolehlivé způsobem.</span><span class="sxs-lookup"><span data-stu-id="bb55a-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="bb55a-215">Sdílený stav celého procesu je jakýkoli druh datové struktury, které jsou sdílené mezi doménami aplikace, buď v kódu Win32, platformou CLR, nebo ve spravovaném kódu pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="bb55a-216">Žádné proměnlivé sdílený stav je velmi obtížné je napsat správně ve spravovaném kódu a všechny statické sdílený stav může být provedeno pouze velmi opatrně.</span><span class="sxs-lookup"><span data-stu-id="bb55a-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="bb55a-217">Pokud máte celého procesu nebo celý počítač sdílený stav, najdete způsob, jak jejich odstranění nebo chránit sdílený stav pomocí oblasti omezeného provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="bb55a-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="bb55a-218">Všimněte si, že všechny knihovny s sdílený stav, který není zjistila a opravila může způsobit, že hostitele, jako je SQL Server, který vyžaduje čištění <xref:System.AppDomain> uvolnění selhání.</span><span class="sxs-lookup"><span data-stu-id="bb55a-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="bb55a-219">Pokud kód používá objekt modelu COM, vyhněte se sdílení tohoto objektu COM mezi doménami aplikace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="bb55a-220">Zámky nebudou fungovat celého procesu nebo mezi doménami aplikace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>

<span data-ttu-id="bb55a-221">V minulosti <xref:System.Threading.Monitor.Enter%2A> a [lock – příkaz](~/docs/csharp/language-reference/keywords/lock-statement.md) byla použita k vytvoření globální procesu zámky.</span><span class="sxs-lookup"><span data-stu-id="bb55a-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="bb55a-222">Například k tomu dojde při zamykání <xref:System.AppDomain> agilní třídy, například <xref:System.Type> instancí z nesdílené sestavení <xref:System.Threading.Thread> objekty, internovány řetězců a některé řetězce sdíleny napříč doménami aplikace pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="bb55a-223">Tyto zámky už nejsou celého procesu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="bb55a-224">K určení přítomnosti zámek domén přes procesy mezi aplikacemi, zjistit, zda kód v rámci zámek používá všechny externí, trvalý prostředků jako je soubor na disku nebo databáze.</span><span class="sxs-lookup"><span data-stu-id="bb55a-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="bb55a-225">Mějte na paměti, přičemž zámek v rámci <xref:System.AppDomain> může způsobit potíže, pokud chráněný kód používá externí zdroj, vzhledem k tomu, že kód může současně spustit napříč několika doménami aplikace.</span><span class="sxs-lookup"><span data-stu-id="bb55a-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="bb55a-226">To může být problém při zápisu do jednoho souboru protokolu nebo vazbu na soket pro celý proces.</span><span class="sxs-lookup"><span data-stu-id="bb55a-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="bb55a-227">Tyto změny znamenají, neexistuje žádný snadný způsob, pomocí spravovaného kódu, proces globální zámek, než pomocí pojmenovaná <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore> instance.</span><span class="sxs-lookup"><span data-stu-id="bb55a-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="bb55a-228">Vytvořit kód, který nepodporuje souběžně v obou aplikačních doménách, nebo použít <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore> třídy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="bb55a-229">Pokud stávající kód nemůže být změněn, nepoužívejte k dosažení této synchronizace, protože spuštěn v režimu vlákének znamená, že nebudete moct zaručit, bude získat a uvolnění objektu mutex, na stejném vlákně operačního systému Win32 pojmenovaný vzájemně vyloučený přístup.</span><span class="sxs-lookup"><span data-stu-id="bb55a-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="bb55a-230">Je nutné použít spravovanou <xref:System.Threading.Mutex> třídy nebo pojmenovaná <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, nebo <xref:System.Threading.Semaphore> synchronizovat kód zámek způsobem, který si je vědoma namísto synchronizace zámek pomocí nespravovaného kódu CLR.</span><span class="sxs-lookup"><span data-stu-id="bb55a-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="bb55a-231">Vyhněte se lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="bb55a-231">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="bb55a-232">Privátní a veřejné <xref:System.Type> objektů v sdílená sestavení s jenom jednu kopii kódu sdílené ve všech doménách aplikace jsou k dispozici také problémy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="bb55a-233">Sdílená sestavení, je pouze jedna instance <xref:System.Type> na proces, což znamená, že více domén aplikace sdílet přesně stejné <xref:System.Type> instance.</span><span class="sxs-lookup"><span data-stu-id="bb55a-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="bb55a-234">Tak zámek na <xref:System.Type> instance převezme zámek, který má vliv na celý proces, ne jenom <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="bb55a-235">Pokud <xref:System.AppDomain> převezme Zámek <xref:System.Type> pak objektu, že vlákno náhle přeruší, neuvolní zámek.</span><span class="sxs-lookup"><span data-stu-id="bb55a-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="bb55a-236">Tohoto uzamknout pak může způsobit další aplikační domény k zablokování.</span><span class="sxs-lookup"><span data-stu-id="bb55a-236">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="bb55a-237">Dobrý způsob, jak zámky v statické metody zahrnuje přidání statické interní synchronizační objekt do kódu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="bb55a-238">To může být inicializována v konstruktoru třídy, pokud je k dispozici, ale pokud ho nelze inicializovat tímto způsobem:</span><span class="sxs-lookup"><span data-stu-id="bb55a-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="bb55a-239">Pak při přijímání zámku, použijte `InternalSyncObject` získat objekt k uzamčení na vlastnost.</span><span class="sxs-lookup"><span data-stu-id="bb55a-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="bb55a-240">Nemusíte použít vlastnost, pokud mají inicializovat interní synchronizační objekt ve vaší konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="bb55a-241">Dvojitá kontrola, zda kód inicializace uzamčení by měl vypadat jako v tomto příkladu:</span><span class="sxs-lookup"><span data-stu-id="bb55a-241">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="bb55a-242">Poznámka k Lock(this)</span><span class="sxs-lookup"><span data-stu-id="bb55a-242">A Note About Lock(this)</span></span>

<span data-ttu-id="bb55a-243">Je obecně přijatelné zámek jednotlivého objektu, který je veřejně přístupný.</span><span class="sxs-lookup"><span data-stu-id="bb55a-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="bb55a-244">Pokud je objekt typu singleton objektu, který může způsobit, že celý subsystému k vzájemnému zablokování, zvažte ale použití také výše vzoru návrhu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="bb55a-245">Například zámek na ten <xref:System.Security.SecurityManager> objekt by mohl způsobit zablokování v rámci <xref:System.AppDomain> provedení celé <xref:System.AppDomain> nepoužitelné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="bb55a-246">Je dobrým zvykem není zámek na veřejně přístupný objekt tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="bb55a-247">Ale zámek na jednotlivé kolekce nebo pole by neměla obecně dostupné na problém.</span><span class="sxs-lookup"><span data-stu-id="bb55a-247">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-248">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-248">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-249">Nepřebírají zámky na typy, které mohou být použity napříč doménami aplikace nebo nemají představu silné identity.</span><span class="sxs-lookup"><span data-stu-id="bb55a-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="bb55a-250">Nevolejte <xref:System.Threading.Monitor.Enter%2A> na <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, nebo libovolný objekt, který je odvozen od <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="bb55a-251">Odeberte uvolňování paměti. KeepAlive volání</span><span class="sxs-lookup"><span data-stu-id="bb55a-251">Remove GC.KeepAlive Calls</span></span>

<span data-ttu-id="bb55a-252">Významné množství existující kód buď nepoužívá <xref:System.GC.KeepAlive%2A> , pokud by měl nebo používá, když není vhodné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="bb55a-253">Po převedení na <xref:System.Runtime.InteropServices.SafeHandle>, není potřeba volat třídy <xref:System.GC.KeepAlive%2A>, za předpokladu, že nemají finalizační metodu, ale spoléhají na <xref:System.Runtime.InteropServices.SafeHandle> pro dokončení operační systém zpracovává.</span><span class="sxs-lookup"><span data-stu-id="bb55a-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="bb55a-254">Při snížení výkonu zachování volání <xref:System.GC.KeepAlive%2A> může být nepatrné, vnímání, který volání <xref:System.GC.KeepAlive%2A> je nezbytné nebo dostatečná k vyřešení problému, který už nemusí existovat provede kód obtížné udržovat životnost.</span><span class="sxs-lookup"><span data-stu-id="bb55a-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="bb55a-255">Nicméně, při použití vzájemné spolupráce CLR obálky volatelné modelem COM (RCW), <xref:System.GC.KeepAlive%2A> stále potřebuje kódu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-256">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-256">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-257">Odebrat <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="bb55a-258">Použijte atribut ochrany hostitele</span><span class="sxs-lookup"><span data-stu-id="bb55a-258">Use the Host Protection Attribute</span></span>

<span data-ttu-id="bb55a-259"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) poskytuje akce deklarativní zabezpečení k určení požadavků na ochranu hostitele, umožňuje hostitele i plně důvěryhodného kódu zabránit volání určitých metod, které jsou pro daného hostitele, jako je například nevhodné<xref:System.Environment.Exit%2A>nebo <xref:System.Windows.Forms.MessageBox.Show%2A> pro SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bb55a-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="bb55a-260">HPA ovlivní pouze nespravované aplikace, které hostují common language runtime a implementovat hostitele ochranu, jako je SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bb55a-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="bb55a-261">Při použití, výsledky akcí zabezpečení při vytváření požadavku propojení na základě zdroje hostitele, které zpřístupňuje třídy nebo metody.</span><span class="sxs-lookup"><span data-stu-id="bb55a-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="bb55a-262">Pokud je kód spuštěn v klientské aplikaci nebo na serveru, který není chráněný hostitel, atribut "se odpaří"; není zjištěna a proto nebyly použity.</span><span class="sxs-lookup"><span data-stu-id="bb55a-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="bb55a-263">Účelem tohoto atributu je vynucovat specifické pro hostitele programovací model pokyny, není chování zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="bb55a-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="bb55a-264">I když požadavek propojení se používá ke kontrole pro soulad s požadavky model programování <xref:System.Security.Permissions.HostProtectionAttribute> není oprávnění zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="bb55a-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="bb55a-265">Pokud hostitel nemá žádné programovací model požadavky, požadavky propojení nedojde.</span><span class="sxs-lookup"><span data-stu-id="bb55a-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="bb55a-266">Tento atribut určuje následující:</span><span class="sxs-lookup"><span data-stu-id="bb55a-266">This attribute identifies the following:</span></span>

- <span data-ttu-id="bb55a-267">Metody nebo třídy, které nebudou vyhovovat hostitele programovací model, ale jinak jsou neškodné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="bb55a-268">Metody nebo třídy, které nebudou vyhovovat programovací model hostitele a může vést k destabilizující server spravován uživatelského kódu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="bb55a-269">Metody nebo třídy, které nebudou vyhovovat hostitele programovací model a může vést k destabilizaci samotný proces serveru.</span><span class="sxs-lookup"><span data-stu-id="bb55a-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="bb55a-270">Pokud vytváříte knihovnu tříd, který má být volána aplikací, které mohou provést v prostředí hostitele chráněné, byste měli použít tento atribut na členy, které zpřístupňují <xref:System.Security.Permissions.HostProtectionResource> kategorie prostředků.</span><span class="sxs-lookup"><span data-stu-id="bb55a-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="bb55a-271">Členové knihovny tříd rozhraní .NET Framework pomocí tohoto atributu způsobí pouze bezprostředního volajícího, která se má zkontrolovat.</span><span class="sxs-lookup"><span data-stu-id="bb55a-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="bb55a-272">Vaše knihovna člen musí také způsobit kontrolu jeho bezprostředního volajícího stejným způsobem.</span><span class="sxs-lookup"><span data-stu-id="bb55a-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="bb55a-273">Vyhledejte další informace o HPA v <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-274">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-274">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-275">Pro SQL Server musí HPA označeny všechny metody, které slouží k uvození synchronizace nebo dělení na vlákna.</span><span class="sxs-lookup"><span data-stu-id="bb55a-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="bb55a-276">To zahrnuje metody, které sdílení stavu, jsou synchronizovány nebo spravovat externí procesy.</span><span class="sxs-lookup"><span data-stu-id="bb55a-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="bb55a-277"><xref:System.Security.Permissions.HostProtectionResource> Hodnoty, které ovlivňují systému SQL Server jsou <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, a <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="bb55a-278">Ale jakoukoli metodu, která zpřístupňuje všechny <xref:System.Security.Permissions.HostProtectionResource> by měly být identifikovány HPA, nejen těm, kteří používají prostředky, které mají vliv SQL.</span><span class="sxs-lookup"><span data-stu-id="bb55a-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="bb55a-279">Po neomezenou dobu nebrání v nespravovaném kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-279">Do Not Block Indefinitely in Unmanaged Code</span></span>

<span data-ttu-id="bb55a-280">Blokování v nespravovaném kódu místo ve spravovaném kódu může způsobit útoku DOS, protože modul CLR není možné přerušit vlákno.</span><span class="sxs-lookup"><span data-stu-id="bb55a-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="bb55a-281">Blokovaná vlákna zabraňuje uvolnění modulu CLR <xref:System.AppDomain>, alespoň bez provádění některých operací velmi nebezpečné.</span><span class="sxs-lookup"><span data-stu-id="bb55a-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="bb55a-282">Blokuje použití Win32 je primitiv synchronizace vymazat příkladem něco, co jsme nemůže povolit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="bb55a-283">Při volání k blokování `ReadFile` na soketu mělo by se vyhnout Pokud je to možné – v ideálním případě by měl rozhraní Win32 API poskytují mechanismus pro vypršení časového limitu operace následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="bb55a-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="bb55a-284">Jakoukoli metodu, která volá do nativní by měl v ideálním případě pomocí přiměřené omezený časový limit volání Win32.</span><span class="sxs-lookup"><span data-stu-id="bb55a-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="bb55a-285">Pokud uživatel může zadat časový limit, uživatel by neměl povoleno zadat neomezený časový limit bez nějaká konkrétní bezpečnostní oprávnění.</span><span class="sxs-lookup"><span data-stu-id="bb55a-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="bb55a-286">Jako vodítko Pokud metoda bude blokovat více než přibližně 10 sekund, budete muset používat verzi, která podporuje vypršení časového limitu nebo potřebujete další podporu modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="bb55a-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="bb55a-287">Tady je několik příkladů problematické rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="bb55a-287">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="bb55a-288">Kanály (anonymní a pojmenované) se dají vytvářet pomocí časového limitu; Nicméně kód musí měli jistotu, že nikdy volání `CreateNamedPipe` ani `WaitNamedPipe` s NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="bb55a-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="bb55a-289">Kromě toho může neočekávané zablokování i v případě, že je zadaný časový limit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="bb55a-290">Volání `WriteFile` na nepojmenovaného kanálu bude blokovat, dokud nejsou zapsány všechny bajty, což znamená, pokud má vyrovnávací paměť nepřečtená data, `WriteFile` volání bude blokovat, dokud čtecí modul má uvolnit místo ve vyrovnávací paměti do kanálu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="bb55a-291">Sokety měli vždy používat některá rozhraní API, které uznává mechanismu vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-291">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-292">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-292">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-293">Blokování bez časového limitu v nespravovaném kódu je útoku DOS.</span><span class="sxs-lookup"><span data-stu-id="bb55a-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="bb55a-294">Neprovádějte platformu vyvolání volání `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, a `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="bb55a-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="bb55a-295">Nepoužívejte NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="bb55a-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="bb55a-296">Identifikujte všechny STA – závislé funkce.</span><span class="sxs-lookup"><span data-stu-id="bb55a-296">Identify Any STA-Dependent Features.</span></span>

<span data-ttu-id="bb55a-297">Identifikujte veškerý kód, který používá jednovláknový Apartment modelu COM (STAs).</span><span class="sxs-lookup"><span data-stu-id="bb55a-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="bb55a-298">V procesu serveru SQL Server jsou zakázány STAs.</span><span class="sxs-lookup"><span data-stu-id="bb55a-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="bb55a-299">Funkce, které závisí na `CoInitialize`, jako jsou čítače výkonu nebo do schránky, musí se zakázat v rámci SQL serveru.</span><span class="sxs-lookup"><span data-stu-id="bb55a-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="bb55a-300">Ujistěte se, že finalizační metody jsou zdarma potíže se synchronizací</span><span class="sxs-lookup"><span data-stu-id="bb55a-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>

<span data-ttu-id="bb55a-301">Více vláken finalizační metodu může existovat v budoucích verzích rozhraní .NET Framework, což znamená finalizační metody pro různé instance stejného typu běžet současně.</span><span class="sxs-lookup"><span data-stu-id="bb55a-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="bb55a-302">Nemají být zcela bezpečné; uvolňování zaručuje, že se spustí pouze jedno vlákno finalizační metodu pro daný objekt instance.</span><span class="sxs-lookup"><span data-stu-id="bb55a-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="bb55a-303">Ale finalizační metody musí být naprogramovány tak, aby nedošlo ke konfliktům časování a zablokování při spuštění současně na více instancí jiný objekt.</span><span class="sxs-lookup"><span data-stu-id="bb55a-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="bb55a-304">Při použití jakékoli externího stavu, jako je například zápis do souboru protokolu v finalizační metodu, potíže s vlákny musí být zpracován.</span><span class="sxs-lookup"><span data-stu-id="bb55a-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="bb55a-305">Nespoléhejte na dokončení zajistit bezpečný přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="bb55a-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="bb55a-306">Úložiště thread local, spravované nebo nativní, nepoužívejte k uložení stavu na finalizační podproces.</span><span class="sxs-lookup"><span data-stu-id="bb55a-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-307">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-307">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-308">Finalizační metody musí být bez potíže se synchronizací.</span><span class="sxs-lookup"><span data-stu-id="bb55a-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="bb55a-309">Nepoužívat statické proměnlivý stav v finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-309">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="bb55a-310">Pokud je to možné vyhnout nespravované paměti</span><span class="sxs-lookup"><span data-stu-id="bb55a-310">Avoid Unmanaged Memory If Possible</span></span>

<span data-ttu-id="bb55a-311">Nespravované paměti může uniknout stejně jako popisovač operačního systému.</span><span class="sxs-lookup"><span data-stu-id="bb55a-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="bb55a-312">Pokud je to možné, zkuste použít paměti na zásobníku pomocí [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) nebo připojených spravovaný objekt, jako [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) nebo <xref:System.Runtime.InteropServices.GCHandle> pomocí byte [].</span><span class="sxs-lookup"><span data-stu-id="bb55a-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="bb55a-313"><xref:System.GC> Nakonec tyto vyčistí.</span><span class="sxs-lookup"><span data-stu-id="bb55a-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="bb55a-314">Pokud však je třeba přiřadit nespravovanou paměť, zvažte použití třídy, která je odvozena z <xref:System.Runtime.InteropServices.SafeHandle> zabalit přidělení paměti.</span><span class="sxs-lookup"><span data-stu-id="bb55a-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="bb55a-315">Všimněte si, že aspoň jeden případ kde <xref:System.Runtime.InteropServices.SafeHandle> není dostatečný.</span><span class="sxs-lookup"><span data-stu-id="bb55a-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="bb55a-316">Pro volání metody COM, které přidělit nebo uvolnit paměť, je běžné, že jedna knihovna DLL pro přidělení paměti prostřednictvím `CoTaskMemAlloc` pak jiné knihovně DLL se uvolní, tato paměť se `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="bb55a-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="bb55a-317">Pomocí <xref:System.Runtime.InteropServices.SafeHandle> v těchto umístěních by nevhodný vzhledem k tomu, že se pokusí spojit životnost nespravované paměti k době života <xref:System.Runtime.InteropServices.SafeHandle> namísto povolení druhý ovládací prvek knihovna DLL životnost paměť.</span><span class="sxs-lookup"><span data-stu-id="bb55a-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="bb55a-318">Zkontrolujte všechna použití Catch(Exception)</span><span class="sxs-lookup"><span data-stu-id="bb55a-318">Review All Uses of Catch(Exception)</span></span>

<span data-ttu-id="bb55a-319">Bloky catch, všechny výjimky namísto jedné určité výjimky se teď catch asynchronní výjimky a catch.</span><span class="sxs-lookup"><span data-stu-id="bb55a-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="bb55a-320">Zkontrolujte každý blok catch(Exception), hledá žádné důležité prostředků uvolnění nebo obnovení kód, který se možná přeskočí, a také potenciálně nesprávné chování v rámci bloku catch pro manipulaci <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, nebo <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="bb55a-321">Všimněte si, že je možné tento kód může protokolování nebo provádění některých předpokladů, že ho může zobrazit pouze určité výjimky, nebo že pokaždé, když dochází k výjimce se nepodařilo pro právě jeden konkrétní důvod.</span><span class="sxs-lookup"><span data-stu-id="bb55a-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="bb55a-322">Možná bude nutné aktualizovat tak, aby zahrnují tyto předpoklady <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="bb55a-323">Vezměte v úvahu všechny změny umístí tento catch, všechny výjimky k zachytávaní konkrétní typ výjimky, které očekáváte, že budou vyvolány, například <xref:System.FormatException> z řetězce formátování metod.</span><span class="sxs-lookup"><span data-stu-id="bb55a-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="bb55a-324">To zabrání spuštění na neočekávané výjimky bloku catch a vám pomůže zajistit, že kód neskrývá pomocí zachycování výjimek neočekávané chyby.</span><span class="sxs-lookup"><span data-stu-id="bb55a-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="bb55a-325">Obecně nikdy zpracování výjimky v kódu knihovny (kód, který vyžaduje, abyste zachytit výjimku může znamenat chybu návrhu v kódu jsou volání).</span><span class="sxs-lookup"><span data-stu-id="bb55a-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="bb55a-326">V některých případech můžete chtít zachytit výjimku a vyvolat jiný typ výjimky poskytující další data.</span><span class="sxs-lookup"><span data-stu-id="bb55a-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="bb55a-327">Použití vnořené výjimky v tomto případě ukládání skutečné příčinu selhání v <xref:System.Exception.InnerException%2A> vlastnost novou výjimku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-328">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-328">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-329">Zkontrolujte všechny bloky catch ve spravovaném kódu tohoto catch všechny objekty nebo catch, všechny výjimky.</span><span class="sxs-lookup"><span data-stu-id="bb55a-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="bb55a-330">V C#, to znamená, že obě nastavení příznaku `catch` {} a `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="bb55a-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="bb55a-331">Zvažte učinění velmi specifický typ výjimky nebo podívejte do kódu a ujistěte se, že nepostupuje chybný způsobem, je-li zachycena typu došlo k neočekávané výjimce.</span><span class="sxs-lookup"><span data-stu-id="bb55a-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="bb55a-332">Nepředpokládejte spravované vlákno je vlákno Win32 – je vlákno</span><span class="sxs-lookup"><span data-stu-id="bb55a-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>

<span data-ttu-id="bb55a-333">Pomocí spravovaného vlákna místní úložiště funguje, ale nemusí používat místní úložiště nespravovaného vlákna nebo se předpokládá, že kód poběží v aktuálním vlákně operačního systému znovu.</span><span class="sxs-lookup"><span data-stu-id="bb55a-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="bb55a-334">Neměňte nastavení, jako je národní prostředí vlákna.</span><span class="sxs-lookup"><span data-stu-id="bb55a-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="bb55a-335">Nevolejte `InitializeCriticalSection` nebo `CreateMutex` prostřednictvím platformy vyvolat, protože vyžadují vláknu operačního systému, který zadá zámek také ukončení uzamčení.</span><span class="sxs-lookup"><span data-stu-id="bb55a-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="bb55a-336">Vzhledem k tomu, že to nebude tak při použití vlákének, kritické oddíly Win32 a vzájemně vyloučené přístupy nelze použít v SQL přímo.</span><span class="sxs-lookup"><span data-stu-id="bb55a-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="bb55a-337">Všimněte si, že spravovanou <xref:System.Threading.Mutex> třídy nezpracovává těchto úkonů spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="bb55a-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="bb55a-338">Lze bezpečně použít i většinu stavu na spravované <xref:System.Threading.Thread> objektu, včetně místním úložišti spravované vlákno a vlákna aktuální jazykové verze uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="bb55a-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="bb55a-339">Můžete také použít <xref:System.ThreadStaticAttribute>, který zpřístupňuje hodnotu existující proměnné statické určená jenom pro aktuální vlákno spravovaná (to je další způsob provedení místní úložiště vlákna v modulu CLR).</span><span class="sxs-lookup"><span data-stu-id="bb55a-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="bb55a-340">Pro programovací model důvody, nelze změnit aktuální jazykové verze vlákna při spuštění v SQL.</span><span class="sxs-lookup"><span data-stu-id="bb55a-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-341">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-341">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-342">SQL Server běží v režimu vlákének; Nepoužívejte úložiště thread local.</span><span class="sxs-lookup"><span data-stu-id="bb55a-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="bb55a-343">Vyhněte se platformu vyvolání volání `TlsAlloc`, `TlsFree`, `TlsGetValue`, a `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="bb55a-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="bb55a-344">Let SQL Server Handle Impersonation</span><span class="sxs-lookup"><span data-stu-id="bb55a-344">Let SQL Server Handle Impersonation</span></span>

<span data-ttu-id="bb55a-345">Protože zosobnění funguje na úrovni vlákna a SQL můžete spustit v režimu vlákének, spravovaný kód nesmí vydávat za uživatele a neměl volat `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="bb55a-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-346">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-346">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-347">Umožní zpracování zosobnění systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bb55a-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="bb55a-348">Nepoužívejte `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, nebo `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="bb55a-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="bb55a-349">Nevolejte Thread::Suspend</span><span class="sxs-lookup"><span data-stu-id="bb55a-349">Do Not Call Thread::Suspend</span></span>

<span data-ttu-id="bb55a-350">Možnost pozastavovat vlákno zdánlivě jednoduché operace, ale může to způsobit zablokování.</span><span class="sxs-lookup"><span data-stu-id="bb55a-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="bb55a-351">Pokud vlákno obsahující že zámek pozastaven vláknem, a pak druhého podprocesu pokusí trvá stejné zámek, dojde k zablokování.</span><span class="sxs-lookup"><span data-stu-id="bb55a-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="bb55a-352"><xref:System.Threading.Thread.Suspend%2A> může vést k potížím se zabezpečením, načtení třídy, vzdálené komunikace a reflexe aktuálně.</span><span class="sxs-lookup"><span data-stu-id="bb55a-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="bb55a-353">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="bb55a-353">Code Analysis Rule</span></span>

<span data-ttu-id="bb55a-354">Nevolejte <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="bb55a-355">Zvažte použití skutečné synchronizace primitivní místo toho, pokud například <xref:System.Threading.Semaphore> nebo <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="bb55a-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="bb55a-356">Ochrana důležitých operací s oblasti omezeného provádění a kontrakty spolehlivosti</span><span class="sxs-lookup"><span data-stu-id="bb55a-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>

<span data-ttu-id="bb55a-357">Při provádění složitá operace, která aktualizuje stav sdílení nebo, který potřebuje nedeterministicky buď zcela úspěšná nebo plně selhávat, ujistěte se, že je chráněn oblasti omezeného provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="bb55a-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="bb55a-358">Zaručí se tak, že kód se spustí ve všech případech i přerušení náhlé vlákna nebo náhlému <xref:System.AppDomain> uvolnit.</span><span class="sxs-lookup"><span data-stu-id="bb55a-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="bb55a-359">CER je konkrétní `try/finally` bloku bezprostředně před volání <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb55a-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="bb55a-360">To uděláte tak instruuje kompilátor just-in-time Příprava veškerý kód v blok finally dřív, než spustíte `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="bb55a-361">To zaručuje, že kód nakonec bloku je sestaven a spustí se ve všech případech.</span><span class="sxs-lookup"><span data-stu-id="bb55a-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="bb55a-362">Není, v CER mít prázdnou `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="bb55a-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="bb55a-363">Použití CER chrání proti asynchronní vlákno přeruší a výjimky na více instancí z důvodu nedostatku paměti.</span><span class="sxs-lookup"><span data-stu-id="bb55a-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="bb55a-364">Zobrazit <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> pro určitou formu CER, která kromě přetečení zásobníku obslužné rutiny pro mimořádně hloubkové kód.</span><span class="sxs-lookup"><span data-stu-id="bb55a-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="bb55a-365">Viz také:</span><span class="sxs-lookup"><span data-stu-id="bb55a-365">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="bb55a-366">Programování serveru SQL Server a atributy ochrany hostitele</span><span class="sxs-lookup"><span data-stu-id="bb55a-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)
