---
title: Opožděná inicializace
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ce217e2ed8e542ad0f7122970655aa32a353f51a
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/18/2019
ms.locfileid: "59182296"
---
# <a name="lazy-initialization"></a><span data-ttu-id="c593c-102">Opožděná inicializace</span><span class="sxs-lookup"><span data-stu-id="c593c-102">Lazy Initialization</span></span>
<span data-ttu-id="c593c-103">*Opožděná inicializace* objektu znamená, že jeho vytvoření je odloženo, dokud je poprvé použita.</span><span class="sxs-lookup"><span data-stu-id="c593c-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="c593c-104">(Pro toto téma podmínky *opožděné inicializace* a *opožděné instance* jsou shodné.) Opožděná inicializace slouží především ke zvýšení výkonu, zabránit plýtvání výpočtu a snížit požadavky na paměť pro program.</span><span class="sxs-lookup"><span data-stu-id="c593c-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="c593c-105">Jedná se o nejběžnějších scénářů:</span><span class="sxs-lookup"><span data-stu-id="c593c-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="c593c-106">Pokud máte objekt, který je nákladné a nemusí použít program.</span><span class="sxs-lookup"><span data-stu-id="c593c-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="c593c-107">Předpokládejme například, že máte v paměti `Customer` objekt, který má `Orders` vlastnost, která obsahuje velké pole `Order` objekty, které mají být inicializovány, vyžaduje připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="c593c-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="c593c-108">Pokud uživatel požádá nikdy zobrazujících objednávky nebo použít data ve výpočtu, neexistuje žádný důvod k jeho vytvoření použít systémové paměti nebo výpočetních cyklů.</span><span class="sxs-lookup"><span data-stu-id="c593c-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="c593c-109">S použitím `Lazy<Orders>` pro deklaraci `Orders` objektu pro opožděnou inicializaci, pokud není používán objekt se můžete vyhnout plýtvání systémových prostředků.</span><span class="sxs-lookup"><span data-stu-id="c593c-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="c593c-110">Pokud máte objekt, který je nákladné a chcete odložit jeho vytvoření až po dokončili další nákladný provoz.</span><span class="sxs-lookup"><span data-stu-id="c593c-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="c593c-111">Předpokládejme například, že váš program načte několik instancí objektů při spuštění, ale jenom některé z nich je nutné okamžitě.</span><span class="sxs-lookup"><span data-stu-id="c593c-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="c593c-112">Odložené inicializace objektů, které nejsou povinné, dokud vytvořili požadované objekty, lze vylepšit výkon při spuštění programu.</span><span class="sxs-lookup"><span data-stu-id="c593c-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="c593c-113">I když můžete napsat vlastní kód pro provádění opožděné inicializace, doporučujeme použít <xref:System.Lazy%601> místo.</span><span class="sxs-lookup"><span data-stu-id="c593c-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="c593c-114"><xref:System.Lazy%601> a jeho souvisejících typů také podporuje bezpečnost vláken a poskytnout zásady šíření výjimky konzistentní vzhledem k aplikacím.</span><span class="sxs-lookup"><span data-stu-id="c593c-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="c593c-115">Následující tabulka uvádí typy opožděná inicializace v různých scénářích povolit poskytuje rozhraní .NET Framework verze 4.</span><span class="sxs-lookup"><span data-stu-id="c593c-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="c593c-116">Type</span><span class="sxs-lookup"><span data-stu-id="c593c-116">Type</span></span>|<span data-ttu-id="c593c-117">Popis</span><span class="sxs-lookup"><span data-stu-id="c593c-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="c593c-118">Obálkovou třídu, která poskytuje sémantiku opožděné inicializace pro všechny knihovny tříd nebo typ definovaný uživatelem.</span><span class="sxs-lookup"><span data-stu-id="c593c-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="c593c-119">Se podobá <xref:System.Lazy%601> s tím rozdílem, že poskytuje sémantiku opožděné inicializace na základě místního vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="c593c-120">Každé vlákno má přístup k vlastní jedinečnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c593c-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="c593c-121">Poskytuje pokročilé `static` (`Shared` v jazyce Visual Basic) metody pro opožděné inicializace objektů bez režie třídy.</span><span class="sxs-lookup"><span data-stu-id="c593c-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="c593c-122">Základní opožděná inicializace</span><span class="sxs-lookup"><span data-stu-id="c593c-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="c593c-123">Chcete-li definovat opožděně inicializované typu, například `MyType`, použijte `Lazy<MyType>` (`Lazy(Of MyType)` v jazyce Visual Basic), jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="c593c-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="c593c-124">Pokud není předán žádný delegáta v <xref:System.Lazy%601> konstruktoru, zabalený typ, který je vytvořen pomocí <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> při prvním přístupu vlastnost value.</span><span class="sxs-lookup"><span data-stu-id="c593c-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="c593c-125">Pokud typ nemá výchozí konstruktor, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="c593c-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="c593c-126">V následujícím příkladu se předpokládá, že `Orders` je třída, která obsahuje pole `Order` objekty načteny z databáze.</span><span class="sxs-lookup"><span data-stu-id="c593c-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="c593c-127">A `Customer` objekt obsahuje instanci `Orders`, ale v závislosti na akce uživatelů, dat z `Orders` objektu nemusí být nutná.</span><span class="sxs-lookup"><span data-stu-id="c593c-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="c593c-128">Můžete také předat delegáta v <xref:System.Lazy%601> konstruktor, který vyvolá konkrétního konstruktoru přetížení na zabalený typ, který v okamžiku vytvoření a provedení dalších kroků inicializace, které jsou požadovány, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="c593c-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="c593c-129">Po vytvoření objektu opožděné žádná instance `Orders` se vytvoří až <xref:System.Lazy%601.Value%2A> poprvé získat přístup k vlastnosti opožděné proměnné.</span><span class="sxs-lookup"><span data-stu-id="c593c-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="c593c-130">Na první přístup je zabalený typ, který vytvoří a vrátí a uložené pro jakýkoli budoucí přístup.</span><span class="sxs-lookup"><span data-stu-id="c593c-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="c593c-131">A <xref:System.Lazy%601> objekt vždy vrátí na stejný objekt nebo hodnotu, která nebyla inicializována.</span><span class="sxs-lookup"><span data-stu-id="c593c-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="c593c-132">Proto <xref:System.Lazy%601.Value%2A> vlastnost je jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="c593c-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="c593c-133">Pokud <xref:System.Lazy%601.Value%2A> zadejte úložiště odkaz nelze přiřadit nový objekt k němu.</span><span class="sxs-lookup"><span data-stu-id="c593c-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="c593c-134">(Můžete ale změnit hodnotu nastavitelné veřejné polí a vlastností.) Pokud <xref:System.Lazy%601.Value%2A> ukládá hodnotu typu, nelze změnit jeho hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c593c-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="c593c-135">Můžete však vytvořit novou proměnnou vyvoláním konstruktoru proměnné znovu pomocí nové argumenty.</span><span class="sxs-lookup"><span data-stu-id="c593c-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="c593c-136">Novou instanci opožděné, jako je ta starší nevytvoří instanci `Orders` až do jeho <xref:System.Lazy%601.Value%2A> vlastnost je nejprve otevřen.</span><span class="sxs-lookup"><span data-stu-id="c593c-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="c593c-137">Inicializace bezpečná pro vlákno</span><span class="sxs-lookup"><span data-stu-id="c593c-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="c593c-138">Ve výchozím nastavení <xref:System.Lazy%601> objekty jsou vláknově bezpečné.</span><span class="sxs-lookup"><span data-stu-id="c593c-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="c593c-139">To znamená, pokud konstruktor neurčuje druh bezpečný přístup z více vláken <xref:System.Lazy%601> vytvoří objekty jsou vláknově bezpečné.</span><span class="sxs-lookup"><span data-stu-id="c593c-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="c593c-140">Ve scénářích s více procesy, první vlákno pro přístup k <xref:System.Lazy%601.Value%2A> vlastnost vláknově bezpečné <xref:System.Lazy%601> objektu inicializuje ji pro všechny další přístupy na všech vláknech a všechna vlákna sdílet stejná data.</span><span class="sxs-lookup"><span data-stu-id="c593c-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="c593c-141">Proto není důležité, které vlákno inicializuje objekt a konflikty časování je neškodný.</span><span class="sxs-lookup"><span data-stu-id="c593c-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c593c-142">Taková konzistence pro chybové podmínky můžete rozšířit pomocí ukládání do mezipaměti výjimky.</span><span class="sxs-lookup"><span data-stu-id="c593c-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="c593c-143">Další informace naleznete v části Další [výjimky v opožděné objekty](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="c593c-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="c593c-144">Následující příklad ukazuje, že stejné `Lazy<int>` instance má stejnou hodnotu pro tři samostatné vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="c593c-145">Pokud budete potřebovat samostatné dat v každém vláknu, použijte <xref:System.Threading.ThreadLocal%601> zadejte, jak je popsáno dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="c593c-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="c593c-146">Některé <xref:System.Lazy%601> konstruktory nemají logickým parametrem s názvem `isThreadSafe` , který se používá k určení, zda <xref:System.Lazy%601.Value%2A> vlastnost budou mít přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="c593c-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="c593c-147">Pokud chcete získat přístup k vlastnosti z právě jedno vlákno, předejte `false` získat mírné zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="c593c-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="c593c-148">Pokud chcete získat přístup k vlastnosti z více vláken, předejte `true` dáte pokyn, aby <xref:System.Lazy%601> instance správně zpracovat časování, ve kterých jedno vlákno vyvolá výjimku během inicializace.</span><span class="sxs-lookup"><span data-stu-id="c593c-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="c593c-149">Některé <xref:System.Lazy%601> mají konstruktory <xref:System.Threading.LazyThreadSafetyMode> parametr s názvem `mode`.</span><span class="sxs-lookup"><span data-stu-id="c593c-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="c593c-150">Tyto konstruktory zadat režim zabezpečení další vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="c593c-151">Následující tabulka ukazuje, jak bezpečnost vlákna <xref:System.Lazy%601> je objekt ovlivněn parametry konstruktoru, které určují bezpečný přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="c593c-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="c593c-152">Každý konstruktor má nejvýše jeden takový parametr.</span><span class="sxs-lookup"><span data-stu-id="c593c-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="c593c-153">Zabezpečení vlákna objektu</span><span class="sxs-lookup"><span data-stu-id="c593c-153">Thread safety of the object</span></span>|<span data-ttu-id="c593c-154">`LazyThreadSafetyMode` `mode` Parametr</span><span class="sxs-lookup"><span data-stu-id="c593c-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="c593c-155">Logická `isThreadSafe` parametr</span><span class="sxs-lookup"><span data-stu-id="c593c-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="c593c-156">Žádné parametry bezpečný přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="c593c-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="c593c-157">Plně bezpečné pro vlákna; pouze jedno vlákno současně pokusí o inicializaci hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c593c-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="c593c-158">Ano.</span><span class="sxs-lookup"><span data-stu-id="c593c-158">Yes.</span></span>|  
|<span data-ttu-id="c593c-159">Není bezpečné pro vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="c593c-160">Není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="c593c-160">Not applicable.</span></span>|  
|<span data-ttu-id="c593c-161">Plně bezpečné pro vlákna; závod vláken k inicializaci hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c593c-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="c593c-162">Není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="c593c-162">Not applicable.</span></span>|<span data-ttu-id="c593c-163">Není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="c593c-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="c593c-164">Jak je zobrazeno v tabulce, určení <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> pro `mode` parametr je stejné jako zadání `true` pro `isThreadSafe` parametru a zadáním <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> je stejné jako zadání `false`.</span><span class="sxs-lookup"><span data-stu-id="c593c-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="c593c-165">Určení <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> umožňuje více vláken, k pokusu o inicializaci <xref:System.Lazy%601> instance.</span><span class="sxs-lookup"><span data-stu-id="c593c-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="c593c-166">Pouze jedno vlákno může tento závod vyhrát a všechny ostatní vlákna zobrazí hodnotu, která byla inicializována úspěšné vláknem.</span><span class="sxs-lookup"><span data-stu-id="c593c-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="c593c-167">Pokud během inicializace je vyvolána výjimka ve vlákně, bylo vlákno nezíská hodnoty nastavené v úspěšné vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="c593c-168">Výjimky nejsou uložené v mezipaměti, takže další pokus o přístup <xref:System.Lazy%601.Value%2A> vlastnost může mít za následek úspěšné inicializace.</span><span class="sxs-lookup"><span data-stu-id="c593c-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="c593c-169">Tím se liší od způsob, jakým výjimky jsou považovány v ostatních režimech, která je popsána v následující části.</span><span class="sxs-lookup"><span data-stu-id="c593c-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="c593c-170">Další informace najdete v tématu <xref:System.Threading.LazyThreadSafetyMode> výčtu.</span><span class="sxs-lookup"><span data-stu-id="c593c-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="c593c-171">Výjimky v opožděné objekty</span><span class="sxs-lookup"><span data-stu-id="c593c-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="c593c-172">Jak bylo uvedeno dříve, <xref:System.Lazy%601> objekt vždy vrátí na stejný objekt nebo hodnotu, která byla inicializována, a proto <xref:System.Lazy%601.Value%2A> vlastnost je jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="c593c-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="c593c-173">Pokud povolíte ukládání do mezipaměti výjimku, tato neměnnosti také rozšiřuje výjimky chování.</span><span class="sxs-lookup"><span data-stu-id="c593c-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="c593c-174">Pokud je objekt opožděně inicializované výjimka povoleno ukládání do mezipaměti a vyvolá výjimku z jeho inicializační metoda při <xref:System.Lazy%601.Value%2A> vlastnost je nejprve otevřen, že stejná výjimka je vyvolána na všechny následné pokusy o přístup k <xref:System.Lazy%601.Value%2A> vlastnost .</span><span class="sxs-lookup"><span data-stu-id="c593c-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="c593c-175">Jinými slovy konstruktor zabalený typ, který se nikdy znovu vyvolána, dokonce i ve scénářích s více vlákny.</span><span class="sxs-lookup"><span data-stu-id="c593c-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="c593c-176">Proto <xref:System.Lazy%601> objekt nelze vyvolat výjimku na jeden přístup a všechny další přístupy nevrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c593c-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="c593c-177">Ukládání do mezipaměti výjimka je povolená, když použijete některou <xref:System.Lazy%601?displayProperty=nameWithType> konstruktor, který přijímá metodu inicializace (`valueFactory` parametr); například je povolená, když použijete `Lazy(T)(Func(T))`konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="c593c-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="c593c-178">Pokud konstruktor také přijímá <xref:System.Threading.LazyThreadSafetyMode> hodnotu (`mode` parametr), zadejte <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> nebo <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c593c-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c593c-179">Určení inicializační metoda umožňuje ukládání do mezipaměti výjimky pro tyto dva režimy.</span><span class="sxs-lookup"><span data-stu-id="c593c-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="c593c-180">Inicializační metoda může být velmi jednoduché.</span><span class="sxs-lookup"><span data-stu-id="c593c-180">The initialization method can be very simple.</span></span> <span data-ttu-id="c593c-181">Například může volat výchozí konstruktor pro `T`: `new Lazy<Contents>(() => new Contents(), mode)` v jazyce C#, nebo `New Lazy(Of Contents)(Function() New Contents())` v jazyce Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="c593c-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="c593c-182">Pokud používáte <xref:System.Lazy%601?displayProperty=nameWithType> konstruktor, který neurčuje metodu inicializace, výjimky, které jsou vyvolány výchozí konstruktor pro `T` nejsou uložené v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="c593c-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="c593c-183">Další informace najdete v tématu <xref:System.Threading.LazyThreadSafetyMode> výčtu.</span><span class="sxs-lookup"><span data-stu-id="c593c-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c593c-184">Pokud vytvoříte <xref:System.Lazy%601> objekt s `isThreadSafe` konstruktor parametrem nastaveným na `false` nebo `mode` konstruktor parametrem nastaveným na <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, musí přejít <xref:System.Lazy%601> objektu z jednoho vlákna nebo zadat vlastní synchronizace.</span><span class="sxs-lookup"><span data-stu-id="c593c-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="c593c-185">To platí pro všechny aspekty objektu, včetně výjimek, ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="c593c-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="c593c-186">Jak je uvedeno v předchozí části, <xref:System.Lazy%601> objekty vytvořené tak, že zadáte <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> zpracovávat výjimky odlišně.</span><span class="sxs-lookup"><span data-stu-id="c593c-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="c593c-187">S <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, více vláken se mohou utkat inicializovat <xref:System.Lazy%601> instance.</span><span class="sxs-lookup"><span data-stu-id="c593c-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="c593c-188">V takovém případě výjimky nejsou uložené v mezipaměti a pokusí o přístup k <xref:System.Lazy%601.Value%2A> vlastnost může pokračovat, dokud nebude úspěšné inicializace.</span><span class="sxs-lookup"><span data-stu-id="c593c-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="c593c-189">Následující tabulka shrnuje způsob, jakým <xref:System.Lazy%601> řízení konstruktorů výjimek ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="c593c-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="c593c-190">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="c593c-190">Constructor</span></span>|<span data-ttu-id="c593c-191">Režim zabezpečení vlákna</span><span class="sxs-lookup"><span data-stu-id="c593c-191">Thread safety mode</span></span>|<span data-ttu-id="c593c-192">Používá metodu inicializace</span><span class="sxs-lookup"><span data-stu-id="c593c-192">Uses initialization method</span></span>|<span data-ttu-id="c593c-193">Výjimky jsou uložené v mezipaměti</span><span class="sxs-lookup"><span data-stu-id="c593c-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="c593c-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="c593c-194">Lazy(T)()</span></span>|<span data-ttu-id="c593c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="c593c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="c593c-196">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-196">No</span></span>|<span data-ttu-id="c593c-197">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-197">No</span></span>|  
|<span data-ttu-id="c593c-198">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="c593c-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="c593c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="c593c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="c593c-200">Ano</span><span class="sxs-lookup"><span data-stu-id="c593c-200">Yes</span></span>|<span data-ttu-id="c593c-201">Ano</span><span class="sxs-lookup"><span data-stu-id="c593c-201">Yes</span></span>|  
|<span data-ttu-id="c593c-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="c593c-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="c593c-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) nebo `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="c593c-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="c593c-204">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-204">No</span></span>|<span data-ttu-id="c593c-205">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-205">No</span></span>|  
|<span data-ttu-id="c593c-206">Lazy(T)(Func(T), logická hodnota)</span><span class="sxs-lookup"><span data-stu-id="c593c-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="c593c-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) nebo `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="c593c-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="c593c-208">Ano</span><span class="sxs-lookup"><span data-stu-id="c593c-208">Yes</span></span>|<span data-ttu-id="c593c-209">Ano</span><span class="sxs-lookup"><span data-stu-id="c593c-209">Yes</span></span>|  
|<span data-ttu-id="c593c-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="c593c-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="c593c-211">Zadané uživatelem</span><span class="sxs-lookup"><span data-stu-id="c593c-211">User-specified</span></span>|<span data-ttu-id="c593c-212">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-212">No</span></span>|<span data-ttu-id="c593c-213">Ne</span><span class="sxs-lookup"><span data-stu-id="c593c-213">No</span></span>|  
|<span data-ttu-id="c593c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="c593c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="c593c-215">Zadané uživatelem</span><span class="sxs-lookup"><span data-stu-id="c593c-215">User-specified</span></span>|<span data-ttu-id="c593c-216">Ano</span><span class="sxs-lookup"><span data-stu-id="c593c-216">Yes</span></span>|<span data-ttu-id="c593c-217">Ne, pokud uživatel zadá <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; jinak vrátí hodnotu, Ano.</span><span class="sxs-lookup"><span data-stu-id="c593c-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="c593c-218">Implementace opožděně inicializované vlastnosti</span><span class="sxs-lookup"><span data-stu-id="c593c-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="c593c-219">Chcete-li implementovat veřejné vlastnosti pomocí opožděné inicializace, definujte pomocným polem vlastnosti jako datový typ <xref:System.Lazy%601>a vraťte se <xref:System.Lazy%601.Value%2A> vlastnost z `get` přistupujícího objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c593c-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="c593c-220"><xref:System.Lazy%601.Value%2A> Vlastnost je jen pro čtení; proto vlastnost, která zpřístupní ho nemá žádné `set` přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="c593c-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="c593c-221">Pokud vyžadujete, aby se opírá o vlastnost pro čtení a zápis <xref:System.Lazy%601> objektu, `set` přístupového objektu musíte vytvořit nový <xref:System.Lazy%601> objekt a přiřaďte ho ke záložního úložiště.</span><span class="sxs-lookup"><span data-stu-id="c593c-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="c593c-222">`set` Přístupového objektu musíte vytvořit výraz lambda, který vrátí hodnotu, která byla předána hodnota nové vlastnosti `set` přístupový objekt a předat tento výraz lambda konstruktoru pro novou <xref:System.Lazy%601> objektu.</span><span class="sxs-lookup"><span data-stu-id="c593c-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="c593c-223">Další přístup <xref:System.Lazy%601.Value%2A> způsobí, že vlastnost inicializace nového <xref:System.Lazy%601>a jeho <xref:System.Lazy%601.Value%2A> vlastnost poté vrátí novou hodnotu, která byla přiřazena k vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c593c-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="c593c-224">Důvod pro toto uspořádání složitými je zachovat multithreading ochrany, které jsou součástí <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c593c-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="c593c-225">V opačném případě by mít přistupující objekty vlastnosti pro ukládání do mezipaměti první hodnoty vrácené <xref:System.Lazy%601.Value%2A> vlastnost a měnit pouze hodnotu uloženou v mezipaměti a byste museli napsat vlastní kód bezpečným pro vlákno, které provedete.</span><span class="sxs-lookup"><span data-stu-id="c593c-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="c593c-226">Kvůli další inicializace, vyžaduje se opírá o vlastnost pro čtení a zápis <xref:System.Lazy%601> objektu, nemusí být přijatelný výkon.</span><span class="sxs-lookup"><span data-stu-id="c593c-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="c593c-227">V závislosti na konkrétním scénáři může být další koordinace navíc vyžadováno nedošlo ke konfliktům časování mezi setter a metody getter.</span><span class="sxs-lookup"><span data-stu-id="c593c-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="c593c-228">Thread-Local opožděná inicializace</span><span class="sxs-lookup"><span data-stu-id="c593c-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="c593c-229">V některých scénářích s více vlákny můžete chtít poskytnout vlastní privátní data každé vlákno.</span><span class="sxs-lookup"><span data-stu-id="c593c-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="c593c-230">Tato data se nazývají *dat thread local*.</span><span class="sxs-lookup"><span data-stu-id="c593c-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="c593c-231">V rozhraní .NET Framework verze 3.5 a starších, můžete použít `ThreadStatic` atribut statickou proměnnou, která usnadňují místního vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="c593c-232">Avšak použití `ThreadStatic` atribut může vést k drobným chybám.</span><span class="sxs-lookup"><span data-stu-id="c593c-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="c593c-233">Například příkazy i základní inicializace způsobí, že proměnné mají být inicializovány pouze na první vlákno, k přístupu, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="c593c-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="c593c-234">V jiných vláknech proměnná bude inicializován pomocí jeho výchozí hodnota (nula).</span><span class="sxs-lookup"><span data-stu-id="c593c-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="c593c-235">Jako alternativu v rozhraní .NET Framework verze 4, můžete použít <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> vytvořit proměnnou založený na instancích, místního vlákna, který je inicializován na všech vláknech podle <xref:System.Action%601> delegáta, který zadáte.</span><span class="sxs-lookup"><span data-stu-id="c593c-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="c593c-236">V následujícím příkladu, všechna vlákna, která přístup `counter` se zobrazí její výchozí hodnotu 1.</span><span class="sxs-lookup"><span data-stu-id="c593c-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="c593c-237"><xref:System.Threading.ThreadLocal%601> zabalí jeho objekt stejným způsobem jako <xref:System.Lazy%601>, s následujícími základní rozdíly:</span><span class="sxs-lookup"><span data-stu-id="c593c-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="c593c-238">Každé vlákno inicializuje proměnná místního vlákna pomocí jeho vlastní privátní data, která nejsou přístupné z jiných vláken.</span><span class="sxs-lookup"><span data-stu-id="c593c-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="c593c-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> Vlastnost pro čtení i zápis a je možné upravit libovolný počet.</span><span class="sxs-lookup"><span data-stu-id="c593c-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="c593c-240">To může ovlivnit šíření výjimek, například jeden `get` operace může vyvolat výjimku, ale další možné úspěšně inicializovat hodnota.</span><span class="sxs-lookup"><span data-stu-id="c593c-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="c593c-241">Pokud je k dispozici žádná inicializace delegáta, <xref:System.Threading.ThreadLocal%601> inicializovat jeho zabalený typ, který bude použita výchozí hodnota typu.</span><span class="sxs-lookup"><span data-stu-id="c593c-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="c593c-242">V tomto ohledu <xref:System.Threading.ThreadLocal%601> je konzistentní s <xref:System.ThreadStaticAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="c593c-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="c593c-243">Následující příklad ukazuje, že každý podproces, který přistupuje k `ThreadLocal<int>` instance získá svou vlastní jedinečnou kopii data.</span><span class="sxs-lookup"><span data-stu-id="c593c-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="c593c-244">Místní proměnné vlákna smyčky Parallel.For a ForEach</span><span class="sxs-lookup"><span data-stu-id="c593c-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="c593c-245">Při použití <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metoda nebo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metoda k iteraci nad zdroji dat současně, můžete použít přetížení, které mají integrovanou podporu pro místní data.</span><span class="sxs-lookup"><span data-stu-id="c593c-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="c593c-246">V těchto metodách umístění vlákna můžete dosáhnout použitím místní delegáti vytvořit, přístup a vyčistit data.</span><span class="sxs-lookup"><span data-stu-id="c593c-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="c593c-247">Další informace najdete v tématu [jak: Zápis smyčky Parallel.for pomocí proměnných v místním vláknu](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) a [jak: Zápis smyčky Parallel.ForEach pomocí proměnných v místním oddílu](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="c593c-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="c593c-248">Pomocí opožděné inicializace pro scénáře s nízkou režií</span><span class="sxs-lookup"><span data-stu-id="c593c-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="c593c-249">V situacích, kdy musíte opožděné inicializace velký počet objektů, můžete se rozhodnout obtékání jednotlivých objektů v <xref:System.Lazy%601> vyžaduje příliš mnoho paměti nebo příliš mnoho výpočetních prostředků.</span><span class="sxs-lookup"><span data-stu-id="c593c-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="c593c-250">Nebo můžete mít přísné požadavky na informace o tom, jak opožděné inicializace je přístupný.</span><span class="sxs-lookup"><span data-stu-id="c593c-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="c593c-251">V takovém případě můžete použít `static` (`Shared` v jazyce Visual Basic) metody <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> opožděné inicializace každý objekt nezabalili v instanci třídy <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c593c-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="c593c-252">V následujícím příkladu se předpokládá, že, namísto obtékání celý `Orders` objekt v jednom <xref:System.Lazy%601> objektu, budete mít jednotlivé opožděně inicializované `Order` pouze objekty, pokud jsou povinné.</span><span class="sxs-lookup"><span data-stu-id="c593c-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="c593c-253">V tomto příkladu Všimněte si, že je vyvolána inicializační proceduru v každé iteraci smyčky.</span><span class="sxs-lookup"><span data-stu-id="c593c-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="c593c-254">Ve scénářích s více procesy první vlákno k vyvolání procedury inicializace je ten, jehož hodnota je vidět všechna vlákna.</span><span class="sxs-lookup"><span data-stu-id="c593c-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="c593c-255">Novější vláken také vyvolat inicializační proceduru, ale nepoužívají se jejich výsledky.</span><span class="sxs-lookup"><span data-stu-id="c593c-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="c593c-256">Pokud tento druh potenciální konflikt časování není přijatelná, použijte přetížení <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> , která přebírá argument typu Boolean a synchronizační objekt.</span><span class="sxs-lookup"><span data-stu-id="c593c-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c593c-257">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c593c-257">See also</span></span>

- [<span data-ttu-id="c593c-258">Základy dělení na spravovaná vlákna</span><span class="sxs-lookup"><span data-stu-id="c593c-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="c593c-259">Vlákna a dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="c593c-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)
- [<span data-ttu-id="c593c-260">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="c593c-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="c593c-261">Postupy: Provádění opožděné inicializace objektů</span><span class="sxs-lookup"><span data-stu-id="c593c-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)
