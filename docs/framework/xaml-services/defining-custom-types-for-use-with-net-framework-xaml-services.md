---
title: Definování vlastních typů pro práci s technologií .NET Framework XAML Services
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/08/2019
ms.locfileid: "59164434"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="c3e21-102">Definování vlastních typů pro práci s technologií .NET Framework XAML Services</span><span class="sxs-lookup"><span data-stu-id="c3e21-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="c3e21-103">Při definování vlastních typů, které jsou pro obchodní objekty nebo jsou typy, které nemají závislost na určité rozhraní, jsou některé osvědčené postupy pro XAML, můžete postupovat podle.</span><span class="sxs-lookup"><span data-stu-id="c3e21-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="c3e21-104">Pokud budete postupovat podle těchto postupů, můžete zjistit vlastnosti XAML stejného typu a přiřaďte jí vhodné vyjádření v datovém proudu uzlu XAML pomocí typu systému XAML rozhraní .NET Framework XAML Services a jeho XAML čtečky a zapisovače XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="c3e21-105">Toto téma popisuje osvědčené postupy pro definice typu, definice členů a zapisujících CLR typy nebo členy.</span><span class="sxs-lookup"><span data-stu-id="c3e21-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="c3e21-106">Zabezpečené vzory konstruktoru a definic typů pro XAML</span><span class="sxs-lookup"><span data-stu-id="c3e21-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="c3e21-107">Má být vytvořena jako element objektu v XAML, vlastní třídy musí splňovat následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="c3e21-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="c3e21-108">Vlastní třída musí být veřejné a musí zveřejnit výchozí veřejný konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="c3e21-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="c3e21-109">(Viz následující části pro poznámky týkající se struktury).</span><span class="sxs-lookup"><span data-stu-id="c3e21-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="c3e21-110">Vlastní třída nesmí být vnořená třída.</span><span class="sxs-lookup"><span data-stu-id="c3e21-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="c3e21-111">Nadbytečné "tečka" v cestě celé jméno díky dělení obor názvů třídy nejednoznačný a naruší to ostatní funkce XAML jako připojené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="c3e21-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="c3e21-112">Pokud objekt může být vytvořen jako element objektu, vytvořený objekt vyplnit formu všechny vlastnosti, které získat objekt jako jeho základní typ vlastnosti elementu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="c3e21-113">Stále můžete zadat objekt hodnoty pro typy, které nesplňují tato kritéria, pokud povolíte převaděč hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c3e21-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="c3e21-114">Další informace najdete v tématu [převaděče typů a rozšíření značek pro XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="c3e21-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="c3e21-115">Structures</span></span>  
 <span data-ttu-id="c3e21-116">Struktury jsou vždycky možné zkonstruovat v XAML, podle definice CLR.</span><span class="sxs-lookup"><span data-stu-id="c3e21-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="c3e21-117">Je to proto, že kompilátor CLR implicitně vytvoří výchozí konstruktor pro struktury.</span><span class="sxs-lookup"><span data-stu-id="c3e21-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="c3e21-118">Tento konstruktor inicializuje všechny hodnoty vlastností, které jejich výchozích hodnotách.</span><span class="sxs-lookup"><span data-stu-id="c3e21-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="c3e21-119">V některých případech není chování výchozí konstrukci pro strukturu žádoucí.</span><span class="sxs-lookup"><span data-stu-id="c3e21-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="c3e21-120">Příčinou může být struktura je určený k vyplnění hodnot a funkce koncepčně jako sjednocení.</span><span class="sxs-lookup"><span data-stu-id="c3e21-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="c3e21-121">Jako sjednocení omezením hodnot může mít vzájemně se vylučující interpretace a proto nejsou žádná z její vlastnosti nastavitelná při čekání.</span><span class="sxs-lookup"><span data-stu-id="c3e21-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="c3e21-122">Je například struktura, ve slovníku WPF <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="c3e21-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="c3e21-123">Tyto struktury by měly implementovat konvertor typu tak, aby hodnot lze vyjádřit do formuláře atributů, pomocí řetězce vytváření názvů, které vytvářejí různé interpretace nebo režimy struktura hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c3e21-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="c3e21-124">Struktury by měly vystavit také podobné chování pro tvorbu kódu prostřednictvím jiného než výchozího konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="c3e21-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="c3e21-125">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="c3e21-125">Interfaces</span></span>  
 <span data-ttu-id="c3e21-126">Rozhraní může sloužit jako základní typy členů.</span><span class="sxs-lookup"><span data-stu-id="c3e21-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="c3e21-127">Systém typů XAML kontroluje seznamu přiřadit a očekává, že objekt, který je uvedený jako hodnota může být přiřazen k rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3e21-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="c3e21-128">Neexistuje žádný koncept jak musí být rozhraní zobrazí jako typ XAML tak dlouho, dokud odpovídající typ přiřaditelný podporuje požadavky dané XAML konstrukce.</span><span class="sxs-lookup"><span data-stu-id="c3e21-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="c3e21-129">Metody pro vytváření objektů</span><span class="sxs-lookup"><span data-stu-id="c3e21-129">Factory Methods</span></span>  
 <span data-ttu-id="c3e21-130">Metody pro vytváření objektů jsou funkce XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="c3e21-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="c3e21-131">Mění se zásadou XAML, že objekty musí mít výchozí konstruktory.</span><span class="sxs-lookup"><span data-stu-id="c3e21-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="c3e21-132">Metody pro vytváření objektů nejsou uvedené v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="c3e21-133">Zobrazit [x: FactoryMethod – direktiva](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="c3e21-134">Výčty</span><span class="sxs-lookup"><span data-stu-id="c3e21-134">Enumerations</span></span>  
 <span data-ttu-id="c3e21-135">Výčty mají XAML nativní typ převodu chování.</span><span class="sxs-lookup"><span data-stu-id="c3e21-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="c3e21-136">Výčet konstantní názvy zadané v XAML jsou vyřešeny před nadřízený typ výčtu a vrátí hodnotu výčtu pro zápis objektu XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="c3e21-137">XAML podporuje použití stylu příznaky pro výčty s <xref:System.FlagsAttribute> použít.</span><span class="sxs-lookup"><span data-stu-id="c3e21-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="c3e21-138">Další informace najdete v tématu [syntaxe XAML v podrobnosti o](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="c3e21-139">([Syntaxe XAML v podrobnosti o](../wpf/advanced/xaml-syntax-in-detail.md) je určené pro cílovou skupinu WPF, ale většina informace v tomto tématu je relevantní pro XAML, která není specifická pro konkrétní implementaci rozhraní.)</span><span class="sxs-lookup"><span data-stu-id="c3e21-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="c3e21-140">Definice členů</span><span class="sxs-lookup"><span data-stu-id="c3e21-140">Member Definitions</span></span>  
 <span data-ttu-id="c3e21-141">Typy lze definovat členy pro využití XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="c3e21-142">Je možné pro typy, které definují členy, které jsou použitelné XAML i v případě konkrétního typu se nedá použít pro XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="c3e21-143">To je možné z důvodu CLR dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="c3e21-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="c3e21-144">Tak dlouho, dokud nějaký typ, který dědí člen podporuje použití XAML jako typ a člen podporuje použití XAML pro jeho základní typ nebo má nativní syntaxe XAML k dispozici, je daný člen XAML počítačově využitelný.</span><span class="sxs-lookup"><span data-stu-id="c3e21-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="c3e21-145">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="c3e21-145">Properties</span></span>  
 <span data-ttu-id="c3e21-146">Pokud definujete vlastnosti jako veřejná vlastnost CLR pomocí typické CLR `get` a `set` přístupové vzory a používání jazyka odpovídající typu systému XAML můžete nahlásit zadaná pro vlastnost jako člena s příslušnými informacemi <xref:System.Xaml.XamlMember> vlastnosti, jako například <xref:System.Xaml.XamlMember.IsReadPublic%2A> a <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3e21-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="c3e21-147">Specifické vlastnosti můžete povolit syntaxe textu s použitím <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c3e21-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="c3e21-148">Další informace najdete v tématu [převaděče typů a rozšíření značek pro XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="c3e21-149">Chybí text syntaxe nebo nativní převod XAML a neexistují další dereference, jako je například použití rozšíření značky, typ vlastnosti (<xref:System.Xaml.XamlMember.TargetType%2A> XAML zadejte system) musí být schopni vracet instanci pro zápis objektu XAML díky tomu t, že Typ cíle jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="c3e21-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="c3e21-150">Pokud používáte XAML 2009 [x: Reference – rozšíření značek](x-reference-markup-extension.md) je možné zadat hodnoty, pokud předchozí požadavky nejsou splněny; který je ale více problém použití než v případě problému definice typu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="c3e21-151">Události</span><span class="sxs-lookup"><span data-stu-id="c3e21-151">Events</span></span>  
 <span data-ttu-id="c3e21-152">Pokud definujete události jako veřejná událost CLR, typu systému XAML můžete nahlásit události jako člena s <xref:System.Xaml.XamlMember.IsEvent%2A> jako `true`.</span><span class="sxs-lookup"><span data-stu-id="c3e21-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="c3e21-153">Vzájemné propojení obslužné rutiny událostí není v rámci oboru funkce rozhraní .NET Framework XAML Services; To je ponecháno na konkrétní rozhraní a implementaci.</span><span class="sxs-lookup"><span data-stu-id="c3e21-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="c3e21-154">Metody</span><span class="sxs-lookup"><span data-stu-id="c3e21-154">Methods</span></span>  
 <span data-ttu-id="c3e21-155">Vložený kód pro metody není výchozí možnost XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="c3e21-156">Ve většině případů můžete přímo neodkazujte metoda členy z XAML a roli metod v XAML je jenom k poskytování podpory pro určité vzory XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="c3e21-157">[x: FactoryMethod – direktiva](x-factorymethod-directive.md) výjimka.</span><span class="sxs-lookup"><span data-stu-id="c3e21-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="c3e21-158">Pole</span><span class="sxs-lookup"><span data-stu-id="c3e21-158">Fields</span></span>  
 <span data-ttu-id="c3e21-159">Pokyny k návrhu CLR Zabraňte nestatické pole.</span><span class="sxs-lookup"><span data-stu-id="c3e21-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="c3e21-160">Pro statické pole se zobrazí hodnoty statických polí jen prostřednictvím [x: Static – rozšíření značek](x-static-markup-extension.md); v takovém případě nejsou dělat nic zvláštního v definici CLR vystavit pole pro [x: Static](x-static-markup-extension.md) použití.</span><span class="sxs-lookup"><span data-stu-id="c3e21-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="c3e21-161">Připojitelná členy</span><span class="sxs-lookup"><span data-stu-id="c3e21-161">Attachable Members</span></span>  
 <span data-ttu-id="c3e21-162">Připojitelná členy jsou přístupné na XAML prostřednictvím na definující typ přístupového objektu metoda vzorek.</span><span class="sxs-lookup"><span data-stu-id="c3e21-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="c3e21-163">Definující typ, samotný nemusí být XAML použitelné jako objekt.</span><span class="sxs-lookup"><span data-stu-id="c3e21-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="c3e21-164">Ve skutečnosti se běžně používá k deklaraci třídy služby, jejichž role je vlastní připojitelný člen a implementovat související chování, ale sloužit jiné funkce, jako je například znázornění uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c3e21-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="c3e21-165">Na následující oddíly, zástupný symbol *PropertyName* představuje název připojitelný člen.</span><span class="sxs-lookup"><span data-stu-id="c3e21-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="c3e21-166">Tento název musí být platné v [xamlname – gramatika](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="c3e21-167">Buďte opatrní kolizí název mezi tyto vzory a jiné metody typu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="c3e21-168">Pokud existuje člen, který odpovídá jednomu ze vzorů, ji lze interpretovat jako cestu připojitelný člen využití procesoru XAML i v případě, který nebyl váš záměr.</span><span class="sxs-lookup"><span data-stu-id="c3e21-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="c3e21-169">Přístupový objekt GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="c3e21-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="c3e21-170">Podpis pro `Get` *PropertyName* přístupový objekt musí být:</span><span class="sxs-lookup"><span data-stu-id="c3e21-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 `public static object Get` *<span data-ttu-id="c3e21-171">Vlastnost PropertyName</span><span class="sxs-lookup"><span data-stu-id="c3e21-171">PropertyName</span></span>* `(object`  `target` `)`  
  
-   <span data-ttu-id="c3e21-172">`target` Objektu lze zadat jako konkrétnější typ ve vaší implementaci.</span><span class="sxs-lookup"><span data-stu-id="c3e21-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="c3e21-173">Může být využit k určení oboru využití připojitelný člen; použití mimo určený rozsah vyvolají výjimky neplatné přetypování, které jsou pak prezentované podle Chyba analýzy XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="c3e21-174">Název parametru `target` není povinné, ale má název `target` konvencí ve většině implementací.</span><span class="sxs-lookup"><span data-stu-id="c3e21-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="c3e21-175">Návratová hodnota se dá nastavit jako konkrétnější typ ve vaší implementaci.</span><span class="sxs-lookup"><span data-stu-id="c3e21-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="c3e21-176">Pro podporu <xref:System.ComponentModel.TypeConverter> povoleno textová syntaxe pro použití atributu připojitelný člen použít <xref:System.ComponentModel.TypeConverterAttribute> k `Get` *PropertyName* přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="c3e21-177">Použití `get` místo `set` se může zdát nonintuitive; tato úmluva však může podporovat koncept jen pro čtení připojitelná členů, které jsou serializovatelné, což je užitečné v situacích, návrháře.</span><span class="sxs-lookup"><span data-stu-id="c3e21-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="c3e21-178">Přístupový objekt SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="c3e21-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="c3e21-179">Podpis pro sadu*PropertyName* přístupový objekt musí být:</span><span class="sxs-lookup"><span data-stu-id="c3e21-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 `public static void Set` *<span data-ttu-id="c3e21-180">Vlastnost PropertyName</span><span class="sxs-lookup"><span data-stu-id="c3e21-180">PropertyName</span></span>* `(object`  `target` `, object`  `value` `)`  
  
-   <span data-ttu-id="c3e21-181">`target` Objektu lze zadat jako konkrétnější typ v implementaci, se stejnými logiky a důsledky, jak je popsáno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="c3e21-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="c3e21-182">`value` Objektu lze zadat jako konkrétnější typ ve vaší implementaci.</span><span class="sxs-lookup"><span data-stu-id="c3e21-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="c3e21-183">Mějte na paměti, že hodnota pro tuto metodu je vstup z využití XAML, obvykle do formuláře atributů.</span><span class="sxs-lookup"><span data-stu-id="c3e21-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="c3e21-184">Z formuláře atributů musí být hodnota převaděč podporu syntaxe textu, a atribut na `Get` *PropertyName* přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="c3e21-185">Připojitelný člen úložišť</span><span class="sxs-lookup"><span data-stu-id="c3e21-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="c3e21-186">Přístupové metody obvykle nejsou dost prostředků připojitelný člen hodnoty umístí do grafu objektu, nebo k načtení hodnoty z objektu grafu a je správně serializovat.</span><span class="sxs-lookup"><span data-stu-id="c3e21-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="c3e21-187">Tuto funkčnost `target` objekty v předchozích podpisech přístupový objekt musí být schopné ukládání hodnot.</span><span class="sxs-lookup"><span data-stu-id="c3e21-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="c3e21-188">Mechanismus úložiště by měl být konzistentní s připojitelný člen zásadě, že člen je připojitelná k cíli, kde připojitelný člen není v seznamu členů.</span><span class="sxs-lookup"><span data-stu-id="c3e21-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="c3e21-189">Rozhraní .NET framework XAML Services poskytuje techniku implementaci pro prostřednictvím rozhraní API jsou uloženy připojitelný člen <xref:System.Xaml.IAttachedPropertyStore> a <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="c3e21-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <xref:System.Xaml.IAttachedPropertyStore> <span data-ttu-id="c3e21-190">uživatelé vytvářející obsah XAML používá ke zjišťování implementace úložiště a by měla být implementována na typ, který je `target` přistupujících objektů.</span><span class="sxs-lookup"><span data-stu-id="c3e21-190">is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="c3e21-191">Statické <xref:System.Xaml.AttachablePropertyServices> rozhraní API se používají v těle přístupové objekty a odkazovat na připojitelný člen podle jeho <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="c3e21-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="c3e21-192">Atributy CLR související s jazykem XAML</span><span class="sxs-lookup"><span data-stu-id="c3e21-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="c3e21-193">Správně zapisujících typy, členy a sestavení je důležité, aby sestavy informací o typu systému XAML pro rozhraní .NET Framework XAML Services.</span><span class="sxs-lookup"><span data-stu-id="c3e21-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="c3e21-194">Toto je relevantní, pokud máte v úmyslu vaše typy pro použití s XAML systémy, které jsou přímo založena na rozhraní .NET Framework XAML Services XAML čtečky a zapisovače XAML, nebo pokud definujete nebo pomocí rozhraní využívá XAML, která je založena na těchto XAML čtečky a zapisovače XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="c3e21-195">Výpis každého atributu souvisejícím s XAML, který je relevantní informace o podpoře XAML vlastní typy, najdete v části [XAML-Related CLR atributy pro vlastní typy a knihovny](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="c3e21-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="c3e21-196">Použití</span><span class="sxs-lookup"><span data-stu-id="c3e21-196">Usage</span></span>  
 <span data-ttu-id="c3e21-197">Použití vlastních typů vyžaduje, že autor značky musí být namapovaný předponu pro sestavení a názvový prostor CLR, které obsahují vlastního typu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="c3e21-198">Tento postup není uvedeno v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="c3e21-199">Úroveň přístupu</span><span class="sxs-lookup"><span data-stu-id="c3e21-199">Access Level</span></span>  
 <span data-ttu-id="c3e21-200">XAML poskytuje prostředky pro načtení a vytvoření instancí typů, které mají `internal` úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="c3e21-201">Tato možnost je poskytována tak, aby uživatelský kód můžete definovat vlastní typy a pak vytvoření instance těchto tříd z kódu, který je také součástí stejného kódu oboru uživatele.</span><span class="sxs-lookup"><span data-stu-id="c3e21-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="c3e21-202">Příkladem pro WPF je vždy, když uživatelský kód definuje <xref:System.Windows.Controls.UserControl> , který je určený jako způsob, jak Refaktorovat chování uživatelského rozhraní, ale ne jako součást každý použitý mechanizmus možné rozšíření, která může být implicitní podpůrnou třídu s deklarací `public` úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="c3e21-203">Tyto <xref:System.Windows.Controls.UserControl> mohou být deklarovány s `internal` přistupovat v případě, že záložní kód je zkompilován do stejného sestavení, ze kterého se na ni odkazuje jako typ XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="c3e21-204">Pro aplikace, která načte XAML v úplném vztahu důvěryhodnosti a použije <xref:System.Xaml.XamlObjectWriter>, načítání tříd pomocí `internal` úroveň přístupu je vždy povolena.</span><span class="sxs-lookup"><span data-stu-id="c3e21-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="c3e21-205">Pro aplikace, která načte XAML v částečném vztahu důvěryhodnosti, můžete nastavit vlastnosti úrovně přístupu pomocí <xref:System.Xaml.Permissions.XamlAccessLevel> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c3e21-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="c3e21-206">Navíc musí být schopen rozšířily úrovně oprávnění a zachovat pro zkušební případnou běhu; mechanismy odložení (jako je například systém šablony WPF) To je interně zpracována třídou předání <xref:System.Xaml.Permissions.XamlAccessLevel> informace.</span><span class="sxs-lookup"><span data-stu-id="c3e21-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="c3e21-207">Implementaci WPF</span><span class="sxs-lookup"><span data-stu-id="c3e21-207">WPF Implementation</span></span>  
 <span data-ttu-id="c3e21-208">WPF XAML používá model přístupu částečným vztahem důvěryhodnosti, kam Pokud BAML je načten v částečném vztahu důvěryhodnosti, je přístup omezen na <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> pro sestavení, který je zdrojem BAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="c3e21-209">Používá pro odložení, WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> jako mechanismus pro předávání informací úrovně přístupu.</span><span class="sxs-lookup"><span data-stu-id="c3e21-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="c3e21-210">V terminologii WPF XAML *vnitřní typ* je typ, který je definován ve stejném sestavení, která zahrnuje i odkazující XAML.</span><span class="sxs-lookup"><span data-stu-id="c3e21-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="c3e21-211">Takový typ lze mapovat pomocí oboru názvů XAML, která záměrně vynechá sestavení = část mapování, například `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="c3e21-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="c3e21-212">Pokud BAML odkazuje na vnitřní typ a zda má typ `internal` přístup k úrovni, tím se vygeneruje `GeneratedInternalTypeHelper` třídy pro sestavení.</span><span class="sxs-lookup"><span data-stu-id="c3e21-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="c3e21-213">Pokud chcete, aby se zabránilo `GeneratedInternalTypeHelper`, buď musíte použít `public` přístup k úrovni, nebo musí zohlednit příslušné třídě do samostatných sestavení a ujistěte se, že sestavení závislé.</span><span class="sxs-lookup"><span data-stu-id="c3e21-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3e21-214">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c3e21-214">See also</span></span>

- [<span data-ttu-id="c3e21-215">Atributy CLR související s jazykem XAML pro vlastní typy a knihovny</span><span class="sxs-lookup"><span data-stu-id="c3e21-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="c3e21-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="c3e21-216">XAML Services</span></span>](index.md)
