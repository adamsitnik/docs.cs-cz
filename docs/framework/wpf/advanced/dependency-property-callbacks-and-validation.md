---
title: Zpětné volání a ověření vlastností závislostí
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: 7f00961ba100700c68936cc33facfdc758c77d3f
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/22/2019
ms.locfileid: "69940826"
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="9a7fb-102">Zpětné volání a ověření vlastností závislostí</span><span class="sxs-lookup"><span data-stu-id="9a7fb-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="9a7fb-103">Toto téma popisuje, jak vytvořit vlastnosti závislosti pomocí alternativních vlastních implementací pro funkce související s vlastnostmi, jako je například určení ověřování, zpětná volání, která jsou vyvolána při změně efektivní hodnoty vlastnosti a přepsání možné vnější vlivy na určení hodnoty.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="9a7fb-104">Toto téma také popisuje scénáře, kdy je vhodné rozšířit chování výchozího systému vlastností systémem pomocí těchto technik.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="9a7fb-105">Požadavky</span><span class="sxs-lookup"><span data-stu-id="9a7fb-105">Prerequisites</span></span>  
 <span data-ttu-id="9a7fb-106">V tomto tématu se předpokládá, že rozumíte základním scénářům implementace vlastnosti závislosti a způsobu, jakým se aplikují metadata na vlastní vlastnost závislosti.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="9a7fb-107">Podívejte se na téma [vlastnosti vlastní závislosti](custom-dependency-properties.md) a [metadata vlastnosti závislosti](dependency-property-metadata.md) pro kontext.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-107">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>   
## <a name="validation-callbacks"></a><span data-ttu-id="9a7fb-108">Zpětná volání ověření</span><span class="sxs-lookup"><span data-stu-id="9a7fb-108">Validation Callbacks</span></span>  
 <span data-ttu-id="9a7fb-109">Zpětná volání ověřování lze přiřadit vlastnosti závislosti při prvním registraci.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="9a7fb-110">Zpětné volání ověřování není součástí metadat vlastností; Jedná se o přímý vstup <xref:System.Windows.DependencyProperty.Register%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="9a7fb-111">Proto Jakmile je pro vlastnost závislosti vytvořeno zpětné volání ověřování, nelze ji přepsat novou implementací.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="9a7fb-112">Zpětná volání jsou implementována tak, aby byla poskytnuta hodnota objektu.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="9a7fb-113">Vrátí `true` , pokud je zadaná hodnota pro vlastnost platná. v opačném případě vrátí `false`.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="9a7fb-114">Předpokládá se, že vlastnost je správného typu na typ zaregistrovaný v systému vlastností, takže typ kontroly v rámci zpětných volání není obvykle proveden.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="9a7fb-115">Zpětná volání jsou používána systémem vlastností v nejrůznějších různých operacích.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="9a7fb-116">To zahrnuje inicializaci počátečního typu podle výchozí hodnoty, programového změny vyvoláním <xref:System.Windows.DependencyObject.SetValue%2A>nebo pokusů o přepsání metadat s poskytnutou novou výchozí hodnotou.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="9a7fb-117">Pokud je zpětné volání ověřování vyvoláno kteroukoli z těchto operací a vrátí `false`, bude vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="9a7fb-118">Aby bylo možné tyto výjimky zpracovat, musí být moduly pro zápis aplikací připravené.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="9a7fb-119">Běžné použití zpětných volání ověřování ověřuje hodnoty výčtu nebo omezuje hodnoty celých čísel nebo dvojitých hodnot, pokud vlastnost nastavuje měření, která musí být nulová nebo větší.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="9a7fb-120">Zpětná volání ověřování jsou určena speciálně pro validátory tříd, nikoli pro validátory instancí.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="9a7fb-121">Parametry zpětného volání nekomunikují specificky <xref:System.Windows.DependencyObject> , na kterých jsou nastaveny vlastnosti k ověření.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="9a7fb-122">Zpětná volání ověřování nejsou proto užitečná pro vynucování možných "závislostí", které by mohly ovlivnit hodnotu vlastnosti, kde je hodnota vlastnosti specifická pro konkrétní instance závislá na faktorech, jako jsou například hodnoty specifické pro instance jiných vlastností nebo Běhový stav.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="9a7fb-123">Následuje příklad kódu pro velmi jednoduché ověřování typu zpětného volání: ověřování, že vlastnost, která je zadána jako <xref:System.Double> primitivní <xref:System.Double.PositiveInfinity> , není nebo <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="9a7fb-124">Převede zpětná volání hodnot a události změněné vlastností.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="9a7fb-125">Zpětná volání převodních hodnot předají <xref:System.Windows.DependencyObject> konkrétní instanci pro vlastnosti, <xref:System.Windows.PropertyChangedCallback> stejně jako implementace, které jsou vyvolány systémem vlastností při změně hodnoty vlastnosti závislosti.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="9a7fb-126">Pomocí těchto dvou zpětných volání v kombinaci můžete vytvořit řadu vlastností pro prvky, kde změny v jedné vlastnosti vynutí vynucení nebo opětovné vyhodnocení jiné vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="9a7fb-127">Typický scénář pro použití propojení vlastností závislosti je v případě, že máte vlastnost založenou na uživatelském rozhraní, kde element obsahuje jednu vlastnost pro minimální a maximální hodnotu a třetí vlastnost pro skutečnou nebo aktuální hodnotu.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="9a7fb-128">Pokud je toto maximum upraveno takovým způsobem, že aktuální hodnota překročila nové maximum, měla by být aktuální hodnota převedena na hodnotu vyšší než nové maximum a podobný vztah pro minimum na hodnotu Current.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="9a7fb-129">Následuje stručný ukázkový kód pouze pro jednu ze tří vlastností závislosti, které ilustrují tento vztah.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="9a7fb-130">Příklad ukazuje, jak `CurrentReading` je zaregistrována vlastnost minimální/maximální/aktuální sady souvisejících vlastností pro čtení.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related \*Reading properties is registered.</span></span> <span data-ttu-id="9a7fb-131">Používá ověření, jak je znázorněno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="9a7fb-132">Vlastnost, která se změnila zpět pro aktuální, slouží k přeposílání změn na jiné závislé vlastnosti tím, že explicitně vyvolá zpětná volání přenesených hodnot, která jsou registrována pro tyto ostatní vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="9a7fb-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="9a7fb-133">Zpětné volání s převedenou hodnotou kontroluje hodnoty vlastností, na kterých je aktuální vlastnost potenciálně závislá, a v případě potřeby Převede aktuální hodnotu:</span><span class="sxs-lookup"><span data-stu-id="9a7fb-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> <span data-ttu-id="9a7fb-134">Výchozí hodnoty vlastností nejsou přiřazeny.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="9a7fb-135">Hodnota vlastnosti, která se rovná výchozí hodnotě, může nastat, pokud hodnota vlastnosti stále má počáteční výchozí hodnotu, nebo pomocí mazání jiných hodnot <xref:System.Windows.DependencyObject.ClearValue%2A>pomocí.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="9a7fb-136">Zpětná volání přeměněných hodnot a vlastností jsou součástí metadat vlastností.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="9a7fb-137">Proto můžete změnit zpětná volání pro konkrétní vlastnost závislosti, protože existuje u typu, který je odvozen z typu, který vlastní vlastnost závislosti, přepsáním metadat pro tuto vlastnost typu.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>   
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="9a7fb-138">Pokročilé scénáře vynucení a zpětného volání</span><span class="sxs-lookup"><span data-stu-id="9a7fb-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="9a7fb-139">Omezení a požadované hodnoty</span><span class="sxs-lookup"><span data-stu-id="9a7fb-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="9a7fb-140"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Zpětná volání budou použita systémem vlastností k přenesení hodnoty v souladu s logikou, kterou deklarujete, ale převedená hodnota vlastnosti lokálně uchová stále "požadovanou hodnotu" interně.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="9a7fb-141">Pokud jsou omezení založena na dalších hodnotách vlastností, které se mohou dynamicky měnit během životního cyklu aplikace, jsou omezení vynuceně měněna dynamicky a omezená vlastnost může změnit její hodnotu tak, aby se co nejblíže požadované hodnotě. je možné vydávat nová omezení.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="9a7fb-142">Hodnota se změní na požadovanou hodnotu, pokud jsou všechna omezení vyvolána.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="9a7fb-143">V případě, že máte více vlastností, které jsou na sobě vzájemně závislé, můžete začlenit některé poměrně složité scénáře závislosti.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="9a7fb-144">Například ve scénáři min/max/current se můžete rozhodnout, že nastavit uživatele jako minimální a maximální hodnotu.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="9a7fb-145">Pokud ano, může být nutné, aby toto maximum bylo vždy větší než minimum a naopak.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="9a7fb-146">Pokud je však tato konverze aktivní a maximum se převede na minimum, zůstane aktuální v nastavitelných stavech, protože je závislý na obou a je omezený na rozsah mezi hodnotami, což je nula.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="9a7fb-147">Když se pak hodnota maximum nebo minimum upraví, zobrazí se u položky "sledovat" jednu z hodnot, protože požadovaná hodnota Current je stále uložená a pokouší se dosáhnout požadované hodnoty, protože jsou omezení vydaná.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="9a7fb-148">Nedošlo k žádné technické chybě se složitými závislostmi, ale může se jednat o mírné zvýšení výkonu, pokud vyžadují velký počet přehodnocení a může být také matoucí pro uživatele, pokud mají vliv na uživatelské rozhraní přímo.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="9a7fb-149">Buďte opatrní se změnou vlastnosti a převedli zpětná volání hodnot a zajistěte, aby se převedená konverze mohla považovat za nejednoznačnou možnou hodnotu a nepředstavuje "omezení".</span><span class="sxs-lookup"><span data-stu-id="9a7fb-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="9a7fb-150">Zrušení změn hodnot pomocí CoerceValue</span><span class="sxs-lookup"><span data-stu-id="9a7fb-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="9a7fb-151">Systém vlastností zpracuje všechny <xref:System.Windows.CoerceValueCallback> , které vrací hodnotu <xref:System.Windows.DependencyProperty.UnsetValue> jako zvláštní případ.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="9a7fb-152">Tento zvláštní případ znamená, že změna vlastnosti, která je výsledkem <xref:System.Windows.CoerceValueCallback> volání metody, by měla být zamítnutá systémem vlastností a že by měl systém vlastností místo toho hlásit jakoukoli předchozí hodnotu, kterou vlastnost měla.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="9a7fb-153">Tento mechanismus může být užitečný pro kontrolu, že změny vlastnosti, které byly iniciovány asynchronně, jsou pro aktuální stav objektu stále platné, a změny se potlačí, pokud ne.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="9a7fb-154">Dalším možným scénářem je, že můžete selektivně potlačit hodnotu v závislosti na tom, která součást určení hodnot vlastností zodpovídá za nahlášenou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="9a7fb-155">Chcete-li to provést, můžete použít <xref:System.Windows.DependencyProperty> předaný příkaz ke zpětnému volání a identifikátor vlastnosti jako <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>vstup pro a poté zpracovat <xref:System.Windows.ValueSource>.</span><span class="sxs-lookup"><span data-stu-id="9a7fb-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9a7fb-156">Viz také:</span><span class="sxs-lookup"><span data-stu-id="9a7fb-156">See also</span></span>

- [<span data-ttu-id="9a7fb-157">Přehled vlastností závislosti</span><span class="sxs-lookup"><span data-stu-id="9a7fb-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="9a7fb-158">Metadata vlastností závislosti</span><span class="sxs-lookup"><span data-stu-id="9a7fb-158">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="9a7fb-159">Vlastní vlastnosti závislosti</span><span class="sxs-lookup"><span data-stu-id="9a7fb-159">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
