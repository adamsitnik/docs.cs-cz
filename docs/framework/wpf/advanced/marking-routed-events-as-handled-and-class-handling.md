---
title: Označení směrovaných událostí jako zpracovaných a zpracování tříd
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401641"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="bd29a-102">Označení směrovaných událostí jako zpracovaných a zpracování tříd</span><span class="sxs-lookup"><span data-stu-id="bd29a-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="bd29a-103">Obslužné rutiny směrované události mohou označovat událost zpracovanou v datech události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="bd29a-104">Zpracování události bude efektivně zkrátit trasu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="bd29a-105">Zpracování tříd je programovací pojem, který je podporován směrovanými událostmi.</span><span class="sxs-lookup"><span data-stu-id="bd29a-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="bd29a-106">Obslužná rutina třídy má příležitost zpracovat konkrétní směrovanou událost na úrovni třídy pomocí obslužné rutiny, která je vyvolána před jakoukoliv obslužnou rutinou instance v jakékoli instanci třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="bd29a-107">Požadavky</span><span class="sxs-lookup"><span data-stu-id="bd29a-107">Prerequisites</span></span>  
 <span data-ttu-id="bd29a-108">Toto téma se seznámí s koncepty představenými v [přehledu směrovaných událostí](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="bd29a-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="bd29a-109">Kdy označit události jako zpracovávané</span><span class="sxs-lookup"><span data-stu-id="bd29a-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="bd29a-110">Při nastavení hodnoty <xref:System.Windows.RoutedEventArgs.Handled%2A> vlastnosti na `true` hodnotu v datech události pro směrovanou událost se označuje jako "označení události, která se zpracovává".</span><span class="sxs-lookup"><span data-stu-id="bd29a-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="bd29a-111">Neexistuje žádné absolutní pravidlo, pokud byste měli označit směrované události jako zpracovávané, buď jako autora aplikace, nebo jako autor ovládacího prvku, který reaguje na stávající směrované události nebo implementuje nové směrované události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="bd29a-112">Ve většině případů by koncept "zpracovávaný" byl v datech události směrované události použit jako omezený protokol pro vlastní odpovědi aplikace na různé směrované události vystavené v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] rozhraních API a také pro všechny vlastní směrované události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="bd29a-113">Dalším způsobem, jak vzít v úvahu "zpracovávaný" problém, je, že byste měli obecně označit směrovanou událost, která je zpracována, pokud kód odpověděl na směrovanou událost významným a relativně úplným způsobem.</span><span class="sxs-lookup"><span data-stu-id="bd29a-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="bd29a-114">Obvykle by neměla existovat více než jedna významná odpověď, která vyžaduje samostatné implementace obslužných rutin pro každý výskyt události s jedním směrováním.</span><span class="sxs-lookup"><span data-stu-id="bd29a-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="bd29a-115">Je-li zapotřebí více odpovědí, je nutné implementovat potřebný kód prostřednictvím logiky aplikace, která je zřetězena v rámci jedné obslužné rutiny, nikoli pomocí směrovaného systému událostí pro přesměrování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="bd29a-116">Pojem "značný" je také subjektivní a závisí na vaší aplikaci nebo kódu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="bd29a-117">Obecně platí, že některé "významné reakce" jsou například: nastavení fokusu, změna veřejného stavu, nastavení vlastností, které ovlivňují vizuální znázornění a vyvolání dalších nových událostí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="bd29a-118">Mezi příklady nepodstatných odpovědí patří: Změna privátního stavu (bez vizuálního dopadu nebo programové rereprezentace), protokolování událostí nebo prohlížení argumentů události a volba nereakce na ni.</span><span class="sxs-lookup"><span data-stu-id="bd29a-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="bd29a-119">Chování směrovaného systému událostí posiluje tento model "významná reakce" pro použití zpracovaného stavu směrované události, protože obslužné rutiny, které [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] jsou přidány v nástroji nebo <xref:System.Windows.UIElement.AddHandler%2A> společný podpis, nejsou vyvolány v reakci na směrovanou událost, kde událost data jsou již označena jako zpracovaná.</span><span class="sxs-lookup"><span data-stu-id="bd29a-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="bd29a-120">Aby bylo možné zpracovávat směrované události, které jsou označeny předchozími účastníky `handledEventsToo` v trase<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>události, je nutné projít další úsilím o přidání obslužné rutiny s verzí parametru ().</span><span class="sxs-lookup"><span data-stu-id="bd29a-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="bd29a-121">V některých případech ovládací prvky samy označují určité směrované události jako zpracovávané.</span><span class="sxs-lookup"><span data-stu-id="bd29a-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="bd29a-122">Zpracovaná směrovaná událost představuje rozhodnutí na základě [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] autorů ovládacích prvků, že akce ovládacího prvku v reakci na směrovanou událost jsou významné nebo dokončené jako součást implementace ovládacího prvku a událost nepotřebuje žádné další zpracování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="bd29a-123">Obvykle je to provedeno přidáním obslužné rutiny třídy pro událost nebo přepsáním jedné z virtuálních obslužných rutin třídy, které existují v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="bd29a-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="bd29a-124">V případě potřeby můžete toto zpracování událostí dál obejít; Další informace najdete v tématu [práce s potlačením událostí pomocí ovládacích prvků](#WorkingAroundEventSuppressionByControls) dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="bd29a-125">Události Preview (TUNELING) vs. Šíření událostí a zpracování událostí</span><span class="sxs-lookup"><span data-stu-id="bd29a-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="bd29a-126">Směrované události ve verzi Preview jsou události, které následují po tunelové trase prostřednictvím stromu elementu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="bd29a-127">"Preview" vyjádřená v konvenci pojmenování je orientační obecné zásady pro vstupní události, které směrované události ve verzi Preview (TUNELING) jsou vyvolány před ekvivalentní událostí směrovaného probublávání.</span><span class="sxs-lookup"><span data-stu-id="bd29a-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="bd29a-128">Vstupní směrované události, které mají dvojici tunelování a probublávání, mají také zvláštní logiku zpracování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="bd29a-129">Pokud je nasměrovaná událost tunelového propojení/náhledu označena jako zpracovávaná naslouchacím programem událostí, pak bude směrované směrná událost označena jako zpracovaná, a to i před tím, než přijme všechny posluchače směrované směrované události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="bd29a-130">Směrované tunelování a probublávání směrované události jsou technicky samostatné události, ale záměrně sdílejí stejnou instanci dat událostí, aby bylo možné toto chování povolit.</span><span class="sxs-lookup"><span data-stu-id="bd29a-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="bd29a-131">Propojení mezi tunelovým propojením a směrovanými událostmi je provedeno interní implementací způsobu, jakým daná [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] třída vyvolává své vlastní deklarované směrované události a jedná se o true pro spárované vstupní směrované události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="bd29a-132">Pokud však tato implementace na úrovni třídy neexistuje, neexistuje spojení mezi událostí směrované tunelování a probublávání směrované události, která sdílí schéma pojmenování: bez takové implementace by by byly dvě zcela oddělené směrované události a nemusely být vyvoláno v pořadí nebo sdílet data události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="bd29a-133">Další informace o tom, jak implementovat dvojice událostí směrovaného tunelového propojení nebo bublinového vstupu ve vlastní třídě, najdete v tématu [Vytvoření vlastní směrované události](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="bd29a-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="bd29a-134">Obslužné rutiny tříd a obslužné rutiny instancí</span><span class="sxs-lookup"><span data-stu-id="bd29a-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="bd29a-135">Směrované události uvažují dva různé typy posluchačů k události: naslouchací procesy tříd a naslouchací procesy instancí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="bd29a-136">Naslouchací procesy tříd existují, protože typy se nazývají <xref:System.Windows.EventManager> konkrétní rozhraní<xref:System.Windows.EventManager.RegisterClassHandler%2A>API,, ve svém statickém konstruktoru nebo přepsaly virtuální metodu obslužné rutiny třídy z základní třídy elementu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="bd29a-137">Naslouchací procesy instance jsou konkrétní instance nebo prvky třídy, kde byl k této směrované události připojen jeden nebo více obslužných rutin voláním <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="bd29a-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="bd29a-138">Stávající [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] směrované události <xref:System.Windows.UIElement.AddHandler%2A> volají jako součást obálky událostí modulu CLR (Common Language Runtime) přidání{} a odebrání{} implementací události, což je také způsob, jakým je jednoduchý [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanismus Připojení obslužných rutin událostí prostřednictvím syntaxe atributu je povoleno.</span><span class="sxs-lookup"><span data-stu-id="bd29a-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="bd29a-139">Proto i jednoduché [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] použití je nakonec rovno <xref:System.Windows.UIElement.AddHandler%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="bd29a-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="bd29a-140">Prvky ve vizuálním stromu jsou zkontrolovány pro registrované implementace obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="bd29a-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="bd29a-141">Obslužné rutiny jsou potenciálně vyvolány v rámci trasy, v pořadí, které je podstatou typu strategie směrování pro tuto směrovanou událost.</span><span class="sxs-lookup"><span data-stu-id="bd29a-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="bd29a-142">Například probublávání směrované události nejprve vyvolá tyto obslužné rutiny, které jsou připojeny ke stejnému prvku, který vyvolal směrovanou událost.</span><span class="sxs-lookup"><span data-stu-id="bd29a-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="bd29a-143">Pak směrované událost "bubliny" na další nadřazený prvek a tak dále, dokud není dosaženo kořenového prvku aplikace.</span><span class="sxs-lookup"><span data-stu-id="bd29a-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="bd29a-144">Z perspektivy kořenového prvku v trase šíření, pokud zpracování tříd nebo libovolný prvek blíže zdroji směrované události vyvolávají obslužné rutiny, které označují argumenty události jako zpracovávané, nejsou vyvolány obslužné rutiny kořenových elementů a směrování událostí. je účinně zkrácen před dosažením tohoto kořenového prvku.</span><span class="sxs-lookup"><span data-stu-id="bd29a-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="bd29a-145">Nicméně trasa není zcela zastavena, protože obslužné rutiny lze přidat pomocí zvláštního podmíněného řízení, které by měly být vyvolány i v případě, že obslužná rutina třídy nebo obslužná rutina instance označila směrovanou událost jako zpracovanou.</span><span class="sxs-lookup"><span data-stu-id="bd29a-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="bd29a-146">To je vysvětleno v tématu [Přidání obslužných rutin instance, které jsou vyvolány, i když jsou události označeny jako zpracované](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="bd29a-147">Na hlubší úrovni než v případě trasy události, existuje také potenciálně více obslužných rutin třídy působících na jakékoli dané instanci třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="bd29a-148">Důvodem je, že model zpracování tříd pro směrované události umožňuje všem možným třídám v hierarchii tříd pro každou směrovanou událost zaregistrovat svoji vlastní obslužnou rutinu třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="bd29a-149">Každá obslužná rutina třídy je přidána do interního úložiště a při sestavení trasy události pro aplikaci jsou všechny obslužné rutiny třídy přidány do trasy události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="bd29a-150">Obslužné rutiny třídy jsou přidány do trasy tak, že je nejprve vyvolána největší odvozená třída a obslužné rutiny třídy z každé následující základní třídy jsou vyvolány v dalším.</span><span class="sxs-lookup"><span data-stu-id="bd29a-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="bd29a-151">Obecně nejsou obslužné rutiny tříd registrovány tak, že reagují na směrované události, které již byly označeny jako zpracované.</span><span class="sxs-lookup"><span data-stu-id="bd29a-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="bd29a-152">Proto tento mechanismus manipulace třídy umožňuje jednu ze dvou možností:</span><span class="sxs-lookup"><span data-stu-id="bd29a-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="bd29a-153">Odvozené třídy mohou doplňovat zpracování tříd, která je zděděna ze základní třídy přidáním obslužné rutiny, která neoznačuje zpracování směrované události, protože obslužná rutina základní třídy bude vyvolána každou za každou za obslužnou rutinu odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="bd29a-154">Odvozené třídy mohou nahradit zpracování tříd ze základní třídy přidáním obslužné rutiny třídy, která označuje zpracování směrované události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="bd29a-155">Měli byste být opatrní s tímto přístupem, protože bude potenciálně měnit zamýšlený návrh základního ovládacího prvku v oblastech, jako je vizuální vzhled, stavová logika, zpracování vstupu a zpracování příkazů.</span><span class="sxs-lookup"><span data-stu-id="bd29a-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="bd29a-156">Zpracování tříd směrovaných událostí pomocí základních tříd ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="bd29a-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="bd29a-157">U každého daného uzlu elementu v trase události mají naslouchací procesy třídy možnost reagovat na směrovanou událost před tím, než může kterýkoli naslouchací proces instancí elementu.</span><span class="sxs-lookup"><span data-stu-id="bd29a-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="bd29a-158">Z tohoto důvodu obslužné rutiny třídy jsou někdy použity pro potlačení směrovaných událostí, které konkrétní implementace třídy ovládacího prvku nechce rozšířit další, nebo pro poskytnutí speciálního zpracování této směrované události, která je funkcí třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="bd29a-159">Například třída může vyvolat svou vlastní událost specifickou pro třídu, která obsahuje konkrétnější informace o tom, co některá podmínka vstupu uživatele znamená v kontextu této konkrétní třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="bd29a-160">Implementace třídy pak může označit obecnější směrované události jako zpracovávané.</span><span class="sxs-lookup"><span data-stu-id="bd29a-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="bd29a-161">Obslužné rutiny třídy jsou obvykle přidány tak, že nejsou vyvolány pro směrované události, kde již byla označena zpracovaná data události, ale v případě netypických případů existuje i <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpis, který zaregistruje obslužné rutiny tříd k vyvolání, i když jsou směrované události označeno jako zpracované.</span><span class="sxs-lookup"><span data-stu-id="bd29a-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="bd29a-162">Virtuální obslužné rutiny třídy</span><span class="sxs-lookup"><span data-stu-id="bd29a-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="bd29a-163">Některé prvky, zejména základní prvky <xref:System.Windows.UIElement>, jako je, vystavení prázdné "on \*" událost "a" událost náhledu\*události ", které odpovídají jejich seznamu veřejných směrovaných událostí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="bd29a-164">Tyto virtuální metody lze přepsat pro implementaci obslužné rutiny třídy pro tuto směrovanou událost.</span><span class="sxs-lookup"><span data-stu-id="bd29a-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="bd29a-165">Základní třídy prvků registrují tyto virtuální metody jako obslužné rutiny třídy pro každou takovou směrovanou událost <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> pomocí postupu popsaného výše.</span><span class="sxs-lookup"><span data-stu-id="bd29a-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="bd29a-166">Virtuální metody\*události on zjednodušují implementaci zpracování tříd pro příslušné směrované události, aniž by vyžadovaly speciální inicializaci ve statických konstruktorech pro každý typ.</span><span class="sxs-lookup"><span data-stu-id="bd29a-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="bd29a-167">Například můžete přidat zpracování tříd pro <xref:System.Windows.UIElement.DragEnter> událost v libovolné <xref:System.Windows.UIElement> <xref:System.Windows.UIElement.OnDragEnter%2A> odvozené třídy přepsáním virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="bd29a-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="bd29a-168">V rámci přepsání můžete zpracovat směrovanou událost, vyvolat další události, iniciovat logiku specifickou pro třídu, která může měnit vlastnosti prvku na instancích nebo jakoukoli kombinaci těchto akcí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="bd29a-169">Obecně byste měli volat základní implementaci v takových přepsáních i v případě, že označíte událost, která je zpracována.</span><span class="sxs-lookup"><span data-stu-id="bd29a-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="bd29a-170">Důrazně doporučujeme volání základní implementace, protože virtuální metoda je na základní třídě.</span><span class="sxs-lookup"><span data-stu-id="bd29a-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="bd29a-171">Standardní chráněný virtuální model pro volání základních implementací z každého virtuálního v podstatě nahrazuje a paralelně podobný mechanizmus, který je nativní pro směrování zpracování tříd událostí, přičemž obslužné rutiny třídy pro všechny třídy v hierarchii tříd jsou volá se na všech daných instancích počínaje obslužnou rutinou nejvyšší odvozené třídy a pokračuje se obslužnou rutinou základní třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="bd29a-172">Je nutné vynechat volání základní implementace pouze v případě, že vaše třída má záměrné požadavky na změnu logiky zpracování základní třídy.</span><span class="sxs-lookup"><span data-stu-id="bd29a-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="bd29a-173">Bez ohledu na to, zda zavoláte základní implementaci před nebo po přepsání kódu, bude záviset na povaze vaší implementace.</span><span class="sxs-lookup"><span data-stu-id="bd29a-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="bd29a-174">Zpracování třídy událostí vstupu</span><span class="sxs-lookup"><span data-stu-id="bd29a-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="bd29a-175">Virtuální metody obslužné rutiny třídy jsou všechny zaregistrované tak, aby se vyvolaly jenom v případech, kdy všechna sdílená data událostí ještě nejsou označená jako zpracovaná.</span><span class="sxs-lookup"><span data-stu-id="bd29a-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="bd29a-176">V případě jedinečnosti vstupních událostí jsou také tunelování a šíření verzí obvykle vyvolány v sekvenci a sdílejí data události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="bd29a-177">To má za následek, že pro danou dvojici obslužných rutin třídy vstupních událostí, kde jedna je verze tunelování a druhá je probublávání verze, nechcete, aby byla událost zpracována okamžitě.</span><span class="sxs-lookup"><span data-stu-id="bd29a-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="bd29a-178">Pokud implementujete metodu tunelování pro zpracování virtuální metody k označení zpracování události, která zabrání vyvolání obslužné rutiny třídy (a také zabránění jakýmkoli normálně registrovaným obslužným rutinám instance pro událost tunelového propojení nebo probublávání z je vyvoláno).</span><span class="sxs-lookup"><span data-stu-id="bd29a-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="bd29a-179">Jakmile je zpracování třídy na uzlu dokončeno, jsou považovány za naslouchací procesy instance.</span><span class="sxs-lookup"><span data-stu-id="bd29a-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="bd29a-180">Přidání obslužných rutin instancí, které jsou vyvolány, i když jsou události označeny jako zpracované</span><span class="sxs-lookup"><span data-stu-id="bd29a-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="bd29a-181"><xref:System.Windows.UIElement.AddHandler%2A> Metoda poskytuje konkrétní přetížení, které umožňuje přidat obslužné rutiny, které budou vyvolány systémem událostí vždy, když událost dosáhne elementu manipulace v trase, a to i v případě, že nějaká jiná obslužná rutina již upravila data události k označení toho, že událost je zpracována.</span><span class="sxs-lookup"><span data-stu-id="bd29a-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="bd29a-182">To se obvykle neprovádí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-182">This is not typically done.</span></span> <span data-ttu-id="bd29a-183">Obecně lze obslužné rutiny zapsat pro úpravu všech oblastí kódu aplikace, které mohou být ovlivněny událostí, bez ohledu na to, kde byly zpracovány ve stromové struktuře elementu, i když je požadováno více konečných výsledků.</span><span class="sxs-lookup"><span data-stu-id="bd29a-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="bd29a-184">Také obvykle existuje pouze jeden prvek, který musí na tuto událost reagovat, a příslušná logika aplikace již proběhla.</span><span class="sxs-lookup"><span data-stu-id="bd29a-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="bd29a-185">`handledEventsToo` Ale přetížení je k dispozici pro výjimečné případy, kdy některý jiný prvek ve stromové struktuře elementu nebo skládání ovládacího prvku již označil událost jako zpracovanou, ale jiné prvky ve stromové struktuře elementu (v závislosti na trase) ještě vyšší nebo nižší. chtějí mít vyvolané vlastní obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="bd29a-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="bd29a-186">Kdy označit zpracovávané události jako neošetřené</span><span class="sxs-lookup"><span data-stu-id="bd29a-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="bd29a-187">Obecně směrované události, které jsou označeny jako zpracované, by neměly být označeny jako neošetřené<xref:System.Windows.RoutedEventArgs.Handled%2A> ( `false`nastavení zpět na), a to `handledEventsToo`i pomocí obslužných rutin, které fungují.</span><span class="sxs-lookup"><span data-stu-id="bd29a-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="bd29a-188">Nicméně některé vstupní události mají na vysoké úrovni a reprezentace událostí nižší úrovně, které se mohou překrývat, pokud se událost vysoké úrovně zobrazuje na jedné pozici stromu a událost nízké úrovně na jiné pozici.</span><span class="sxs-lookup"><span data-stu-id="bd29a-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="bd29a-189">Zvažte například případ, kdy podřízený prvek naslouchá události klíče vysoké úrovně, například <xref:System.Windows.UIElement.TextInput> když nadřazený prvek naslouchá události nízké úrovně, jako je <xref:System.Windows.UIElement.KeyDown>například.</span><span class="sxs-lookup"><span data-stu-id="bd29a-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="bd29a-190">Pokud nadřazený element zpracovává událost nízké úrovně, může být událost vyšší úrovně potlačena i v podřízeném elementu, který by intuitivní by měl mít první příležitost zpracovat událost.</span><span class="sxs-lookup"><span data-stu-id="bd29a-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="bd29a-191">V těchto situacích může být nutné přidat obslužné rutiny do nadřazených prvků a podřízených prvků pro událost nízké úrovně.</span><span class="sxs-lookup"><span data-stu-id="bd29a-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="bd29a-192">Implementace obslužné rutiny podřízeného elementu může označit událost nízké úrovně jako zpracovanou, ale implementace obslužné rutiny nadřazeného elementu by ji znovu nastavila tak, aby další prvky stromu (stejně jako událost vysoké úrovně) mohly mít možnost reagovat.</span><span class="sxs-lookup"><span data-stu-id="bd29a-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="bd29a-193">Tato situace by měla být poměrně zřídka.</span><span class="sxs-lookup"><span data-stu-id="bd29a-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="bd29a-194">Úmyslné potlačení vstupních událostí pro skládání ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="bd29a-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="bd29a-195">Hlavní scénář, ve kterém se používá zpracování tříd směrovaných událostí, je pro vstupní události a složené ovládací prvky.</span><span class="sxs-lookup"><span data-stu-id="bd29a-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="bd29a-196">Složený ovládací prvek je podle definice tvořená několika praktickými ovládacími prvky nebo řídicími základními třídami.</span><span class="sxs-lookup"><span data-stu-id="bd29a-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="bd29a-197">Autor ovládacího prvku často chce amalgamate všechny možné vstupní události, které mohou vyvolat jednotlivé dílčí komponenty, aby bylo možné nahlásit celý ovládací prvek jako jednotný zdroj událostí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="bd29a-198">V některých případech může autor ovládacího prvku chtít potlačit události z komponent zcela nebo nahradit událost definovanou komponentou, která poskytuje další informace nebo implikuje konkrétnější chování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="bd29a-199">Kanonický příklad, který je okamžitě viditelný pro všechny autory komponenty, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] je způsob, jakým <xref:System.Windows.Controls.Button> událost myši, která bude nakonec přeložena na intuitivní událost, která <xref:System.Windows.Controls.Primitives.ButtonBase.Click> má všechna tlačítka: událost.</span><span class="sxs-lookup"><span data-stu-id="bd29a-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="bd29a-200"><xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement> <xref:System.Windows.Controls.Control> <xref:System.Windows.UIElement> Základní třída (<xref:System.Windows.Controls.Primitives.ButtonBase>) je odvozena z toho, ze které se dále odvozují a a většina infrastruktury událostí potřebná pro zpracování vstupu řízení je k dispozici na úrovni. <xref:System.Windows.Controls.Button></span><span class="sxs-lookup"><span data-stu-id="bd29a-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="bd29a-201">Konkrétně <xref:System.Windows.UIElement> zpracovává obecné <xref:System.Windows.Input.Mouse> události, které zpracovávají testy přístupů pro ukazatel myši v rámci jeho hranic, a poskytuje odlišné události pro nejběžnější akce <xref:System.Windows.UIElement.MouseLeftButtonDown>tlačítek, jako je například.</span><span class="sxs-lookup"><span data-stu-id="bd29a-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="bd29a-202"><xref:System.Windows.UIElement>poskytuje také prázdný virtuální <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako obslužnou rutinu pro předregistrovanou třídu pro <xref:System.Windows.UIElement.MouseLeftButtonDown>a <xref:System.Windows.Controls.Primitives.ButtonBase> Přepisuje ji.</span><span class="sxs-lookup"><span data-stu-id="bd29a-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="bd29a-203">Podobně používá obslužné rutiny třídy <xref:System.Windows.UIElement.MouseLeftButtonUp>pro. <xref:System.Windows.Controls.Primitives.ButtonBase></span><span class="sxs-lookup"><span data-stu-id="bd29a-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="bd29a-204">V přepsáních, kterým jsou předány data události, implementace označí tuto <xref:System.Windows.RoutedEventArgs> instanci jako zpracovanou nastavením <xref:System.Windows.RoutedEventArgs.Handled%2A> na `true`a stejnou data události je to, co pokračuje ve zbývající části trasy na jiné obslužné rutiny tříd a také obslužné rutiny instance nebo metody pro navýšení události.</span><span class="sxs-lookup"><span data-stu-id="bd29a-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="bd29a-205">Přepsání také příště <xref:System.Windows.Controls.Primitives.ButtonBase.Click> vyvolá událost. <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A></span><span class="sxs-lookup"><span data-stu-id="bd29a-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="bd29a-206">Konečný výsledek pro většinu posluchačů bude, že <xref:System.Windows.UIElement.MouseLeftButtonDown> události a <xref:System.Windows.UIElement.MouseLeftButtonUp> jsou "zmizí" <xref:System.Windows.Controls.Primitives.ButtonBase.Click>a místo toho jsou nahrazeny událostí, která má větší význam, protože tato událost pochází z tlačítka true a nikoli některých. složená část tlačítka nebo z nějakého jiného prvku zcela.</span><span class="sxs-lookup"><span data-stu-id="bd29a-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="bd29a-207">Práce s potlačením událostí pomocí ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="bd29a-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="bd29a-208">V některých případech může toto chování při potlačení události v rámci jednotlivých ovládacích prvků narušit s některými obecnější záměry logiky zpracování událostí pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="bd29a-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="bd29a-209">Například pokud z nějakého důvodu má aplikace obslužnou rutinu pro <xref:System.Windows.UIElement.MouseLeftButtonDown> umístění v kořenovém elementu aplikace, všimnete si, že jakékoli kliknutí myší na tlačítko by nebylo možné vyvolat <xref:System.Windows.UIElement.MouseLeftButtonDown> nebo <xref:System.Windows.UIElement.MouseLeftButtonUp> obslužné rutiny na kořenové úrovni.</span><span class="sxs-lookup"><span data-stu-id="bd29a-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="bd29a-210">Vlastní událost sama provedla bublinu (znovu, trasy událostí nejsou ve skutečnosti ukončeny, ale směrovaný systém událostí po označení zpracování změní jejich chování volání obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="bd29a-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="bd29a-211">Když směrované událost dosáhla tlačítka, <xref:System.Windows.Controls.Primitives.ButtonBase> zpracovává zpracování třídy označené jako zpracované, <xref:System.Windows.UIElement.MouseLeftButtonDown> protože <xref:System.Windows.Controls.Primitives.ButtonBase.Click> chtěla nahradit událost větším významem.</span><span class="sxs-lookup"><span data-stu-id="bd29a-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="bd29a-212">Proto by se žádná <xref:System.Windows.UIElement.MouseLeftButtonDown> standardní obslužná rutina dále vyvolala.</span><span class="sxs-lookup"><span data-stu-id="bd29a-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="bd29a-213">Existují dva postupy, které můžete použít k zajištění toho, aby byly obslužné rutiny vyvolány v této situaci.</span><span class="sxs-lookup"><span data-stu-id="bd29a-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="bd29a-214">Prvním postupem je úmyslné přidání obslužné rutiny pomocí `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>signatury.</span><span class="sxs-lookup"><span data-stu-id="bd29a-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="bd29a-215">Omezení tohoto přístupu je, že tato technika pro připojení obslužné rutiny události je možné pouze z kódu, nikoli z značek.</span><span class="sxs-lookup"><span data-stu-id="bd29a-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="bd29a-216">Jednoduchá syntaxe zadání názvu obslužné rutiny události jako hodnoty atributu události prostřednictvím [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nepovoluje toto chování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="bd29a-217">Druhá technika funguje pouze pro vstupní události, kde jsou párovány verze tunelování a šíření směrovaných událostí.</span><span class="sxs-lookup"><span data-stu-id="bd29a-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="bd29a-218">Pro tyto směrované události můžete místo toho přidat obslužné rutiny do ekvivalentní směrované události verze Preview/Tunneling.</span><span class="sxs-lookup"><span data-stu-id="bd29a-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="bd29a-219">Tato směrované událost bude tunelem směrována z kořenového adresáře, takže kód pro zpracování třídy tlačítka by ho nezachytil, předpokládá se, že jste připojili obslužnou rutinu Preview na některé úrovni nadřazeného prvku ve stromu prvků aplikace.</span><span class="sxs-lookup"><span data-stu-id="bd29a-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="bd29a-220">Pokud použijete tento přístup, buďte opatrní při označování všech zpracovaných událostí ve verzi Preview.</span><span class="sxs-lookup"><span data-stu-id="bd29a-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="bd29a-221">Pro příklad zadaný <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> při zpracovávání u kořenového prvku, pokud jste označili událost jako <xref:System.Windows.RoutedEventArgs.Handled%2A> v implementaci obslužné rutiny, byste <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událost skutečně potlačili.</span><span class="sxs-lookup"><span data-stu-id="bd29a-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="bd29a-222">To obvykle není žádoucí chování.</span><span class="sxs-lookup"><span data-stu-id="bd29a-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bd29a-223">Viz také:</span><span class="sxs-lookup"><span data-stu-id="bd29a-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="bd29a-224">Události náhledu</span><span class="sxs-lookup"><span data-stu-id="bd29a-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="bd29a-225">Vytvoření vlastní směrované události</span><span class="sxs-lookup"><span data-stu-id="bd29a-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="bd29a-226">Přehled směrovaných událostí</span><span class="sxs-lookup"><span data-stu-id="bd29a-226">Routed Events Overview</span></span>](routed-events-overview.md)
