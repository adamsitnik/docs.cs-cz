---
title: Označení směrovaných událostí jako zpracovaných a zpracování tříd
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401641"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Označení směrovaných událostí jako zpracovaných a zpracování tříd
Obslužné rutiny směrované události mohou označovat událost zpracovanou v datech události. Zpracování události bude efektivně zkrátit trasu. Zpracování tříd je programovací pojem, který je podporován směrovanými událostmi. Obslužná rutina třídy má příležitost zpracovat konkrétní směrovanou událost na úrovni třídy pomocí obslužné rutiny, která je vyvolána před jakoukoliv obslužnou rutinou instance v jakékoli instanci třídy.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Požadavky  
 Toto téma se seznámí s koncepty představenými v [přehledu směrovaných událostí](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Kdy označit události jako zpracovávané  
 Při nastavení hodnoty <xref:System.Windows.RoutedEventArgs.Handled%2A> vlastnosti na `true` hodnotu v datech události pro směrovanou událost se označuje jako "označení události, která se zpracovává". Neexistuje žádné absolutní pravidlo, pokud byste měli označit směrované události jako zpracovávané, buď jako autora aplikace, nebo jako autor ovládacího prvku, který reaguje na stávající směrované události nebo implementuje nové směrované události. Ve většině případů by koncept "zpracovávaný" byl v datech události směrované události použit jako omezený protokol pro vlastní odpovědi aplikace na různé směrované události vystavené v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] rozhraních API a také pro všechny vlastní směrované události. Dalším způsobem, jak vzít v úvahu "zpracovávaný" problém, je, že byste měli obecně označit směrovanou událost, která je zpracována, pokud kód odpověděl na směrovanou událost významným a relativně úplným způsobem. Obvykle by neměla existovat více než jedna významná odpověď, která vyžaduje samostatné implementace obslužných rutin pro každý výskyt události s jedním směrováním. Je-li zapotřebí více odpovědí, je nutné implementovat potřebný kód prostřednictvím logiky aplikace, která je zřetězena v rámci jedné obslužné rutiny, nikoli pomocí směrovaného systému událostí pro přesměrování. Pojem "značný" je také subjektivní a závisí na vaší aplikaci nebo kódu. Obecně platí, že některé "významné reakce" jsou například: nastavení fokusu, změna veřejného stavu, nastavení vlastností, které ovlivňují vizuální znázornění a vyvolání dalších nových událostí. Mezi příklady nepodstatných odpovědí patří: Změna privátního stavu (bez vizuálního dopadu nebo programové rereprezentace), protokolování událostí nebo prohlížení argumentů události a volba nereakce na ni.  
  
 Chování směrovaného systému událostí posiluje tento model "významná reakce" pro použití zpracovaného stavu směrované události, protože obslužné rutiny, které [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] jsou přidány v nástroji nebo <xref:System.Windows.UIElement.AddHandler%2A> společný podpis, nejsou vyvolány v reakci na směrovanou událost, kde událost data jsou již označena jako zpracovaná. Aby bylo možné zpracovávat směrované události, které jsou označeny předchozími účastníky `handledEventsToo` v trase<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>události, je nutné projít další úsilím o přidání obslužné rutiny s verzí parametru ().  
  
 V některých případech ovládací prvky samy označují určité směrované události jako zpracovávané. Zpracovaná směrovaná událost představuje rozhodnutí na základě [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] autorů ovládacích prvků, že akce ovládacího prvku v reakci na směrovanou událost jsou významné nebo dokončené jako součást implementace ovládacího prvku a událost nepotřebuje žádné další zpracování. Obvykle je to provedeno přidáním obslužné rutiny třídy pro událost nebo přepsáním jedné z virtuálních obslužných rutin třídy, které existují v základní třídě. V případě potřeby můžete toto zpracování událostí dál obejít; Další informace najdete v tématu [práce s potlačením událostí pomocí ovládacích prvků](#WorkingAroundEventSuppressionByControls) dále v tomto tématu.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Události Preview (TUNELING) vs. Šíření událostí a zpracování událostí  
 Směrované události ve verzi Preview jsou události, které následují po tunelové trase prostřednictvím stromu elementu. "Preview" vyjádřená v konvenci pojmenování je orientační obecné zásady pro vstupní události, které směrované události ve verzi Preview (TUNELING) jsou vyvolány před ekvivalentní událostí směrovaného probublávání. Vstupní směrované události, které mají dvojici tunelování a probublávání, mají také zvláštní logiku zpracování. Pokud je nasměrovaná událost tunelového propojení/náhledu označena jako zpracovávaná naslouchacím programem událostí, pak bude směrované směrná událost označena jako zpracovaná, a to i před tím, než přijme všechny posluchače směrované směrované události. Směrované tunelování a probublávání směrované události jsou technicky samostatné události, ale záměrně sdílejí stejnou instanci dat událostí, aby bylo možné toto chování povolit.  
  
 Propojení mezi tunelovým propojením a směrovanými událostmi je provedeno interní implementací způsobu, jakým daná [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] třída vyvolává své vlastní deklarované směrované události a jedná se o true pro spárované vstupní směrované události. Pokud však tato implementace na úrovni třídy neexistuje, neexistuje spojení mezi událostí směrované tunelování a probublávání směrované události, která sdílí schéma pojmenování: bez takové implementace by by byly dvě zcela oddělené směrované události a nemusely být vyvoláno v pořadí nebo sdílet data události.  
  
 Další informace o tom, jak implementovat dvojice událostí směrovaného tunelového propojení nebo bublinového vstupu ve vlastní třídě, najdete v tématu [Vytvoření vlastní směrované události](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Obslužné rutiny tříd a obslužné rutiny instancí  
 Směrované události uvažují dva různé typy posluchačů k události: naslouchací procesy tříd a naslouchací procesy instancí. Naslouchací procesy tříd existují, protože typy se nazývají <xref:System.Windows.EventManager> konkrétní rozhraní<xref:System.Windows.EventManager.RegisterClassHandler%2A>API,, ve svém statickém konstruktoru nebo přepsaly virtuální metodu obslužné rutiny třídy z základní třídy elementu. Naslouchací procesy instance jsou konkrétní instance nebo prvky třídy, kde byl k této směrované události připojen jeden nebo více obslužných rutin voláním <xref:System.Windows.UIElement.AddHandler%2A>. Stávající [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] směrované události <xref:System.Windows.UIElement.AddHandler%2A> volají jako součást obálky událostí modulu CLR (Common Language Runtime) přidání{} a odebrání{} implementací události, což je také způsob, jakým je jednoduchý [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanismus Připojení obslužných rutin událostí prostřednictvím syntaxe atributu je povoleno. Proto i jednoduché [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] použití je nakonec rovno <xref:System.Windows.UIElement.AddHandler%2A> volání.  
  
 Prvky ve vizuálním stromu jsou zkontrolovány pro registrované implementace obslužných rutin. Obslužné rutiny jsou potenciálně vyvolány v rámci trasy, v pořadí, které je podstatou typu strategie směrování pro tuto směrovanou událost. Například probublávání směrované události nejprve vyvolá tyto obslužné rutiny, které jsou připojeny ke stejnému prvku, který vyvolal směrovanou událost. Pak směrované událost "bubliny" na další nadřazený prvek a tak dále, dokud není dosaženo kořenového prvku aplikace.  
  
 Z perspektivy kořenového prvku v trase šíření, pokud zpracování tříd nebo libovolný prvek blíže zdroji směrované události vyvolávají obslužné rutiny, které označují argumenty události jako zpracovávané, nejsou vyvolány obslužné rutiny kořenových elementů a směrování událostí. je účinně zkrácen před dosažením tohoto kořenového prvku. Nicméně trasa není zcela zastavena, protože obslužné rutiny lze přidat pomocí zvláštního podmíněného řízení, které by měly být vyvolány i v případě, že obslužná rutina třídy nebo obslužná rutina instance označila směrovanou událost jako zpracovanou. To je vysvětleno v tématu [Přidání obslužných rutin instance, které jsou vyvolány, i když jsou události označeny jako zpracované](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), dále v tomto tématu.  
  
 Na hlubší úrovni než v případě trasy události, existuje také potenciálně více obslužných rutin třídy působících na jakékoli dané instanci třídy. Důvodem je, že model zpracování tříd pro směrované události umožňuje všem možným třídám v hierarchii tříd pro každou směrovanou událost zaregistrovat svoji vlastní obslužnou rutinu třídy. Každá obslužná rutina třídy je přidána do interního úložiště a při sestavení trasy události pro aplikaci jsou všechny obslužné rutiny třídy přidány do trasy události. Obslužné rutiny třídy jsou přidány do trasy tak, že je nejprve vyvolána největší odvozená třída a obslužné rutiny třídy z každé následující základní třídy jsou vyvolány v dalším. Obecně nejsou obslužné rutiny tříd registrovány tak, že reagují na směrované události, které již byly označeny jako zpracované. Proto tento mechanismus manipulace třídy umožňuje jednu ze dvou možností:  
  
- Odvozené třídy mohou doplňovat zpracování tříd, která je zděděna ze základní třídy přidáním obslužné rutiny, která neoznačuje zpracování směrované události, protože obslužná rutina základní třídy bude vyvolána každou za každou za obslužnou rutinu odvozené třídy.  
  
- Odvozené třídy mohou nahradit zpracování tříd ze základní třídy přidáním obslužné rutiny třídy, která označuje zpracování směrované události. Měli byste být opatrní s tímto přístupem, protože bude potenciálně měnit zamýšlený návrh základního ovládacího prvku v oblastech, jako je vizuální vzhled, stavová logika, zpracování vstupu a zpracování příkazů.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Zpracování tříd směrovaných událostí pomocí základních tříd ovládacích prvků  
 U každého daného uzlu elementu v trase události mají naslouchací procesy třídy možnost reagovat na směrovanou událost před tím, než může kterýkoli naslouchací proces instancí elementu. Z tohoto důvodu obslužné rutiny třídy jsou někdy použity pro potlačení směrovaných událostí, které konkrétní implementace třídy ovládacího prvku nechce rozšířit další, nebo pro poskytnutí speciálního zpracování této směrované události, která je funkcí třídy. Například třída může vyvolat svou vlastní událost specifickou pro třídu, která obsahuje konkrétnější informace o tom, co některá podmínka vstupu uživatele znamená v kontextu této konkrétní třídy. Implementace třídy pak může označit obecnější směrované události jako zpracovávané. Obslužné rutiny třídy jsou obvykle přidány tak, že nejsou vyvolány pro směrované události, kde již byla označena zpracovaná data události, ale v případě netypických případů existuje i <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpis, který zaregistruje obslužné rutiny tříd k vyvolání, i když jsou směrované události označeno jako zpracované.  
  
### <a name="class-handler-virtuals"></a>Virtuální obslužné rutiny třídy  
 Některé prvky, zejména základní prvky <xref:System.Windows.UIElement>, jako je, vystavení prázdné "on *" událost "a" událost náhledu\*události ", které odpovídají jejich seznamu veřejných směrovaných událostí. Tyto virtuální metody lze přepsat pro implementaci obslužné rutiny třídy pro tuto směrovanou událost. Základní třídy prvků registrují tyto virtuální metody jako obslužné rutiny třídy pro každou takovou směrovanou událost <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> pomocí postupu popsaného výše. Virtuální metody\*události on zjednodušují implementaci zpracování tříd pro příslušné směrované události, aniž by vyžadovaly speciální inicializaci ve statických konstruktorech pro každý typ. Například můžete přidat zpracování tříd pro <xref:System.Windows.UIElement.DragEnter> událost v libovolné <xref:System.Windows.UIElement> <xref:System.Windows.UIElement.OnDragEnter%2A> odvozené třídy přepsáním virtuální metody. V rámci přepsání můžete zpracovat směrovanou událost, vyvolat další události, iniciovat logiku specifickou pro třídu, která může měnit vlastnosti prvku na instancích nebo jakoukoli kombinaci těchto akcí. Obecně byste měli volat základní implementaci v takových přepsáních i v případě, že označíte událost, která je zpracována. Důrazně doporučujeme volání základní implementace, protože virtuální metoda je na základní třídě. Standardní chráněný virtuální model pro volání základních implementací z každého virtuálního v podstatě nahrazuje a paralelně podobný mechanizmus, který je nativní pro směrování zpracování tříd událostí, přičemž obslužné rutiny třídy pro všechny třídy v hierarchii tříd jsou volá se na všech daných instancích počínaje obslužnou rutinou nejvyšší odvozené třídy a pokračuje se obslužnou rutinou základní třídy. Je nutné vynechat volání základní implementace pouze v případě, že vaše třída má záměrné požadavky na změnu logiky zpracování základní třídy. Bez ohledu na to, zda zavoláte základní implementaci před nebo po přepsání kódu, bude záviset na povaze vaší implementace.  
  
#### <a name="input-event-class-handling"></a>Zpracování třídy událostí vstupu  
 Virtuální metody obslužné rutiny třídy jsou všechny zaregistrované tak, aby se vyvolaly jenom v případech, kdy všechna sdílená data událostí ještě nejsou označená jako zpracovaná. V případě jedinečnosti vstupních událostí jsou také tunelování a šíření verzí obvykle vyvolány v sekvenci a sdílejí data události. To má za následek, že pro danou dvojici obslužných rutin třídy vstupních událostí, kde jedna je verze tunelování a druhá je probublávání verze, nechcete, aby byla událost zpracována okamžitě. Pokud implementujete metodu tunelování pro zpracování virtuální metody k označení zpracování události, která zabrání vyvolání obslužné rutiny třídy (a také zabránění jakýmkoli normálně registrovaným obslužným rutinám instance pro událost tunelového propojení nebo probublávání z je vyvoláno).  
  
 Jakmile je zpracování třídy na uzlu dokončeno, jsou považovány za naslouchací procesy instance.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Přidání obslužných rutin instancí, které jsou vyvolány, i když jsou události označeny jako zpracované  
 <xref:System.Windows.UIElement.AddHandler%2A> Metoda poskytuje konkrétní přetížení, které umožňuje přidat obslužné rutiny, které budou vyvolány systémem událostí vždy, když událost dosáhne elementu manipulace v trase, a to i v případě, že nějaká jiná obslužná rutina již upravila data události k označení toho, že událost je zpracována. To se obvykle neprovádí. Obecně lze obslužné rutiny zapsat pro úpravu všech oblastí kódu aplikace, které mohou být ovlivněny událostí, bez ohledu na to, kde byly zpracovány ve stromové struktuře elementu, i když je požadováno více konečných výsledků. Také obvykle existuje pouze jeden prvek, který musí na tuto událost reagovat, a příslušná logika aplikace již proběhla. `handledEventsToo` Ale přetížení je k dispozici pro výjimečné případy, kdy některý jiný prvek ve stromové struktuře elementu nebo skládání ovládacího prvku již označil událost jako zpracovanou, ale jiné prvky ve stromové struktuře elementu (v závislosti na trase) ještě vyšší nebo nižší. chtějí mít vyvolané vlastní obslužné rutiny.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Kdy označit zpracovávané události jako neošetřené  
 Obecně směrované události, které jsou označeny jako zpracované, by neměly být označeny jako neošetřené<xref:System.Windows.RoutedEventArgs.Handled%2A> ( `false`nastavení zpět na), a to `handledEventsToo`i pomocí obslužných rutin, které fungují. Nicméně některé vstupní události mají na vysoké úrovni a reprezentace událostí nižší úrovně, které se mohou překrývat, pokud se událost vysoké úrovně zobrazuje na jedné pozici stromu a událost nízké úrovně na jiné pozici. Zvažte například případ, kdy podřízený prvek naslouchá události klíče vysoké úrovně, například <xref:System.Windows.UIElement.TextInput> když nadřazený prvek naslouchá události nízké úrovně, jako je <xref:System.Windows.UIElement.KeyDown>například. Pokud nadřazený element zpracovává událost nízké úrovně, může být událost vyšší úrovně potlačena i v podřízeném elementu, který by intuitivní by měl mít první příležitost zpracovat událost.  
  
 V těchto situacích může být nutné přidat obslužné rutiny do nadřazených prvků a podřízených prvků pro událost nízké úrovně. Implementace obslužné rutiny podřízeného elementu může označit událost nízké úrovně jako zpracovanou, ale implementace obslužné rutiny nadřazeného elementu by ji znovu nastavila tak, aby další prvky stromu (stejně jako událost vysoké úrovně) mohly mít možnost reagovat. Tato situace by měla být poměrně zřídka.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Úmyslné potlačení vstupních událostí pro skládání ovládacích prvků  
 Hlavní scénář, ve kterém se používá zpracování tříd směrovaných událostí, je pro vstupní události a složené ovládací prvky. Složený ovládací prvek je podle definice tvořená několika praktickými ovládacími prvky nebo řídicími základními třídami. Autor ovládacího prvku často chce amalgamate všechny možné vstupní události, které mohou vyvolat jednotlivé dílčí komponenty, aby bylo možné nahlásit celý ovládací prvek jako jednotný zdroj událostí. V některých případech může autor ovládacího prvku chtít potlačit události z komponent zcela nebo nahradit událost definovanou komponentou, která poskytuje další informace nebo implikuje konkrétnější chování. Kanonický příklad, který je okamžitě viditelný pro všechny autory komponenty, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] je způsob, jakým <xref:System.Windows.Controls.Button> událost myši, která bude nakonec přeložena na intuitivní událost, která <xref:System.Windows.Controls.Primitives.ButtonBase.Click> má všechna tlačítka: událost.  
  
 <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement> <xref:System.Windows.Controls.Control> <xref:System.Windows.UIElement> Základní třída (<xref:System.Windows.Controls.Primitives.ButtonBase>) je odvozena z toho, ze které se dále odvozují a a většina infrastruktury událostí potřebná pro zpracování vstupu řízení je k dispozici na úrovni. <xref:System.Windows.Controls.Button> Konkrétně <xref:System.Windows.UIElement> zpracovává obecné <xref:System.Windows.Input.Mouse> události, které zpracovávají testy přístupů pro ukazatel myši v rámci jeho hranic, a poskytuje odlišné události pro nejběžnější akce <xref:System.Windows.UIElement.MouseLeftButtonDown>tlačítek, jako je například. <xref:System.Windows.UIElement>poskytuje také prázdný virtuální <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako obslužnou rutinu pro předregistrovanou třídu pro <xref:System.Windows.UIElement.MouseLeftButtonDown>a <xref:System.Windows.Controls.Primitives.ButtonBase> Přepisuje ji. Podobně používá obslužné rutiny třídy <xref:System.Windows.UIElement.MouseLeftButtonUp>pro. <xref:System.Windows.Controls.Primitives.ButtonBase> V přepsáních, kterým jsou předány data události, implementace označí tuto <xref:System.Windows.RoutedEventArgs> instanci jako zpracovanou nastavením <xref:System.Windows.RoutedEventArgs.Handled%2A> na `true`a stejnou data události je to, co pokračuje ve zbývající části trasy na jiné obslužné rutiny tříd a také obslužné rutiny instance nebo metody pro navýšení události. Přepsání také příště <xref:System.Windows.Controls.Primitives.ButtonBase.Click> vyvolá událost. <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> Konečný výsledek pro většinu posluchačů bude, že <xref:System.Windows.UIElement.MouseLeftButtonDown> události a <xref:System.Windows.UIElement.MouseLeftButtonUp> jsou "zmizí" <xref:System.Windows.Controls.Primitives.ButtonBase.Click>a místo toho jsou nahrazeny událostí, která má větší význam, protože tato událost pochází z tlačítka true a nikoli některých. složená část tlačítka nebo z nějakého jiného prvku zcela.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Práce s potlačením událostí pomocí ovládacích prvků  
 V některých případech může toto chování při potlačení události v rámci jednotlivých ovládacích prvků narušit s některými obecnější záměry logiky zpracování událostí pro vaši aplikaci. Například pokud z nějakého důvodu má aplikace obslužnou rutinu pro <xref:System.Windows.UIElement.MouseLeftButtonDown> umístění v kořenovém elementu aplikace, všimnete si, že jakékoli kliknutí myší na tlačítko by nebylo možné vyvolat <xref:System.Windows.UIElement.MouseLeftButtonDown> nebo <xref:System.Windows.UIElement.MouseLeftButtonUp> obslužné rutiny na kořenové úrovni. Vlastní událost sama provedla bublinu (znovu, trasy událostí nejsou ve skutečnosti ukončeny, ale směrovaný systém událostí po označení zpracování změní jejich chování volání obslužných rutin. Když směrované událost dosáhla tlačítka, <xref:System.Windows.Controls.Primitives.ButtonBase> zpracovává zpracování třídy označené jako zpracované, <xref:System.Windows.UIElement.MouseLeftButtonDown> protože <xref:System.Windows.Controls.Primitives.ButtonBase.Click> chtěla nahradit událost větším významem. Proto by se žádná <xref:System.Windows.UIElement.MouseLeftButtonDown> standardní obslužná rutina dále vyvolala. Existují dva postupy, které můžete použít k zajištění toho, aby byly obslužné rutiny vyvolány v této situaci.  
  
 Prvním postupem je úmyslné přidání obslužné rutiny pomocí `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>signatury. Omezení tohoto přístupu je, že tato technika pro připojení obslužné rutiny události je možné pouze z kódu, nikoli z značek. Jednoduchá syntaxe zadání názvu obslužné rutiny události jako hodnoty atributu události prostřednictvím [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] nepovoluje toto chování.  
  
 Druhá technika funguje pouze pro vstupní události, kde jsou párovány verze tunelování a šíření směrovaných událostí. Pro tyto směrované události můžete místo toho přidat obslužné rutiny do ekvivalentní směrované události verze Preview/Tunneling. Tato směrované událost bude tunelem směrována z kořenového adresáře, takže kód pro zpracování třídy tlačítka by ho nezachytil, předpokládá se, že jste připojili obslužnou rutinu Preview na některé úrovni nadřazeného prvku ve stromu prvků aplikace. Pokud použijete tento přístup, buďte opatrní při označování všech zpracovaných událostí ve verzi Preview. Pro příklad zadaný <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> při zpracovávání u kořenového prvku, pokud jste označili událost jako <xref:System.Windows.RoutedEventArgs.Handled%2A> v implementaci obslužné rutiny, byste <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událost skutečně potlačili. To obvykle není žádoucí chování.  
  
## <a name="see-also"></a>Viz také:

- <xref:System.Windows.EventManager>
- [Události náhledu](preview-events.md)
- [Vytvoření vlastní směrované události](how-to-create-a-custom-routed-event.md)
- [Přehled směrovaných událostí](routed-events-overview.md)
