---
title: Model vláken
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: da9eaf127a4db02cddbb36e53a0d0ddb5b28b841
ms.sourcegitcommit: 10736f243dd2296212e677e207102c463e5f143e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/06/2019
ms.locfileid: "68818047"
---
# <a name="threading-model"></a><span data-ttu-id="e7ac5-102">Model vláken</span><span class="sxs-lookup"><span data-stu-id="e7ac5-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="e7ac5-103">je navržena pro ukládání vývojářů z potíží s vlákny.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="e7ac5-104">V důsledku toho většina [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] vývojářů nebude muset psát rozhraní, které používá více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="e7ac5-105">Vzhledem k tomu, že programy s více vlákny jsou složité a obtížné je ladit, měli byste se jim vyhnout v případě existence řešení s jedním vláknem.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="e7ac5-106">Bez ohledu na to, jak to bylo navrženo [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , ale žádné rozhraní nikdy nebude moci poskytnout řešení s jedním vláknem pro každý problém.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="e7ac5-107">je blízko, ale stále existují situace, kdy více vláken vylepšuje [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] odezvu nebo výkon aplikace.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="e7ac5-108">Po prozkoumání některých materiálů se v tomto dokumentu prozkoumá některé z těchto situací a pak se dokončí diskuzí o některých podrobnostech nižší úrovně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  

> [!NOTE]
>  <span data-ttu-id="e7ac5-109">Toto téma popisuje dělení na <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> vlákna pomocí metody pro asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="e7ac5-110">Můžete také provést asynchronní volání voláním <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> metody, která <xref:System.Action> přijímá nebo <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="e7ac5-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> Metoda vrátí<xref:System.Windows.Threading.DispatcherOperation.Task%2A> nebo ,<xref:System.Windows.Threading.DispatcherOperation%601>která má vlastnost. <xref:System.Windows.Threading.DispatcherOperation></span><span class="sxs-lookup"><span data-stu-id="e7ac5-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="e7ac5-112">`await` Klíčové slovo lze použít buď s přidruženým <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Threading.Tasks.Task>, nebo.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="e7ac5-113">Pokud potřebujete počkat synchronně <xref:System.Threading.Tasks.Task> pro, který je vrácený <xref:System.Windows.Threading.DispatcherOperation> nebo <xref:System.Windows.Threading.DispatcherOperation%601>, zavolejte <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> metodu rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="e7ac5-114">Volání <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> způsobí zablokování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="e7ac5-115">Další informace o použití nástroje <xref:System.Threading.Tasks.Task> k provedení asynchronních operací naleznete v tématu Task paralelismus.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="e7ac5-116">Metoda má také přetížení, která <xref:System.Action> přijímají nebo <xref:System.Func%601> jako parametr. <xref:System.Windows.Threading.Dispatcher.Invoke%2A></span><span class="sxs-lookup"><span data-stu-id="e7ac5-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="e7ac5-117"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> Metodu lze použít k provádění synchronních volání předáním <xref:System.Action> delegáta nebo <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="e7ac5-118">Přehled a dispečer</span><span class="sxs-lookup"><span data-stu-id="e7ac5-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="e7ac5-119">Obvykle aplikace začínají dvěma vlákny: jeden pro zpracování vykreslování a další pro [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]správu. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e7ac5-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="e7ac5-120">Vykreslování vlákna efektivně běží na pozadí, zatímco [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno přijímá vstup, zpracovává události, vykreslí obrazovku a spouští kód aplikace.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="e7ac5-121">Většina aplikací používá jedno [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno, i když v některých případech je nejvhodnější použít několik.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="e7ac5-122">Budeme s tímto příkladem pojednávat později.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="e7ac5-123">Vlákno vyřadí pracovní položky do fronty v rámci objektu <xref:System.Windows.Threading.Dispatcher>s názvem. [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e7ac5-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="e7ac5-124"><xref:System.Windows.Threading.Dispatcher> Vybere pracovní položky na základě priority a každý z nich provede dokončení.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="e7ac5-125">Každé [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno musí mít alespoň jeden <xref:System.Windows.Threading.Dispatcher>a každý z nich <xref:System.Windows.Threading.Dispatcher> může spouštět pracovní položky v přesně jednom vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="e7ac5-126">Schopnost vytvářet reakce na uživatelsky přívětivé aplikace je maximalizovat <xref:System.Windows.Threading.Dispatcher> propustnost tím, že se pracovní položky podrží malými.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="e7ac5-127">Tímto způsobem se položky nikdy nevrátí do fronty <xref:System.Windows.Threading.Dispatcher> , která čeká na zpracování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="e7ac5-128">Jakékoli vnímané zpoždění mezi vstupem a odpovědí může frustrovat uživatele.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="e7ac5-129">Jak aplikace by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] pak měly zpracovávat velké operace?</span><span class="sxs-lookup"><span data-stu-id="e7ac5-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="e7ac5-130">Co když váš kód zahrnuje velký výpočet nebo potřebuje dotaz na databázi na některém vzdáleném serveru?</span><span class="sxs-lookup"><span data-stu-id="e7ac5-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="e7ac5-131">Obvykle je odpověď zpracovávat velkou operaci v samostatném vlákně, ale [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno je volné, aby bylo možné položky <xref:System.Windows.Threading.Dispatcher> ve frontě.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="e7ac5-132">Po dokončení velké operace může hlásit svůj výsledek zpátky do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna pro zobrazení.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="e7ac5-133">Historicky [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] umožňuje elementům přístup pouze pomocí vlákna, které je vytvořilo. [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e7ac5-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="e7ac5-134">To znamená, že vlákno na pozadí za určitou dlouhodobě běžící úlohu nemůže po dokončení aktualizovat textové pole.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="e7ac5-135">zajišťuje integritu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] komponent.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-135">does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="e7ac5-136">Seznam by mohl vypadat neobvyklý, pokud jeho obsah byl během Malování aktualizován vláknem na pozadí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="e7ac5-137">má vestavěný mechanismus vzájemného vyloučení, který tuto koordinaci vynutil.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="e7ac5-138">Většina tříd [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] je odvozena <xref:System.Windows.Threading.DispatcherObject>z.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="e7ac5-139">V konstrukci <xref:System.Windows.Threading.DispatcherObject> ukládá odkaz <xref:System.Windows.Threading.Dispatcher> na vazbu k aktuálně běžícímu vláknu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="e7ac5-140">V důsledku toho <xref:System.Windows.Threading.DispatcherObject> přidruží ke vláknu, který ho vytvořil.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="e7ac5-141">Během provádění <xref:System.Windows.Threading.DispatcherObject> programu může zavolat jeho veřejnou <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> metodu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="e7ac5-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>prověřuje <xref:System.Windows.Threading.Dispatcher> přidružení k aktuálnímu vláknu a porovná ho s odkazem uloženým během konstrukce. <xref:System.Windows.Threading.Dispatcher></span><span class="sxs-lookup"><span data-stu-id="e7ac5-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="e7ac5-143">Pokud se neshodují <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> , vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="e7ac5-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>má být volána na začátku každé metody patřící do <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="e7ac5-145">Pokud může upravit pouze jedno vlákno, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]jak vlákna na pozadí pracují s uživatelem?</span><span class="sxs-lookup"><span data-stu-id="e7ac5-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="e7ac5-146">Vlákno na pozadí může požádat [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno o provedení operace za jeho jménem.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="e7ac5-147">Provede to registrací pracovní položky s <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláknem.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-148">Třída poskytuje dvě metody pro registraci pracovních položek: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher></span><span class="sxs-lookup"><span data-stu-id="e7ac5-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="e7ac5-149">Obě metody naplánují delegáta pro spuštění.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="e7ac5-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>je synchronní volání – to znamená, že se nevrátí, dokud [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno dokončí provádění delegáta.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="e7ac5-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>je asynchronní a vrátí se okamžitě.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="e7ac5-152"><xref:System.Windows.Threading.Dispatcher> Seřadí prvky ve své frontě podle priority.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="e7ac5-153">Při přidávání elementu do <xref:System.Windows.Threading.Dispatcher> fronty je možné zadat deset úrovní.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="e7ac5-154">Tyto priority se udržují ve <xref:System.Windows.Threading.DispatcherPriority> výčtu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="e7ac5-155">Podrobné informace o <xref:System.Windows.Threading.DispatcherPriority> úrovních najdete [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] v dokumentaci.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="e7ac5-156">Vlákna v akci: Ukázky</span><span class="sxs-lookup"><span data-stu-id="e7ac5-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="e7ac5-157">Aplikace s jedním vláknem s dlouhodobou kalkulací</span><span class="sxs-lookup"><span data-stu-id="e7ac5-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="e7ac5-158">Většina grafických uživatelských rozhraní (GUI) stráví velkou část času nečinnosti při čekání na události, které jsou vygenerovány v reakci na interakci uživatele.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="e7ac5-159">S pečlivým programováním je možné tento čas nečinnosti použít, aniž by to ovlivnilo odezvu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e7ac5-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="e7ac5-160">Model vláken nepovoluje vstup k přerušení operace, která se odehrává [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ve vlákně. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e7ac5-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-161">To znamená, že musíte mít jistotu, že se <xref:System.Windows.Threading.Dispatcher> budete muset pravidelně vracet do procesu probíhajících vstupních událostí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="e7ac5-162">Vezměte v úvahu v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="e7ac5-162">Consider the following example:</span></span>  
  
 ![Snímek obrazovky, který zobrazuje vlákna z primárních čísel.](./media/threading-model/threading-prime-numbers.png)  
  
 <span data-ttu-id="e7ac5-164">Tato jednoduchá aplikace se počítá směrem nahoru od tří, hledá se čísla na apostrofech.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="e7ac5-165">Když uživatel klikne na tlačítko **Start** , hledání začne.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="e7ac5-166">Když program najde primární, aktualizuje uživatelské rozhraní jeho zjišťováním.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="e7ac5-167">V jakémkoli okamžiku může uživatel hledání zastavit.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="e7ac5-168">I když je dostatek jednoduchého, hledání na základě prvotních čísel by mohlo jít trvale, což představuje některé problémy.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="e7ac5-169">Pokud jsme celé vyhledávání poznamenali v obslužné rutině události Click tlačítka, nikdy neposkytneme [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno možnost zpracovávat jiné události.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="e7ac5-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] By nebylo možné reagovat na vstupní nebo procesní zprávy.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="e7ac5-171">Nikdy nepřekreslí a nikdy nereaguje na kliknutí na tlačítko.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="e7ac5-172">Hledání na primárním čísle můžeme provést v samostatném vlákně, ale musíme řešit problémy s synchronizací.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="e7ac5-173">S přístupem s jedním vláknem můžeme přímo aktualizovat popisek, který uvádí největší nalezené apostrofy.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="e7ac5-174">V případě, že úlohu výpočtu rozdělíte na spravovatelné bloky dat, můžeme se pravidelně vracet do <xref:System.Windows.Threading.Dispatcher> procesů a zpracovávat události.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="e7ac5-175">Můžeme předat [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] možnost překreslit a zpracovat vstup.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="e7ac5-176">Nejlepším způsobem, jak rozdělit dobu zpracování mezi výpočtem a zpracováním událostí, je spravovat výpočet <xref:System.Windows.Threading.Dispatcher>z.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="e7ac5-177">Pomocí <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metody můžeme naplánovat kontroly prvotních čísel ve stejné frontě, z níž [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] se události vykreslí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="e7ac5-178">V našem příkladu plánujeme vždy jenom jednu kontrolu primárního čísla.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="e7ac5-179">Po dokončení kontroly prvotního čísla naplánujeme další kontrolu hned.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="e7ac5-180">Tato kontrolu pokračuje až po zpracování [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nevyřízených událostí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 ![Snímek obrazovky, který zobrazuje frontu dispečera.](./media/threading-model/threading-dispatcher-queue.png)  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="e7ac5-182">provede kontrolu pravopisu pomocí tohoto mechanismu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-182">accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="e7ac5-183">Kontrola pravopisu se provádí na pozadí s použitím času [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nečinnosti vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-184">Pojďme se podívat na kód.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="e7ac5-185">Následující příklad ukazuje kód XAML, který vytváří uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="e7ac5-186">Následující příklad ukazuje kód na pozadí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="e7ac5-187">Následující příklad ukazuje obslužnou rutinu události pro <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="e7ac5-188">Kromě aktualizace textu na <xref:System.Windows.Controls.Button>, je tato obslužná rutina zodpovědná za plánování prvotní kontroly prvotních čísel přidáním delegáta <xref:System.Windows.Threading.Dispatcher> do fronty.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="e7ac5-189">Po dokončení <xref:System.Windows.Threading.Dispatcher> této obslužné rutiny události bude tento delegát vybrán pro spuštění.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="e7ac5-190">Jak jsme se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> <xref:System.Windows.Threading.Dispatcher> už dozvěděli dřív, je člen použitý k naplánování delegáta pro provádění.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="e7ac5-191">V tomto případě zvolíme <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> prioritu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="e7ac5-192">Spustí <xref:System.Windows.Threading.Dispatcher> tohoto delegáta pouze v případě, že neexistují žádné důležité události ke zpracování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="e7ac5-193">odezva je důležitější než Kontrola čísla.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="e7ac5-194">Také předáte novému delegátovi, který představuje rutinu pro kontrolu čísel.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="e7ac5-195">Tato metoda kontroluje, zda je následující liché číslo primární.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="e7ac5-196">Pokud je primární, metoda přímo aktualizuje rozhraní `bigPrime` <xref:System.Windows.Controls.TextBlock> tak, aby odráželo jeho zjišťování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="e7ac5-197">To můžeme udělat, protože výpočet se vyskytuje ve stejném vlákně, které jste použili k vytvoření komponenty.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="e7ac5-198">Zvolili jsme použití samostatného vlákna pro výpočet, musíme použít složitější synchronizační mechanismus a spustit aktualizaci ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-199">Tuto situaci si ukážeme dál.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="e7ac5-200">Úplný zdrojový kód pro tuto ukázku najdete v tématu [aplikace s jedním vláknem s ukázkou dlouho běžícího výpočtu](https://go.microsoft.com/fwlink/?LinkID=160038) .</span><span class="sxs-lookup"><span data-stu-id="e7ac5-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="e7ac5-201">Zpracování blokující operace s vláknem na pozadí</span><span class="sxs-lookup"><span data-stu-id="e7ac5-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="e7ac5-202">Manipulace s blokujícími operacemi v grafické aplikaci může být obtížné.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="e7ac5-203">Nechceme volat metody blokování z obslužných rutin událostí, protože se zdá, že se aplikace zablokuje.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="e7ac5-204">Pro zpracování těchto operací můžeme použít samostatné vlákno, ale po dokončení musíme synchronizaci s [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláknem, protože nemůžeme přímo změnit grafické uživatelské rozhraní z našeho pracovního vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="e7ac5-205">Můžeme použít <xref:System.Windows.Threading.Dispatcher.Invoke%2A> nebo <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> provkládání[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] delegátů do vlákna.<xref:System.Windows.Threading.Dispatcher></span><span class="sxs-lookup"><span data-stu-id="e7ac5-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-206">Nakonec se tyto delegáty spustí s oprávněním pro úpravu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] prvků.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="e7ac5-207">V tomto příkladu Napodobme vzdálené volání procedur, které načte předpověď počasí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="e7ac5-208">K provedení tohoto volání používáme samostatné pracovní vlákno a při dokončení naplánujeme metodu aktualizace ve <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 ![Snímek obrazovky zobrazující uživatelské rozhraní počasí](./media/threading-model/threading-weather-ui.png)  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="e7ac5-210">Níže jsou uvedeny některé podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-210">The following are some of the details to be noted.</span></span>  
  
- <span data-ttu-id="e7ac5-211">Vytvoření obslužné rutiny tlačítka</span><span class="sxs-lookup"><span data-stu-id="e7ac5-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="e7ac5-212">Po kliknutí na tlačítko zobrazíme vykreslování hodin a začnete ho animovat.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="e7ac5-213">Zakážeme toto tlačítko.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-213">We disable the button.</span></span> <span data-ttu-id="e7ac5-214">`FetchWeatherFromServer` Metodu vyvolá v novém vlákně a potom se vrátíme a <xref:System.Windows.Threading.Dispatcher> umožníme zpracování událostí během čekání na shromáždění předpovědi počasí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
- <span data-ttu-id="e7ac5-215">Načítají se počasí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="e7ac5-216">V tomto příkladu nemáme v tomto příkladu žádný kód sítě.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="e7ac5-217">Místo toho simulujeme zpoždění přístupu k síti tím, že jsme nové vlákno umístili do režimu spánku po dobu čtyř sekund.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="e7ac5-218">V tuto chvíli je původní [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno pořád spuštěné a reaguje na události.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="e7ac5-219">Pokud to chcete zobrazit, opustili jsme animaci spuštěnou a tlačítky minimalizovat a maximalizovat i nadále fungují.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="e7ac5-220">Až se zpoždění dokončí a my jsme náhodně vybrali naši předpověď počasí, je čas nahlásit zpět do [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-221">Provedeme to naplánováním volání `UpdateUserInterface` [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ve <xref:System.Windows.Threading.Dispatcher>vlákně pomocí tohoto vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="e7ac5-222">Předáte řetězec popisující počasí k tomuto plánovanému volání metody.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
- <span data-ttu-id="e7ac5-223">Aktualizuje se[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e7ac5-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="e7ac5-224">Pokud má [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno `UpdateUserInterface`ve vlákně čas, spustí plánované volání. <xref:System.Windows.Threading.Dispatcher></span><span class="sxs-lookup"><span data-stu-id="e7ac5-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="e7ac5-225">Tato metoda zastaví animaci hodin a vybere obrázek pro popis počasí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="e7ac5-226">Zobrazuje tento obrázek a obnoví tlačítko "vyhodnotit předpověď".</span><span class="sxs-lookup"><span data-stu-id="e7ac5-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="e7ac5-227">Více oken, více vláken</span><span class="sxs-lookup"><span data-stu-id="e7ac5-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="e7ac5-228">Některé [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace vyžadují více oken nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="e7ac5-229">Je zcela přijatelné pro jedno vlákno nebo<xref:System.Windows.Threading.Dispatcher> kombinaci ke správě více oken, ale někdy několik vláken má lepší úlohu.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="e7ac5-230">To platí zejména v případě, že existuje možnost, že jedno z oken bude monopolizovat vlákno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="e7ac5-231">Průzkumník funguje tímto způsobem.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-231">Explorer works in this fashion.</span></span> <span data-ttu-id="e7ac5-232">Každé nové okno Průzkumníka patří původnímu procesu, ale je vytvořeno pod kontrolou nezávislého vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="e7ac5-233">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Pomocí<xref:System.Windows.Controls.Frame> ovládacího prvku můžeme zobrazit webové stránky.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="e7ac5-234">Snadno se dá vytvořit jednoduchá náhrada z Internet Exploreru.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="e7ac5-235">Začneme s důležitou funkcí: možnost otevřít nové okno Průzkumníka.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="e7ac5-236">Když uživatel klikne na tlačítko "nové okno", spustíme kopii našeho okna v samostatném vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="e7ac5-237">Tímto způsobem dlouho běžící nebo blokující operace v jednom z oken nezamkne všechna ostatní okna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="e7ac5-238">Ve skutečnosti má model webového prohlížeče svůj vlastní složitý model vláken.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="e7ac5-239">Zvolili jsme to proto, že by měl být známý pro většinu čtenářů.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="e7ac5-240">Následující příklad ukazuje kód.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="e7ac5-241">Následující segmenty vlákna tohoto kódu jsou pro nás v tomto kontextu nejzajímavější:</span><span class="sxs-lookup"><span data-stu-id="e7ac5-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="e7ac5-242">Tato metoda je volána při kliknutí na tlačítko "nové okno".</span><span class="sxs-lookup"><span data-stu-id="e7ac5-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="e7ac5-243">Vytvoří nové vlákno a spustí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="e7ac5-244">Tato metoda je výchozím bodem pro nové vlákno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="e7ac5-245">Pod kontrolou tohoto vlákna vytvoříme nové okno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="e7ac5-246">automaticky vytvoří nový <xref:System.Windows.Threading.Dispatcher> pro správu nového vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="e7ac5-247">K tomu, aby bylo okno funkční, je třeba spustit <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="e7ac5-248">Technické podrobnosti a body Stumbling</span><span class="sxs-lookup"><span data-stu-id="e7ac5-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="e7ac5-249">Zápis komponent pomocí dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="e7ac5-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="e7ac5-250">Příručka pro vývojáře Microsoft .NET Framework popisuje vzor, jak může komponenta vystavovat asynchronní chování svým klientům (viz [Přehled asynchronních vzorů založených na událostech](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="e7ac5-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="e7ac5-251">Předpokládejme například, že jsme chtěli zabalit `FetchWeatherFromServer` metodu do opakovaně použitelné, negrafované komponenty.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="e7ac5-252">Po standardním vzoru Microsoft .NET Framework by to vypadalo podobně jako v následujícím.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="e7ac5-253">`GetWeatherAsync`použije jeden z výše popsaných postupů, jako je například vytvoření vlákna na pozadí pro asynchronní práci bez blokování volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="e7ac5-254">Jednou z nejdůležitějších částí tohoto modelu je volání metody *methodName* `Completed` ve stejném vlákně, které volalo metodu *methodName* `Async` , která začíná na.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="e7ac5-255">To [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] lze provést poměrně snadno, protože je uložíte <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>, ale negrafickou komponentu lze použít pouze v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikacích, nikoli v [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] aplikacích nebo ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET programs.</span></span>  
  
 <span data-ttu-id="e7ac5-256">Třída tuto potřebu řeší – považuje se za zjednodušenou <xref:System.Windows.Threading.Dispatcher> verzi nástroje, která funguje i v [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] jiných architekturách. <xref:System.Windows.Threading.DispatcherSynchronizationContext></span><span class="sxs-lookup"><span data-stu-id="e7ac5-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="e7ac5-257">Vnořená pumpa</span><span class="sxs-lookup"><span data-stu-id="e7ac5-257">Nested Pumping</span></span>  
 <span data-ttu-id="e7ac5-258">V [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] některých případech není možné vlákno kompletně uzamknout.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-259">Pojďme vzít v <xref:System.Windows.MessageBox.Show%2A> úvahu metodu <xref:System.Windows.MessageBox> třídy.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="e7ac5-260"><xref:System.Windows.MessageBox.Show%2A>nevrátí se, dokud uživatel neklikne na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="e7ac5-261">Ale vytvoří okno, které musí mít smyčku zpráv, aby mohla být interaktivní.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="e7ac5-262">Čekáme na to, až uživatel klikne na tlačítko OK, původní okno aplikace nereaguje na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="e7ac5-263">Ale i nadále zpracovává zprávy o malování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="e7ac5-264">Původní okno se překreslí samostatně, pokud je zahrnuto a odhaleno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-264">The original window redraws itself when covered and revealed.</span></span>  
  
 ![Snímek obrazovky, který zobrazuje MessageBox s tlačítkem OK](./media/threading-model/threading-message-loop.png)  
  
 <span data-ttu-id="e7ac5-266">U některých vláken se musí nacházet okno se zprávou.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="e7ac5-267">může vytvořit nové vlákno pouze pro okno se zprávou, ale toto vlákno nebude moci vykreslit zakázané prvky do původního okna (zapamatujte si předchozí diskuzi na vzájemné vyloučení).</span><span class="sxs-lookup"><span data-stu-id="e7ac5-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="e7ac5-268">Místo toho [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] používá vnořený systém zpracování zpráv.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="e7ac5-269">Třída obsahuje speciální metodu s názvem <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, která ukládá aktuální bod spuštění aplikace a následně zahájí novou smyčku zpráv. <xref:System.Windows.Threading.Dispatcher></span><span class="sxs-lookup"><span data-stu-id="e7ac5-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="e7ac5-270">Po dokončení vnořené smyčky zpráv bude spuštění pokračovat po původním <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="e7ac5-271">V tomto případě <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> udržuje kontext programu při <xref:System.Windows.MessageBox>volání metody.<xref:System.Windows.MessageBox.Show%2A>a spustí novou smyčku zprávy pro překreslení okna na pozadí a zpracování vstupu do okna se zprávou.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="e7ac5-272">Když uživatel klikne na tlačítko OK a vymaže automaticky otevírané okno, vnořená smyčka skončí a řízení pokračuje po volání <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="e7ac5-273">Zastaralé směrované události</span><span class="sxs-lookup"><span data-stu-id="e7ac5-273">Stale Routed Events</span></span>  
 <span data-ttu-id="e7ac5-274">Systém směrovaného Event v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nástroji upozorní celé stromy na vyvolání událostí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="e7ac5-275">Po stisknutí levého tlačítka myši na elipsu `handler2` se spustí.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="e7ac5-276">Po `handler2` dokončení se událost předává spolu <xref:System.Windows.Controls.Canvas> s objektem, který používá `handler1` ke zpracování.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="e7ac5-277">K tomu dojde pouze `handler2` v případě, že objekt události explicitně neoznačí jako zpracovávaný.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="e7ac5-278">Je možné, že `handler2` bude trvat značnou dobu zpracování této události.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="e7ac5-279">`handler2`může použít <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> k zahájení vnořené smyčky zpráv, která se nevrátí na hodiny.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="e7ac5-280">Pokud `handler2` aplikace neoznačí událost jako zpracovanou, když je tato smyčka dokončená, událost se předá do stromu, i když je to hodně staré.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="e7ac5-281">Vícenásobný přístup a uzamykání</span><span class="sxs-lookup"><span data-stu-id="e7ac5-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="e7ac5-282">Blokovací mechanizmus modulu CLR (Common Language Runtime) se chová přesně tak, jak je možné ho představit. může se stát, že vlákno ukončí operaci kompletně při požadavku na zámek.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="e7ac5-283">Ve skutečnosti vlákno nadále přijímá a zpracovává zprávy s vysokou prioritou.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="e7ac5-284">To pomáhá zabránit zablokování a dávat rozhraní s minimální odezvou, ale zavádí možnost drobných chyb.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="e7ac5-285">Velká většina času, o které nepotřebujete nic vědět, ale za výjimečných okolností (obvykle zahrnující [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] zprávy oken nebo komponenty modelu COM STA) to může být velmi důležité.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="e7ac5-286">Většina rozhraní není sestavena s ohledem na bezpečnost vlákna, protože vývojáři pracují s předpokladem, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] že k přístupu nikdy nemá přístup více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="e7ac5-287">V takovém případě může toto jediné vlákno provádět změny v prostředí v neočekávaných časech, což způsobuje, <xref:System.Windows.Threading.DispatcherObject> že by se měl vyřešit mechanismus vzájemného vyloučení.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="e7ac5-288">Vezměte v úvahu následující pseudokódu:</span><span class="sxs-lookup"><span data-stu-id="e7ac5-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="e7ac5-289">![Diagram, který zobrazuje Vícenásobný přístup zřetězení.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="e7ac5-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="e7ac5-290">Ve většině času to je správné, ale v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] některých případech se může stát, že by takové neočekávané vícenásobný přístupy skutečně způsobily problémy.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="e7ac5-291">Takže v určitých klíčových časech [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] volání <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, která mění instrukci zámku pro [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] toto vlákno, aby používala zámek Vícenásobný přístup bez normálního zámku CLR.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>  
  
 <span data-ttu-id="e7ac5-292">Proč tým CLR zvolí toto chování?</span><span class="sxs-lookup"><span data-stu-id="e7ac5-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="e7ac5-293">Musela se provádět s objekty modelu COM STA a s dokončovacím vláknem.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="e7ac5-294">Když je objekt uvolněn z paměti, je `Finalize` jeho metoda spuštěna ve vyhrazeném vlákně finalizační metody, nikoli [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] v vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-295">V tomto případě se jedná o problém, protože objekt COM STA, který byl vytvořen [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ve vlákně, lze odstranit pouze [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ve vlákně.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="e7ac5-296">CLR odpovídá <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (v tomto případě použití Win32's `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="e7ac5-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="e7ac5-297">Pokud je ale [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno zaneprázdněno, vlákno finalizační metody je zastaveno a objekt COM STA nelze uvolnit, což způsobí závažnou nevracení paměti.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="e7ac5-298">Proto tým CLR provedl obtížné volání, aby zámky pracovaly způsobem, jakým dělají.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-298">So the CLR team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="e7ac5-299">Úkolem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] je zabránit neočekávanému Vícenásobný přístup, aniž byste museli znovu zavádět nevrácenou paměť, což znamená, že nebudeme zablokovat Vícenásobný přístup všude.</span><span class="sxs-lookup"><span data-stu-id="e7ac5-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7ac5-300">Viz také:</span><span class="sxs-lookup"><span data-stu-id="e7ac5-300">See also</span></span>

- [<span data-ttu-id="e7ac5-301">Vícevláknová aplikace s ukázkou dlouhotrvajícího výpočtu</span><span class="sxs-lookup"><span data-stu-id="e7ac5-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
