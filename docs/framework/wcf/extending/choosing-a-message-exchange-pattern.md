---
title: Výběr vzorce výměny zpráv
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 518a21ef34d52ef4b70871ba8bad7876374dd319
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/22/2019
ms.locfileid: "69951864"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="c4b5b-102">Výběr vzorce výměny zpráv</span><span class="sxs-lookup"><span data-stu-id="c4b5b-102">Choosing a Message Exchange Pattern</span></span>
<span data-ttu-id="c4b5b-103">Prvním krokem při psaní vlastního přenosu je rozhodování o tom, které *vzory výměny zpráv* (nebo MEPs) se vyžadují pro kanál, který vyvíjíte.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="c4b5b-104">Toto téma popisuje dostupné možnosti a popisuje různé požadavky.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="c4b5b-105">Toto je první úkol v seznamu úkolů vývoj kanálu, který je popsaný v tématu [Vývoj kanálů](../../../../docs/framework/wcf/extending/developing-channels.md).</span><span class="sxs-lookup"><span data-stu-id="c4b5b-105">This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="c4b5b-106">Šest vzorců výměny zpráv</span><span class="sxs-lookup"><span data-stu-id="c4b5b-106">Six Message Exchange Patterns</span></span>  
 <span data-ttu-id="c4b5b-107">Existují tři MEPsy, ze kterých si můžete vybrat:</span><span class="sxs-lookup"><span data-stu-id="c4b5b-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="c4b5b-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> a <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="c4b5b-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="c4b5b-109">Při použití dataMEP datagramu pošle klient zprávu s výměnou *požáru a zapomenutí* .</span><span class="sxs-lookup"><span data-stu-id="c4b5b-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="c4b5b-110">Výměna požáru a zapomenutí je taková, která vyžaduje vzdálené potvrzení úspěšného doručení.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="c4b5b-111">Zpráva může být ztracena při přenosu a nikdy se nespojit se službou.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="c4b5b-112">Pokud se operace odeslání na konci klienta úspěšně dokončí, nezaručuje, že vzdálený koncový bod obdrží zprávu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="c4b5b-113">Datagram je základní stavební blok pro zasílání zpráv, protože můžete sestavovat vlastní protokoly nad ním, včetně spolehlivých protokolů a zabezpečených protokolů.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="c4b5b-114">Kanály datagramů klienta <xref:System.ServiceModel.Channels.IOutputChannel> implementují rozhraní a kanály Datagram Service <xref:System.ServiceModel.Channels.IInputChannel> implementující rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="c4b5b-115">Požadavek-odpověď (<xref:System.ServiceModel.Channels.IRequestChannel> a <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="c4b5b-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="c4b5b-116">V tomto MEP zpráva se pošle a odpověď se přijme.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="c4b5b-117">Vzor se skládá z párů požadavků a odpovědí.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="c4b5b-118">Příklady volání požadavků na odezvu jsou vzdálená volání procedur (RPC) a požadavky GET prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="c4b5b-119">Tento model se také označuje jako poloduplexní.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="c4b5b-120">V tomto MEP implementují klientské kanály <xref:System.ServiceModel.Channels.IRequestChannel> a implementuje <xref:System.ServiceModel.Channels.IReplyChannel>kanály pro služby.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="c4b5b-121">Duplexní<xref:System.ServiceModel.Channels.IDuplexChannel>přenos ()</span><span class="sxs-lookup"><span data-stu-id="c4b5b-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="c4b5b-122">Duplexní MEP umožňuje klientovi poslat libovolný počet zpráv a přijatý v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="c4b5b-123">Duplexní MEP je jako telefonická konverzace, kde každé mluvené slovo je zpráva.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="c4b5b-124">Vzhledem k tomu, že obě strany mohou v tomto MEP odesílat a přijímat, rozhraní implementované kanály klienta a služby <xref:System.ServiceModel.Channels.IDuplexChannel>je.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="c4b5b-125">![Výběr vzoru výměny zprávy](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="c4b5b-125">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="c4b5b-126">Tři základní vzory výměny zpráv.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="c4b5b-127">Shora dolů: datagram, Request-response a duplexní režim.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="c4b5b-128">Každý z těchto MEPs může také podporovat *relace*.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="c4b5b-129">Relace (a implementace <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> typu <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) koreluje všechny zprávy odeslané a přijaté na kanálu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="c4b5b-130">Vzor požadavků a odpovědí je samostatná relace dvou zpráv, protože se jedná o korelační požadavek a odpověď.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="c4b5b-131">Oproti tomu vzor požadavek-odpověď, který podporuje relace, implikuje vzájemnou korelaci mezi všemi páry požadavků a odpovědí na daném kanálu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="c4b5b-132">Získáte tak celkem šest MEPs, ze kterých si můžete vybrat:</span><span class="sxs-lookup"><span data-stu-id="c4b5b-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="c4b5b-133">Datagram</span><span class="sxs-lookup"><span data-stu-id="c4b5b-133">Datagram</span></span>  
  
- <span data-ttu-id="c4b5b-134">Požadavek – odpověď</span><span class="sxs-lookup"><span data-stu-id="c4b5b-134">Request-response</span></span>  
  
- <span data-ttu-id="c4b5b-135">Duplex</span><span class="sxs-lookup"><span data-stu-id="c4b5b-135">Duplex</span></span>  
  
- <span data-ttu-id="c4b5b-136">Datagram s relacemi</span><span class="sxs-lookup"><span data-stu-id="c4b5b-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="c4b5b-137">Požadavek-odpověď s relacemi</span><span class="sxs-lookup"><span data-stu-id="c4b5b-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="c4b5b-138">Duplexní s relacemi</span><span class="sxs-lookup"><span data-stu-id="c4b5b-138">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c4b5b-139">Pro přenos UDP je jedinou podporovanou MEP datagram, protože UDP je ze své podstaty protokolem požáru a zapomenout.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="c4b5b-140">Relace a kanály s relacemi</span><span class="sxs-lookup"><span data-stu-id="c4b5b-140">Sessions and Sessionful Channels</span></span>  
 <span data-ttu-id="c4b5b-141">V cloudu sítě jsou k dispozici protokoly orientované na připojení (například protokol TCP) a protokoly bez připojení (například UDP).</span><span class="sxs-lookup"><span data-stu-id="c4b5b-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="c4b5b-142">WCF používá termín relace k označení logické abstrakce podobné připojení.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="c4b5b-143">Relační protokoly WCF jsou podobné síťovým protokolům orientovaným na připojení a protokoly WCF bez relací jsou podobné síťovým protokolům bez připojení.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="c4b5b-144">V objektovém modelu kanálu jednotlivé logické relace se manifestují jako instance kanálu s relacemi.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="c4b5b-145">Proto každá nová relace vytvořená klientem a přijatá ve službě odpovídá novému kanálu na každé straně.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="c4b5b-146">Následující diagram znázorňuje v horní části strukturu kanálů bez relací a dolní část struktury kanálů, které jsou v relaci.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="c4b5b-147">![Výběr vzoru výměny zprávy](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="c4b5b-147">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="c4b5b-148">Klient vytvoří nový kanál s relací a pošle zprávu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="c4b5b-149">Naslouchací proces kanálu na straně služby obdrží tuto zprávu a zjistí, že patří do nové relace, takže vytvoří nový kanál s relací a předá ho aplikaci (v reakci na aplikaci volající AcceptChannel v naslouchací službě kanálu).</span><span class="sxs-lookup"><span data-stu-id="c4b5b-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="c4b5b-150">Aplikace potom obdrží tuto zprávu a všechny následné zprávy odeslané ve stejné relaci prostřednictvím stejného kanálu relace.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="c4b5b-151">Jiný klient (nebo stejný klient) vytvoří novou relaci a pošle zprávu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="c4b5b-152">Naslouchací proces kanálu detekuje tuto zprávu v nové relaci a vytvoří nový kanál s relací a proces se opakuje.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="c4b5b-153">Bez relací nedochází k žádné korelaci mezi kanály a relacemi.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="c4b5b-154">Proto naslouchací proces kanálu vytvoří pouze jeden kanál, přes který aplikace doručuje všechny přijaté zprávy.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="c4b5b-155">K dispozici není žádné řazení zpráv, protože v ní není žádná relace, ve které by bylo možné zachovat pořadí zpráv.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="c4b5b-156">V horní části předchozího obrázku je znázorněna výměna zpráv v nerelačních zprávách.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="c4b5b-157">Spuštění a ukončení relací</span><span class="sxs-lookup"><span data-stu-id="c4b5b-157">Starting and Terminating Sessions</span></span>  
 <span data-ttu-id="c4b5b-158">Relace se spouští v klientovi pouhým vytvořením nového kanálu s relacemi.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="c4b5b-159">Spouští se ve službě, když služba obdrží zprávu odeslanou v nové relaci.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="c4b5b-160">Podobně se relace ukončí zavřením nebo přerušením kanálu s relacemi.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="c4b5b-161">Výjimkou je ta, <xref:System.ServiceModel.Channels.IDuplexSessionChannel> která se používá pro posílání i přijímání zpráv v duplexní komunikačním vzoru relace.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="c4b5b-162">Je možné, že jedna strana bude chtít přestat odesílat zprávy, ale nadále přijímat zprávy, když použijete <xref:System.ServiceModel.Channels.IDuplexSessionChannel> mechanismus, který umožňuje zavřít výstupní relaci, což znamená, že nebudete odesílat žádné další zprávy, ale zachováte vstupní relaci. otevřené, což vám umožní nadále přijímat zprávy.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="c4b5b-163">Obecně platí, že relace budou uzavřeny na straně odchozí a nikoli na straně příchozí.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="c4b5b-164">To znamená, že je možné zavřít výstupní kanály s relacemi, čímž se čistě ukončí relace.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="c4b5b-165">Při zavření výstupního kanálu relace dojde k tomu, že odpovídající vstupní kanál relace vrátí hodnotu null do aplikace <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> volající <xref:System.ServiceModel.Channels.IDuplexSessionChannel>na.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="c4b5b-166">Vstupní kanály relace by však neměly být uzavřeny, <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> Pokud není <xref:System.ServiceModel.Channels.IDuplexSessionChannel> na hodnotě null, což značí, že relace je již zavřena.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="c4b5b-167"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> Pokud<xref:System.ServiceModel.Channels.IDuplexSessionChannel> v nevrátil hodnotu null, může ukončení vstupního kanálu relace vyvolat výjimku, protože při zavírání může docházet k neočekávaným zprávám.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="c4b5b-168">Pokud si příjemce přeje ukončit relaci před odesílatelem, měl by zavolat <xref:System.ServiceModel.ICommunicationObject.Abort%2A> na vstupní kanál, který náhle ukončí relaci.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="c4b5b-169">Zápis kanálů relací</span><span class="sxs-lookup"><span data-stu-id="c4b5b-169">Writing Sessionful Channels</span></span>  
 <span data-ttu-id="c4b5b-170">Jako autor kanálu v relaci je potřeba, aby váš kanál měl k dispozici několik věcí.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="c4b5b-171">Na straně odeslání váš kanál potřebuje:</span><span class="sxs-lookup"><span data-stu-id="c4b5b-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="c4b5b-172">U každého nového kanálu vytvořte novou relaci a přidružte ji k novému ID relace, které je jedinečný řetězec.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="c4b5b-173">Nebo získejte novou relaci z kanálu relace pod zásobníkem.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="c4b5b-174">U každé zprávy odeslané pomocí tohoto kanálu, pokud kanál vytvořil relaci (na rozdíl od jejího získání od vrstvy níže), je třeba přidružit zprávu k relaci.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="c4b5b-175">V případě kanálů protokolu se to obvykle provádí přidáním hlavičky SOAP.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="c4b5b-176">Pro přenosové kanály se to obvykle provádí vytvořením nového transportního připojení nebo přidáním informací o relaci do protokolu rámců.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="c4b5b-177">U každé zprávy odeslané pomocí tohoto kanálu musíte poskytnout záruky doručení uvedené výše.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="c4b5b-178">Pokud se spoléháte na kanál, který následuje za tím, že zadáte relaci, bude tento kanál také poskytovat záruky pro doručování.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="c4b5b-179">Pokud zadáváte relaci sami, musíte tyto záruky implementovat jako součást vašeho protokolu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="c4b5b-180">Obecně platí, že pokud píšete kanál protokolu, který na obou stranách předpokládá službu WCF, budete pravděpodobně vyžadovat přenos TCP nebo kanál spolehlivého zasílání zpráv a spoléhat na jednu z nich k poskytnutí relace.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="c4b5b-181">Když <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> se ve vašem kanálu volá, proveďte potřebnou práci, aby se relace zavřela buď pomocí zadaného časového limitu, nebo s výchozím nastavením.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="c4b5b-182">To může být jednoduché jako volání <xref:System.ServiceModel.ICommunicationObject.Close%2A> na kanál níže (Pokud jste právě získali relaci z tohoto kanálu) nebo odesláním speciální zprávy protokolu SOAP nebo ukončením připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="c4b5b-183">Když <xref:System.ServiceModel.ICommunicationObject.Abort%2A> se ve vašem kanálu volá, ukončí relaci bez provedení vstupně-výstupních operací.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="c4b5b-184">To může znamenat, že se nic nestane, nebo může zahrnovat přerušení síťového připojení nebo nějakého jiného prostředku.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="c4b5b-185">Na straně příjmu váš kanál potřebuje:</span><span class="sxs-lookup"><span data-stu-id="c4b5b-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="c4b5b-186">Pro každou příchozí zprávu musí naslouchací proces kanálu detekovat relaci, ke které patří.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="c4b5b-187">Pokud se jedná o první zprávu v relaci, musí naslouchací proces kanálu vytvořit nový kanál a vrátit ho z volání do <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c4b5b-188">V opačném případě musí naslouchací proces kanálu najít existující kanál, který odpovídá relaci a doručuje zprávu prostřednictvím tohoto kanálu.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="c4b5b-189">Pokud váš kanál poskytuje relaci (spolu s požadovanými zárukami na doručení), může být vyžadována strana příjmu k provádění některých akcí, jako je například změna pořadí zpráv nebo odesílání potvrzení.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="c4b5b-190">Když <xref:System.ServiceModel.ICommunicationObject.Close%2A> se ve vašem kanálu volá, proveďte potřebnou práci, aby se relace zavřela buď na zadaný časový limit, nebo na výchozí.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="c4b5b-191">To může vést k výjimkám, pokud kanál obdrží zprávu při čekání na vypršení časového limitu ukončení.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="c4b5b-192">To je proto, že kanál bude ve stavu ukončení, když obdrží zprávu, takže by se vyvolal.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="c4b5b-193">Když <xref:System.ServiceModel.ICommunicationObject.Abort%2A> se ve vašem kanálu volá, ukončí relaci bez provedení vstupně-výstupních operací.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="c4b5b-194">To může znamenat, že se nic nestane, nebo může způsobit přerušení síťového připojení nebo nějakého jiného prostředku.</span><span class="sxs-lookup"><span data-stu-id="c4b5b-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c4b5b-195">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c4b5b-195">See also</span></span>

- [<span data-ttu-id="c4b5b-196">Přehled modelu kanálu</span><span class="sxs-lookup"><span data-stu-id="c4b5b-196">Channel Model Overview</span></span>](../../../../docs/framework/wcf/extending/channel-model-overview.md)
