---
title: Zvýšení oprávnění
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: df55b4fa107f3630cd259b755e0aaacdee4904ef
ms.sourcegitcommit: ffd7dd79468a81bbb0d6449f6d65513e050c04c4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/21/2019
ms.locfileid: "65960087"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="cf86c-102">Zvýšení oprávnění</span><span class="sxs-lookup"><span data-stu-id="cf86c-102">Elevation of Privilege</span></span>
<span data-ttu-id="cf86c-103">*Zvýšení úrovně oprávnění* výsledkem udělení povolení útočník nad rámec těchto zpočátku udělená oprávnění.</span><span class="sxs-lookup"><span data-stu-id="cf86c-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="cf86c-104">Například útočník se sadou oprávnění "jen pro čtení" oprávnění nějakým způsobem zvýší oprávnění set "pro čtení a zápisu."</span><span class="sxs-lookup"><span data-stu-id="cf86c-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="cf86c-105">Důvěryhodné služby STS musí podepsat deklarací identity tokenu SAML</span><span class="sxs-lookup"><span data-stu-id="cf86c-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="cf86c-106">Token zabezpečení kontrolní výrazy SAML (Markup Language) je obecný XML token, který je výchozím typem vydávaných tokenů.</span><span class="sxs-lookup"><span data-stu-id="cf86c-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="cf86c-107">SAML token lze sestavit pomocí tokenu služby zabezpečení (STS), která důvěřuje end webové služby v typické exchange.</span><span class="sxs-lookup"><span data-stu-id="cf86c-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="cf86c-108">Tokeny SAML obsahují deklarace identity v příkazech.</span><span class="sxs-lookup"><span data-stu-id="cf86c-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="cf86c-109">Útočník může kopírovat platný token deklarace identity, vytvořte nový token SAML a podepište ho pomocí různých vystavitele.</span><span class="sxs-lookup"><span data-stu-id="cf86c-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="cf86c-110">Cílem je zjistit, jestli server ověřuje vydavatelů a pokud ne, využívat slabé stránky k sestavení kompletních tokeny SAML, které umožňují oprávnění nad rámec těchto určených podle důvěryhodné služby tokenů zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="cf86c-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="cf86c-111"><xref:System.IdentityModel.Tokens.SamlAssertion> Třídy ověří digitální podpis obsažených v tokenu SAML a ve výchozím nastavení <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> vyžaduje, aby byly podepsány tokeny SAML certifikátem X.509, který je platný, kdy <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> z <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> třídy je nastavena na <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="cf86c-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="cf86c-112">`ChainTrust` režim pouze není dostatečná k určení, zda je důvěryhodného vystavitele tokenu SAML.</span><span class="sxs-lookup"><span data-stu-id="cf86c-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="cf86c-113">Služby, které vyžadují podrobnější model důvěryhodnosti můžete buď používat ověřování a vynucování zásad pro kontrolu vystavitele deklarace identity sady produkované vystavený ověřovací token nebo použít nastavení pro ověření X.509 na <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> omezit sadu povolené, podpisové certifikáty.</span><span class="sxs-lookup"><span data-stu-id="cf86c-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="cf86c-114">Další informace najdete v tématu [správa deklarací identity a autorizace s modelem Identity](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) a [federace a vydané tokeny](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="cf86c-114">For more information, see [Managing Claims and Authorization with the Identity Model](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="cf86c-115">Přepnutí Identity bez kontextu zabezpečení</span><span class="sxs-lookup"><span data-stu-id="cf86c-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="cf86c-116">Následující část se vztahuje pouze na WinFX.</span><span class="sxs-lookup"><span data-stu-id="cf86c-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="cf86c-117">Když se vytvoří připojení mezi klientem a serverem a identity klienta se nezmění, s výjimkou jednoho situaci: Po otevření klienta WCF, pokud jsou splněny všechny následující podmínky:</span><span class="sxs-lookup"><span data-stu-id="cf86c-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="cf86c-118">Postupy k vytvoření kontextu zabezpečení (pomocí zabezpečení přenosu, nebo relaci zabezpečení zprávu) je vypnout (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> je nastavena na `false` v případě zabezpečení zpráv nebo nebyl schopen vytvořit zabezpečení přenosu relace se používá v případě zabezpečení přenosu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="cf86c-119">HTTPS je jedním z takových transport).</span><span class="sxs-lookup"><span data-stu-id="cf86c-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="cf86c-120">Používáte ověřování Windows.</span><span class="sxs-lookup"><span data-stu-id="cf86c-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="cf86c-121">Přihlašovací údaje, které explicitně nenastavíte.</span><span class="sxs-lookup"><span data-stu-id="cf86c-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="cf86c-122">Jsou volání služby za zosobněného kontextu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="cf86c-123">Pokud jsou splněné tyto podmínky, může změnit identity použité k ověření klienta ke službě (nemusí být zosobněnou identitou, ale identitu procesu místo) po otevření klienta WCF.</span><span class="sxs-lookup"><span data-stu-id="cf86c-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="cf86c-124">K tomu dochází, protože přihlašovací údaje Windows používá k ověření klienta ke službě se přenášejí se všechny zprávy a pověření pro ověřování se získávají z identita Windows aktuálního vlákna.</span><span class="sxs-lookup"><span data-stu-id="cf86c-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="cf86c-125">Pokud se identita Windows aktuálního vlákna změní (například zosobněním různých volajícího), může také změnit přihlašovací údaj, který je připojen ke zprávě a použít k ověření klienta ke službě.</span><span class="sxs-lookup"><span data-stu-id="cf86c-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="cf86c-126">Pokud chcete mít deterministické chování při použití ověřování Windows společně s zosobnění je nutné explicitně nastavit přihlašovací údaje Windows nebo je potřeba vytvořit kontext zabezpečení ve službě.</span><span class="sxs-lookup"><span data-stu-id="cf86c-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="cf86c-127">K tomuto účelu použijte relaci zabezpečení zprávy nebo relace zabezpečení přenosu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="cf86c-128">Například net.tcp přenosu může poskytnout relace zabezpečení přenosu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="cf86c-129">Kromě toho musí používat pouze synchronní verzi klientské operace při volání služby.</span><span class="sxs-lookup"><span data-stu-id="cf86c-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="cf86c-130">Pokud vytvoříte vztah kontextu zabezpečení zprávy, by neměl uchováváte připojení ke službě otevřít déle než nakonfigurované relace období obnovení, protože identita můžete také změnit během procesu obnovení relace.</span><span class="sxs-lookup"><span data-stu-id="cf86c-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="cf86c-131">Snímek přihlašovací údaje</span><span class="sxs-lookup"><span data-stu-id="cf86c-131">Credentials Capture</span></span>  
 <span data-ttu-id="cf86c-132">Toto se vztahuje na [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)]a následné verze.</span><span class="sxs-lookup"><span data-stu-id="cf86c-132">The following applies to [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)], and subsequent versions.</span></span>  
  
 <span data-ttu-id="cf86c-133">Klient používá přihlašovací údaje nebo služby, které jsou založeny na aktuální kontext vlákna.</span><span class="sxs-lookup"><span data-stu-id="cf86c-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="cf86c-134">Přihlašovací údaje jsou získané `Open` – metoda (nebo `BeginOpen`, pro asynchronní volání) se nazývá klienta nebo služby.</span><span class="sxs-lookup"><span data-stu-id="cf86c-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="cf86c-135">Pro obě <xref:System.ServiceModel.ServiceHost> a <xref:System.ServiceModel.ClientBase%601> třídy, `Open` a `BeginOpen` dědí metody <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> a <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> metody <xref:System.ServiceModel.Channels.CommunicationObject> třídy.</span><span class="sxs-lookup"><span data-stu-id="cf86c-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cf86c-136">Při použití `BeginOpen` metody zachycené přihlašovací údaje nelze zaručit pověření proces, který volá metodu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="cf86c-137">Token mezipamětí povolit jejich přehrání pomocí zastaralá Data</span><span class="sxs-lookup"><span data-stu-id="cf86c-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="cf86c-138">WCF používá místní autority zabezpečení (LSA) `LogonUser` funkce k ověřování uživatelů pomocí uživatelského jména a hesla.</span><span class="sxs-lookup"><span data-stu-id="cf86c-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="cf86c-139">Protože funkci přihlášení je nákladná operace, WCF umožňuje, abyste mezipaměť tokenů, které představují ověřeným uživatelům ke zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="cf86c-140">Mechanizmus ukládání do mezipaměti ukládá výsledky z `LogonUser` pro další použití.</span><span class="sxs-lookup"><span data-stu-id="cf86c-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="cf86c-141">Tento mechanismus je ve výchozím nastavení; zakázané. ji Pokud chcete povolit, nastavte <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> vlastnost `true`, nebo použijte `cacheLogonTokens` atribut [ \<userNameAuthentication >](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span><span class="sxs-lookup"><span data-stu-id="cf86c-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="cf86c-142">Můžete nastavit čas to Live (TTL) pro tokeny v mezipaměti tak, že nastavíte <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> vlastnost <xref:System.TimeSpan>, nebo použijte `cachedLogonTokenLifetime` atribut `userNameAuthentication` element; výchozí hodnota je 15 minut.</span><span class="sxs-lookup"><span data-stu-id="cf86c-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="cf86c-143">Všimněte si, že token je uložené v mezipaměti, libovolného klienta, který zobrazí stejné uživatelské jméno a heslo můžete použít i token, i v případě, že uživatelský účet je odstraněn z Windows, nebo pokud se změnila jeho heslo.</span><span class="sxs-lookup"><span data-stu-id="cf86c-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="cf86c-144">Dokud hodnota TTL nevyprší a token, který se odebere z mezipaměti, WCF umožňuje (potenciálně škodlivý) uživatele ověřit.</span><span class="sxs-lookup"><span data-stu-id="cf86c-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="cf86c-145">Chcete-li tento problém zmírnit: Snížit tak, že nastavíte okno útoku `cachedLogonTokenLifetime` hodnotu na nejkratší dobu span uživatelé potřebují.</span><span class="sxs-lookup"><span data-stu-id="cf86c-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="cf86c-146">Vydaný Token autorizace: Vypršení platnosti obnovit velké hodnoty</span><span class="sxs-lookup"><span data-stu-id="cf86c-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="cf86c-147">Za určitých podmínek <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> vlastnost <xref:System.IdentityModel.Policy.AuthorizationContext> může být nastaven na hodnotu neočekávaně větší ( <xref:System.DateTime.MaxValue> pole hodnota minus jeden den, nebo 20. prosince 9999).</span><span class="sxs-lookup"><span data-stu-id="cf86c-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="cf86c-148">K tomu dojde při použití <xref:System.ServiceModel.WSFederationHttpBinding> a některé z vazeb poskytovaných systémem, které mají vydaný token jako klient typ přihlašovacích údajů.</span><span class="sxs-lookup"><span data-stu-id="cf86c-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="cf86c-149">Tato situace nastane také při vytváření vlastní vazby pomocí jedné z následujících metod:</span><span class="sxs-lookup"><span data-stu-id="cf86c-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="cf86c-150">Chcete-li tento problém zmírnit, musíte zkontrolovat zásady autorizace pro akce a čas vypršení platnosti jednotlivých zásad autorizace.</span><span class="sxs-lookup"><span data-stu-id="cf86c-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="cf86c-151">Služba používá jiný certifikát než zamýšlené klienta</span><span class="sxs-lookup"><span data-stu-id="cf86c-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="cf86c-152">Za určitých podmínek lze klienta digitálně podepsat zprávy pomocí certifikátu X.509 a službu načíst jiný certifikát než zamýšlené.</span><span class="sxs-lookup"><span data-stu-id="cf86c-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="cf86c-153">Tato situace může nastat v následujících případech:</span><span class="sxs-lookup"><span data-stu-id="cf86c-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="cf86c-154">Klient digitálně podepíše zprávu pomocí certifikátu X.509 nepřipojí certifikát X.509 na zprávu, ale spíš jenom odkazuje na certifikát s použitím jeho identifikátor klíče subjektu.</span><span class="sxs-lookup"><span data-stu-id="cf86c-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="cf86c-155">Počítač služby obsahuje dva nebo více certifikátů se stejným klíčem veřejné, ale obsahují rozdílné informace.</span><span class="sxs-lookup"><span data-stu-id="cf86c-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="cf86c-156">Služba načte certifikát, který odpovídá identifikátoru klíče subjektu, ale to není ten, který klient chtěli použít.</span><span class="sxs-lookup"><span data-stu-id="cf86c-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="cf86c-157">Když WCF obdrží zprávu a ověří podpis, WCF mapuje informace v neúmyslnému certifikát X.509 na sadu deklarací identity, které jsou rozdílné a potenciálně se zvýšenými oprávněními z co očekává klienta.</span><span class="sxs-lookup"><span data-stu-id="cf86c-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="cf86c-158">Chcete-li tento problém zmírnit, odkaz X.509 certifikátu dalším způsobem, jako je třeba použití <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="cf86c-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cf86c-159">Viz také:</span><span class="sxs-lookup"><span data-stu-id="cf86c-159">See also</span></span>

- [<span data-ttu-id="cf86c-160">Důležité informace o zabezpečení</span><span class="sxs-lookup"><span data-stu-id="cf86c-160">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)
- [<span data-ttu-id="cf86c-161">Zpřístupnění informací</span><span class="sxs-lookup"><span data-stu-id="cf86c-161">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)
- [<span data-ttu-id="cf86c-162">Útok DoS</span><span class="sxs-lookup"><span data-stu-id="cf86c-162">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)
- [<span data-ttu-id="cf86c-163">Útoky opakováním</span><span class="sxs-lookup"><span data-stu-id="cf86c-163">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)
- [<span data-ttu-id="cf86c-164">Falšování</span><span class="sxs-lookup"><span data-stu-id="cf86c-164">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)
- [<span data-ttu-id="cf86c-165">Nepodporované scénáře</span><span class="sxs-lookup"><span data-stu-id="cf86c-165">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)
