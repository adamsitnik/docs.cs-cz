---
title: Používání třídy XmlSerializer
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 3a0c8bd90c2a8f4ffc2e7a6d8831f306637915e6
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/19/2019
ms.locfileid: "65877385"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="3e7b7-102">Používání třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-102">Using the XmlSerializer Class</span></span>
<span data-ttu-id="3e7b7-103">Windows Communication Foundation (WCF) můžete použít dva různé serializace technologií Chcete-li data ve vaší aplikaci do souboru XML, která se přenášejí mezi klienty a služeb, proces s názvem serializace.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>  
  
## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="3e7b7-104">DataContractSerializer jako výchozí</span><span class="sxs-lookup"><span data-stu-id="3e7b7-104">DataContractSerializer as the Default</span></span>  
 <span data-ttu-id="3e7b7-105">Ve výchozím nastavení používá WCF <xref:System.Runtime.Serialization.DataContractSerializer> třída určená k serializaci datové typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="3e7b7-106">Tento serializátor podporuje následující typy:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-106">This serializer supports the following types:</span></span>  
  
- <span data-ttu-id="3e7b7-107">Primitivní typy (pro příklad, celá čísla, řetězce a bajtové pole), a také některé speciální typy, jako například <xref:System.Xml.XmlElement> a <xref:System.DateTime>, které jsou považovány za primitiv.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>  
  
- <span data-ttu-id="3e7b7-108">Typy kontraktů dat (typy označeny pomocí <xref:System.Runtime.Serialization.DataContractAttribute> atributu).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>  
  
- <span data-ttu-id="3e7b7-109">Typy označené <xref:System.SerializableAttribute> atribut, který patří typy, které implementují <xref:System.Runtime.Serialization.ISerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
- <span data-ttu-id="3e7b7-110">Typy, které implementují <xref:System.Xml.Serialization.IXmlSerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
- <span data-ttu-id="3e7b7-111">Mnoho běžných kolekce typů, které zahrnují mnoho typů obecných kolekcí.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-111">Many common collection types, which include many generic collection types.</span></span>  
  
 <span data-ttu-id="3e7b7-112">Mnoho typů rozhraní .NET Framework spadají do druhé dvě kategorie a proto jsou serializovatelné.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="3e7b7-113">Pole Serializovatelné typy jsou také serializovat.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="3e7b7-114">Úplný seznam najdete v tématu [zadání přenosu dat v kontraktech služeb](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-114">For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
 <span data-ttu-id="3e7b7-115"><xref:System.Runtime.Serialization.DataContractSerializer>, Spolu s daty používá typy kontraktů, je doporučený postup pro zápis nových služeb WCF.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="3e7b7-116">Další informace najdete v tématu [kontraktů dat pomocí](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-116">For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="3e7b7-117">Kdy použít třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-117">When to Use the XmlSerializer Class</span></span>  
 <span data-ttu-id="3e7b7-118">Také podporuje WCF <xref:System.Xml.Serialization.XmlSerializer> třídy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="3e7b7-119"><xref:System.Xml.Serialization.XmlSerializer> Třída není jedinečný pro WCF.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="3e7b7-120">Je stejný stroj serializace, použít webové služby ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="3e7b7-121"><xref:System.Xml.Serialization.XmlSerializer> Třída podporuje mnoho užší sadu typů než <xref:System.Runtime.Serialization.DataContractSerializer> třídy, ale umožňuje lepší kontrolu nad tím výsledného kódu XML a podporuje mnohem více schématu XML definice jazyk (XSD) standard.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="3e7b7-122">Také nevyžaduje žádné deklarativních atributů na Serializovatelné typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="3e7b7-123">Další informace najdete v tématu serializace XML v dokumentaci k rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="3e7b7-124"><xref:System.Xml.Serialization.XmlSerializer> Třídy typy kontraktů dat nepodporuje.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>  
  
 <span data-ttu-id="3e7b7-125">Při použití Svcutil.exe nebo **přidat odkaz na službu** je automaticky vybraná funkce v sadě Visual Studio pro generování kódu klienta pro služby třetích stran nebo pro přístup k schématu třetích stran, příslušný serializátor.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="3e7b7-126">Pokud schéma není kompatibilní s <xref:System.Runtime.Serialization.DataContractSerializer>, <xref:System.Xml.Serialization.XmlSerializer> zaškrtnuto.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>  
  
## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="3e7b7-127">Ruční přepínání objektu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-127">Manually Switching to the XmlSerializer</span></span>  
 <span data-ttu-id="3e7b7-128">V některých případech bude pravděpodobně nutné ručně nepřepnete na <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="3e7b7-129">K tomu dojde, například v těchto případech:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-129">This happens, for example, in the following cases:</span></span>  
  
- <span data-ttu-id="3e7b7-130">Při migraci aplikace z webových služeb ASP.NET na WCF, můžete chtít znovu použít existující, <xref:System.Xml.Serialization.XmlSerializer>– typy kontraktů kompatibilní typy místo vytváří nová data.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>  
  
- <span data-ttu-id="3e7b7-131">Když je důležité mít naprostou kontrolu nad XML, který se zobrazuje zprávy, ale dokumentu webové služby WSDL (Description Language) není k dispozici, například při vytváření služby s typy, které mají zajistit do určité standardizovaných publikované schématu, který je není kompatibilní s objektu DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>  
  
- <span data-ttu-id="3e7b7-132">Při vytváření služeb dodržujících starší verze standard kódování SOAP.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>  
  
 <span data-ttu-id="3e7b7-133">V těchto a dalších případů, můžete ručně nepřepnete na <xref:System.Xml.Serialization.XmlSerializer> třídy použitím `XmlSerializerFormatAttribute` atribut k vaší službě, jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
 [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  
  
## <a name="security-considerations"></a><span data-ttu-id="3e7b7-134">Důležité informace o zabezpečení</span><span class="sxs-lookup"><span data-stu-id="3e7b7-134">Security Considerations</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e7b7-135">Je důležité mít na paměti, při přechodu serializace moduly.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="3e7b7-136">Stejného typu může serializovat do formátu XML odlišně v závislosti na serializátoru, který je používán.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="3e7b7-137">Pokud používáte omylem nesprávné serializátor, může být zveřejnění informací o z typu, který jste neměli v úmyslu zpřístupnit.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>  
  
 <span data-ttu-id="3e7b7-138">Například <xref:System.Runtime.Serialization.DataContractSerializer> třídy serializuje pouze členy označené <xref:System.Runtime.Serialization.DataMemberAttribute> atribut při serializaci dat smlouvy typů.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="3e7b7-139"><xref:System.Xml.Serialization.XmlSerializer> Třídy serializuje žádný veřejný člen.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="3e7b7-140">Podívejte se typ v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-140">See the type in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
 [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  
  
 <span data-ttu-id="3e7b7-141">Pokud je typ nechtěně použít v kontraktu služby kde <xref:System.Xml.Serialization.XmlSerializer> je vybraná třída, `creditCardNumber` člen serializován, pravděpodobně není určený.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>  
  
 <span data-ttu-id="3e7b7-142">I když <xref:System.Runtime.Serialization.DataContractSerializer> třída je výchozím nastavením, můžete explicitně vybrat ho pro vaši službu (i když to by nikdy neměly být povinné) s použitím <xref:System.ServiceModel.DataContractFormatAttribute> atribut Typ kontraktu služby.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>  
  
 <span data-ttu-id="3e7b7-143">Serializátor používaný pro službu je nedílnou součástí toho, kontrakt a nedá se změnit tak, že vyberete jiný vazby nebo změnou dalších nastavení konfigurace.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>  
  
 <span data-ttu-id="3e7b7-144">Další důležité informace o zabezpečení platí pro <xref:System.Xml.Serialization.XmlSerializer> třídy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="3e7b7-145">Nejprve, důrazně doporučujeme, aby všechny aplikace WCF, který používá <xref:System.Xml.Serialization.XmlSerializer> třídy je podepsán klíčem, který je chráněna před vyzrazením.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="3e7b7-146">Toto doporučení se vztahuje i při ručním přepnout na <xref:System.Xml.Serialization.XmlSerializer> provádí a kdy k automatické přepnutí provádí (Svcutil.exe, přidat odkaz na službu nebo něco podobného).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="3e7b7-147">Je to proto, <xref:System.Xml.Serialization.XmlSerializer> Serializační stroj podporuje načítání *předem generovaného sestavení serializace* za předpokladu, že jsou podepsané stejným klíčem jako aplikace.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="3e7b7-148">Nepodepsaná aplikace není zcela chráněný z možnost škodlivé sestavení odpovídající očekávaný název sestavení serializace předem generovaného umístěných ve složce aplikace nebo globální mezipaměti sestavení.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="3e7b7-149">Samozřejmě útočník musíte nejprve získat přístup pro zápis do jednoho z těchto dvou umístění se pokusit tuto akci.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>  
  
 <span data-ttu-id="3e7b7-150">Další hrozby, které existuje při každém použití <xref:System.Xml.Serialization.XmlSerializer> se vztahuje na oprávnění k zápisu do dočasné složky systému.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="3e7b7-151"><xref:System.Xml.Serialization.XmlSerializer> Serializační stroj vytváří a používá dočasné *sestavení serializace* v této složce.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="3e7b7-152">Byste měli vědět, že jakýkoli proces s oprávněním k zápisu do dočasné složky může přepsat tyto sestavení serializace se škodlivý kód.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>  
  
## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="3e7b7-153">Pravidla pro podporu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-153">Rules for XmlSerializer support</span></span>  
 <span data-ttu-id="3e7b7-154">Není možné přímo použít <xref:System.Xml.Serialization.XmlSerializer>-kompatibilní atributů, které mají parametry operace smlouvy nebo návratové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="3e7b7-155">Nicméně se můžou uplatnit na zadané zprávy (zprávy kontraktu částí textu), jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
 [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="3e7b7-156">Při použití zadanou zprávu členům přepsat tyto atributy vlastnosti, které jsou v konfliktu u atributů zadanou zprávu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="3e7b7-157">Například v následujícím kódu `ElementName` přepíše `Name`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>  
  
 [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
 [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  
  
 <span data-ttu-id="3e7b7-158"><xref:System.ServiceModel.MessageHeaderArrayAttribute> Atribut není podporováno při použití <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e7b7-159">V takovém případě <xref:System.Xml.Serialization.XmlSerializer> následující výjimku, který je vydaný před WCF: "Nemůže mít element deklarovaný v nejvyšší úrovni schématu `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="3e7b7-160">Uveďte element obálky pro další s využitím `XmlArray` nebo `XmlArrayItem` místo `XmlElementAttribute`, nebo s použitím stylu parametru Wrapped. "</span><span class="sxs-lookup"><span data-stu-id="3e7b7-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>  
>   
>  <span data-ttu-id="3e7b7-161">Pokud se zobrazí takové výjimky, zjistěte, jestli tato situace se týká.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-161">If you receive such an exception, investigate whether this situation applies.</span></span>  
  
 <span data-ttu-id="3e7b7-162">WCF nepodporuje <xref:System.Xml.Serialization.SoapIncludeAttribute> a <xref:System.Xml.Serialization.XmlIncludeAttribute> atributy v kontraktů zpráv a operací smluv; použijte <xref:System.Runtime.Serialization.KnownTypeAttribute> místo atributu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>  
  
## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="3e7b7-163">Typy, které implementují rozhraní IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="3e7b7-163">Types that Implement the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="3e7b7-164">Typy, které implementují `IXmlSerializable` rozhraní jsou plně podporovány `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="3e7b7-165"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> Atribut by měl vždy použít pro tyto typy řídit jejich schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3e7b7-166">Pokud serializujete polymorfní typy musíte použít <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> typu k zajištění správného typu je serializována.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>  
  
 <span data-ttu-id="3e7b7-167">Existují tři typy prvků typy, které implementují `IXmlSerializable`: typy, které představují libovolného obsahu, typy, které představují jeden prvek a starší verze <xref:System.Data.DataSet> typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="3e7b7-168">Typy obsahu použít metodu schématu poskytovatele určeného `XmlSchemaProviderAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="3e7b7-169">Metoda nevrací `null` a <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost pro atribut je ponecháno na jeho výchozí hodnotu `false`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="3e7b7-170">Toto je nejběžnější použití `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-170">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="3e7b7-171">Typy elementů se používají při `IXmlSerializable` typ musí řídit svůj vlastní název kořenového elementu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="3e7b7-172">K označení typu jako typ elementu, nastavte <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atribut `true` nebo vrátit `null` z metody zprostředkovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="3e7b7-173">Metoda poskytovatele schématu je volitelné pro typy prvků – můžete zadat `null` místo názvu metody v `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="3e7b7-174">Nicméně pokud `IsAny` je `true` a metody zprostředkovatele schématu není zadána, metoda musí vracet `null`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>  
  
- <span data-ttu-id="3e7b7-175">Starší verze <xref:System.Data.DataSet> typy jsou `IXmlSerializable` typy, které nejsou označené `XmlSchemaProviderAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="3e7b7-176">Místo toho spoléhají na <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> metody pro generování schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="3e7b7-177">Tento model se používá pro `DataSet` typu a jeho typové datové sady odvozená třída v dřívějších verzích rozhraní .NET Framework, ale je zastaralá a je podporován pouze kvůli starším verzím.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="3e7b7-178">Nezadávejte Spolehněte se na tento model a vždycky používat `XmlSchemaProviderAttribute` do vaší `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="3e7b7-179">Typy rozhraní IXmlSerializable obsahu</span><span class="sxs-lookup"><span data-stu-id="3e7b7-179">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="3e7b7-180">Při serializaci datový člen typu, který implementuje `IXmlSerializable` a definované dříve, serializátoru, který zapíše element obálky pro datový člen je typu obsahu a předá řízení k <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="3e7b7-181"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> Implementace může zapisovat všechny XML, který zahrnuje přidání atributy pro element obálky.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="3e7b7-182">Po `WriteXml` je Hotovo, serializátor zavře elementu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-182">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="3e7b7-183">Při deserializaci datový člen typu, který implementuje `IXmlSerializable` a je typem obsahu, protože dříve definovali, deserializátor umístí čtecí funkce XML na element obálky pro datový člen a mít pod kontrolou předá <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="3e7b7-184">Metoda musí číst celý prvek, včetně počáteční a koncovou značku.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="3e7b7-185">Ujistěte se, že vaše `ReadXml` kód zpracovává případ, ve kterém je prázdný element.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="3e7b7-186">Kromě toho vaše `ReadXml` implementace neměli byste tedy spoléhat na element obálky jmenován určitým způsobem.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="3e7b7-187">Je název zvoleném serializátoru, který se může lišit.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-187">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="3e7b7-188">Je povoleno přiřadit `IXmlSerializable` typy obsahu polymorphically, třeba k datům členy typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="3e7b7-189">Může se také atribut instance typu mít hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="3e7b7-190">A konečně, je možné použít `IXmlSerializable` typy s objektu grafu a zachovávání s rozlišením povolen a <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="3e7b7-191">Všechny tyto funkce vyžadují serializátor WCF připojit určité atributy do prvku obálky ("nulový" a "type" v oboru názvů Instance schématu XML a "Id", "Ref", "Type" a "Sestavení" v oboru názvů specifických WCF).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="3e7b7-192">Atributy se mají ignorovat při implementaci ReadXml</span><span class="sxs-lookup"><span data-stu-id="3e7b7-192">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="3e7b7-193">Před předáním řízení pro vaše `ReadXml` kód, deserializátor zkontroluje prvek XML, zjistí tyto speciální atributy XML a funguje na ně.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="3e7b7-194">Například, pokud je "nulový" `true`, deserializovat hodnotu null a `ReadXml` není volána.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="3e7b7-195">Pokud se zjistí polymorfismus obsah elementu se deserializovat jako by to byla jiného typu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="3e7b7-196">Implementace typu polymorphically přiřazené `ReadXml` je volána.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="3e7b7-197">V každém případě `ReadXml` implementace by měl ignorovat tyto speciální atributy, protože deserializátor zpracovává.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="3e7b7-198">Důležité informace o schématu pro typy obsahu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="3e7b7-198">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="3e7b7-199">Při exportu schématu a vlastní `IXmlSerializable` typ obsahu, je volána metoda poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="3e7b7-200"><xref:System.Xml.Schema.XmlSchemaSet> Se předá metodě poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="3e7b7-201">Metodu můžete přidat libovolné platné schéma k sadě schémat.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="3e7b7-202">Sada schéma obsahuje schéma, které je již znám v době, kdy dojde k exportu schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="3e7b7-203">Když metoda poskytovatele schématu musí přidat položku do sady schémat, musíte určit, jestli <xref:System.Xml.Schema.XmlSchema> s odpovídající obor názvů již existuje v sadě.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="3e7b7-204">Pokud ano, metoda poskytovatele schématu musí přidat novou položku do stávající `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="3e7b7-205">V opačném případě se musí vytvořit nový `XmlSchema` instance.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="3e7b7-206">To je důležité, pokud pole `IXmlSerializable` typy se používají.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="3e7b7-207">Pokud máte například `IXmlSerializable` typ, který získá exportovat jako typ "A" v oboru názvů "B", je možné, že podle času je volána metoda poskytovatele schématu schématu nastavení už obsahuje schéma pro "B" typ "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="3e7b7-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="3e7b7-208">Kromě přidání typů, který chcete <xref:System.Xml.Schema.XmlSchemaSet>, metoda poskytovatele schématu pro typy obsahu musí vrátit nenulovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="3e7b7-209">Může vrátit <xref:System.Xml.XmlQualifiedName> , který určuje název typu schématu pro daný `IXmlSerializable` typu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="3e7b7-210">Tento kvalifikovaný název slouží taky jako data názvem a oborem názvů pro typ kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="3e7b7-211">Je povoleno návratový typ, který neexistuje v sadě hned po návratu metody zprostředkovatele schématu schémat.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="3e7b7-212">Ale očekává se, že v době všechny související typy jsou exportovány ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> metoda je volána pro všechny typy relevantní na <xref:System.Runtime.Serialization.XsdDataContractExporter> a <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> získat přístup k vlastnosti), typ existuje v sadě schémat.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="3e7b7-213">Přístup k `Schemas` vlastnost před všechny relevantní `Export` byly provedeny volání může vést <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="3e7b7-214">Další informace o procesu exportu, naleznete v tématu [export schémat ze tříd](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-214">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="3e7b7-215">Metoda poskytovatele schéma může taky vrátit <xref:System.Xml.Schema.XmlSchemaType> používat.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="3e7b7-216">Typ může nebo nemusí být anonymní.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="3e7b7-217">Pokud je anonymní, schéma pro `IXmlSerializable` typu se exportuje jako anonymního typu pokaždé, když `IXmlSerializable` typ používá jako datový člen.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="3e7b7-218">`IXmlSerializable` Typ stále má název kontraktu dat a obor názvů.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="3e7b7-219">(Tím se určuje, jak je popsáno v [názvy datových kontraktů](../../../../docs/framework/wcf/feature-details/data-contract-names.md) s tím rozdílem, že <xref:System.Runtime.Serialization.DataContractAttribute> atributu nelze použít k přizpůsobení názvu.) Pokud není anonymní, musí být jeden z typů v `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-219">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="3e7b7-220">Tento případ je ekvivalentní k vrácení `XmlQualifiedName` typu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="3e7b7-221">Kromě toho se pro typ exportuje globální prvek prohlášení.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="3e7b7-222">Pokud typ nemá <xref:System.Xml.Serialization.XmlRootAttribute> atribut WebMethod, element má stejný název a obor názvů jako kontraktu dat, a je vlastnost "nillable" `true`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="3e7b7-223">Jedinou výjimkou je obor názvů schématu (`http://www.w3.org/2001/XMLSchema`) – Pokud typ kontraktu dat je v tomto oboru názvů, odpovídající globální element je v oboru názvů prázdné, protože je zakázaná pro přidání nových elementů do oboru názvů schématu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="3e7b7-224">Pokud má typ `XmlRootAttribute` atribut WebMethod, globální prvek prohlášení je exportovat pomocí následující: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> a <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="3e7b7-225">Výchozí hodnoty s `XmlRootAttribute` použít jsou názvem kontraktu dat, prázdný obor názvů a "nillable" použití `true`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>  
  
 <span data-ttu-id="3e7b7-226">Stejná pravidla deklarace globální element se vztahují na typy starší datová sada.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="3e7b7-227">Všimněte si, že `XmlRootAttribute` nemůže přepsat globální prvek prohlášení přidané prostřednictvím vlastního kódu buď přidat do `XmlSchemaSet` pomocí metody poskytovatele schématu nebo prostřednictvím `GetSchema` pro datovou sadu starší verze typů.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="3e7b7-228">Typy elementů IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="3e7b7-228">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="3e7b7-229">`IXmlSerializable` typy elementů mít buď `IsAny` vlastnost nastavena na hodnotu `true` nebo jejich schématu poskytovatele metoda vrátit `null`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="3e7b7-230">Serializace a deserializace typ elementu je velmi podobná serializace a deserializace typu obsahu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="3e7b7-231">Existují však několik důležitých rozdílů:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-231">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="3e7b7-232">`WriteXml` Implementace má napsat přesně jeden element (který samozřejmě může obsahovat více podřízených prvků).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="3e7b7-233">To by neměl být zápis atributů mimo tento jeden element více na stejné úrovni elementy nebo smíšený obsah.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="3e7b7-234">Element může být prázdný.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-234">The element may be empty.</span></span>  
  
- <span data-ttu-id="3e7b7-235">`ReadXml` Implementace by neměla číst element obálky.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="3e7b7-236">Očekává se číst jeden element, který `WriteXml` vytvoří.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-236">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="3e7b7-237">Při serializaci typ elementu pravidelně (například jako datový člen v kontraktu dat), serializátoru, který vypíše element obálky, a před voláním `WriteXml`, stejně jako u typů obsahu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="3e7b7-238">Ale při serializaci typ elementu na nejvyšší úrovni, serializátoru, který je výstupem však nejsou obvykle element obálky, a po elementu, který `WriteXml` zapíše název kořenového adresáře a obor názvů jsou explicitně určena při vytváření serializátoru, který je v `DataContractSerializer` nebo `NetDataContractSerializer` konstruktory.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="3e7b7-239">Další informace najdete v tématu [serializace a deserializace](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-239">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="3e7b7-240">Při serializaci typ elementu na nejvyšší úrovni bez zadání kořenový název a obor názvů v době konstrukce <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> a <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> v podstatě Neprovádět žádnou akci a <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> volání `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="3e7b7-241">V tomto režimu nelze serializovaného objektu `null` a nelze jí přiřadit polymorphically.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="3e7b7-242">Navíc nelze povolit zachování graf objektu a `NetDataContractSerializer` nelze použít.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="3e7b7-243">Při deserializaci typ elementu na nejvyšší úrovni bez zadání kořenový název a obor názvů v době konstrukce <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> vrátí `true` Pokud nemůže najít začátek libovolný element.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="3e7b7-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> s `verifyObjectName` parametr nastaven na `true` se chová stejně jako `IsStartObject` před skutečně čtení objektu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="3e7b7-245">`ReadObject` ovládací prvek pak předá `ReadXml` metody.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-245">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="3e7b7-246">Schéma exportovat pro typy prvků je stejné jako v případě `XmlElement` zadejte, jak je popsáno v předchozí části, s tím rozdílem, že metoda poskytovatele schématu můžete přidat žádné další schéma, aby <xref:System.Xml.Schema.XmlSchemaSet> stejně jako u typů obsahu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="3e7b7-247">Použití `XmlRootAttribute` atribut s typy prvků není povoleno a globální prvek prohlášení jsou emitovány nikdy pro tyto typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="3e7b7-248">Rozdíl oproti třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-248">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="3e7b7-249">`IXmlSerializable` Rozhraní a `XmlSchemaProviderAttribute` a `XmlRootAttribute` atributy také rozumí <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="3e7b7-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="3e7b7-250">Existují však určité rozdíly v tom, jak jsou považovány v datovém modelu smlouvy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="3e7b7-251">Důležité rozdíly jsou shrnuty v následujícím seznamu:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-251">The important differences are summarized in the following list:</span></span>  
  
- <span data-ttu-id="3e7b7-252">Metoda poskytovatele schématu musí být veřejné se používá v `XmlSerializer`, ale nemusí být veřejné použitého v datovém modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>  
  
- <span data-ttu-id="3e7b7-253">Při volání metody zprostředkovatele schématu `IsAny` je `true` v datovém modelu smlouvy, ale ne s `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="3e7b7-254">Když `XmlRootAttribute` atribut není k dispozici pro obsah nebo starší datová sada typů, `XmlSerializer` exportuje globální prvek prohlášení v oboru názvů prázdné.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="3e7b7-255">V datovém modelu smlouvy oboru názvů použitého je obvykle obor názvů kontraktu dat jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="3e7b7-256">Mějte na paměti tyto rozdíly při vytváření typů, které se používají u obou technologií serializace.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="3e7b7-257">Import schématu rozhraní IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="3e7b7-257">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="3e7b7-258">Při importu schématu generovaném z `IXmlSerializable` typy, existuje několik možností:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="3e7b7-259">Generované schéma může být schématu platný datový kontrakt, jak je popsáno v [schéma kontraktů dat – referenční informace](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="3e7b7-260">V tomto případě obvyklým způsobem můžete importovat schéma a typy kontraktů běžných dat jsou generovány.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="3e7b7-261">Generované schéma nemusí být platný datový kontrakt schéma.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="3e7b7-262">Například metodu schématu poskytovatele může vygenerovat schéma, které zahrnuje atributy ve formátu XML, které nejsou podporované v datovém modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="3e7b7-263">V takovém případě můžete importovat schéma jako `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="3e7b7-264">Tento režim importu se nenachází na ve výchozím nastavení lze snadno ji však povolit – například s `/importXmlTypes` přepínač příkazového řádku [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="3e7b7-265">To je podrobně popsáno [import schématu pro generování třídy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="3e7b7-265">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="3e7b7-266">Všimněte si, že musíte pracovat přímo s XML pro typ instance.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="3e7b7-267">Mohou také zvážit použití jiné technologie serializace, který podporuje používání nástroje většímu počtu schématu – naleznete v tématu o používání `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="3e7b7-268">Můžete chtít znovu použít stávající `IXmlSerializable` typy v proxy namísto generování nové.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="3e7b7-269">V takovém případě funkce odkazované typy popsaná v import schématu pro téma generovat typy lze označující typ, který chcete znovu použít.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="3e7b7-270">To odpovídá pomocí `/reference` zapnout svcutil.exe, který určuje sestavení, který obsahuje typy pro opětovné použití.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="3e7b7-271">Starší verze XmlSerializer chování</span><span class="sxs-lookup"><span data-stu-id="3e7b7-271">XmlSerializer Legacy Behavior</span></span>  
 <span data-ttu-id="3e7b7-272">V rozhraní .NET Framework 4.0 a dřívějších verzí XmlSerializer generované sestavení serializace dočasné napsáním kódu jazyka C# do souboru.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="3e7b7-273">Soubor se potom kompilovány do sestavení.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="3e7b7-274">Toto chování měli některé nežádoucí důsledky jako zpomalení doby spuštění pro serializátor.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="3e7b7-275">V rozhraní .NET Framework 4.5 toto chování změnila ke generování sestavení bez nutnosti použití kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="3e7b7-276">Někteří vývojáři mohou chtít zobrazit generovaný kód C#.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="3e7b7-277">Můžete zadat tuto starší chování pomocí následující konfigurace:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-277">You can specify to use this legacy behavior by the following configuration:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <system.xml.serialization>  
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />  
  </system.xml.serialization>  
  <system.diagnostics>  
    <switches>  
      <add name="XmlSerialization.Compilation" value="1" />  
    </switches>  
  </system.diagnostics>  
</configuration>  
```  
  
 <span data-ttu-id="3e7b7-278">Pokud narazíte na problémy s kompatibilitou, například `XmlSerializer` neúspěšné serializace odvozené třídy s neveřejným nové přepsání, můžete přepnout zpět `XMLSerializer` starší chování pomocí následující konfigurace:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>  
  
```xml  
<configuration>  
<appSettings>   
<add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />  
               </appSettings>  
</configuration>  
```  
  
 <span data-ttu-id="3e7b7-279">Jako alternativu k konfiguraci uvedené výš můžete použít následující konfiguraci na počítači se systémem rozhraní .NET Framework 4.5 nebo novější verzi:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>  
  
```xml  
<configuration>  
<system.xml.serialization>  
<xmlSerializer useLegacySerializerGeneration="true"/>  
</system.xml.serialization>  
</configuration>  
```  
  
> [!NOTE]
>  <span data-ttu-id="3e7b7-280">`<xmlSerializer useLegacySerializerGeneration="true"/>` Přepínač funguje jenom na počítači se systémem rozhraní .NET Framework 4.5 nebo vyšší verze.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="3e7b7-281">Výše uvedené `appSettings` přístup funguje ve všech verzích rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3e7b7-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3e7b7-282">Viz také:</span><span class="sxs-lookup"><span data-stu-id="3e7b7-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="3e7b7-283">Určování přenosu dat v kontraktech služby</span><span class="sxs-lookup"><span data-stu-id="3e7b7-283">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="3e7b7-284">Použití kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="3e7b7-284">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="3e7b7-285">Postupy: Vylepšení spuštění čas z klientských aplikací WCF pomocí třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3e7b7-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
