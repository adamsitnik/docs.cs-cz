---
title: Důležité informace o zabezpečení pro data
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 3895bb44139a05d1933f1d3af19ccb9799309515
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/05/2019
ms.locfileid: "57363082"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="e0f38-102">Důležité informace o zabezpečení pro data</span><span class="sxs-lookup"><span data-stu-id="e0f38-102">Security Considerations for Data</span></span>

<span data-ttu-id="e0f38-103">Při práci s daty ve Windows Communication Foundation (WCF), je nutné zvážit počet kategorií ohrožení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="e0f38-104">V následující tabulce jsou uvedeny nejdůležitější hrozby tříd, které se týkají zpracování dat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="e0f38-105">WCF poskytuje nástroje ke zmírnění těchto hrozeb.</span><span class="sxs-lookup"><span data-stu-id="e0f38-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="e0f38-106">Útok DoS při přijímání nedůvěryhodná data, data, může způsobit přijímající stranu pro přístup k neúměrné množství různých zdrojů, jako je například paměť, vlákna, k dispozici připojení nebo cyklů procesoru způsobením zdlouhavé výpočty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="e0f38-107">Odmítnutí služby útok proti serveru mohou způsobit, že k chybě a nebudete moct zpracovávat zprávy od klientů, které legitimní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="e0f38-108">Spuštění škodlivého kódu příchozí nedůvěryhodných, že data na přijímající stranu pro spuštění kódu způsobí, že ho neměli v úmyslu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="e0f38-109">Zpřístupnění informací vzdálenému útočníkovi vynutí přijímající straně reagovat na jeho požadavky způsobem, který zpřístupnit víc informací, než se chystá.</span><span class="sxs-lookup"><span data-stu-id="e0f38-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="e0f38-110">Uživatelem zadaný kód a zabezpečení přístupu kódu</span><span class="sxs-lookup"><span data-stu-id="e0f38-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="e0f38-111">Počet míst v infrastruktuře Windows Communication Foundation (WCF) spustit kód, který se zadal uživatel.</span><span class="sxs-lookup"><span data-stu-id="e0f38-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="e0f38-112">Například <xref:System.Runtime.Serialization.DataContractSerializer> Serializační stroj může třeba volat vlastnost uživatelem zadaný `set` přístupové objekty a `get` přistupující objekty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="e0f38-113">Infrastruktura WCF kanál může také volat do uživatelem zadaného odvozené třídy <xref:System.ServiceModel.Channels.Message> třídy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="e0f38-114">Zodpovídá za kód autora zajistit, že neexistuje žádná ohrožení zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="e0f38-115">Například pokud vytvoříte datový typ kontraktu s vlastností datový člen celočíselného typu a v `set` přistupující objekt implementace přidělit pole na základě hodnoty vlastnosti, vystavit možnosti útoku denial-of-service-li škodlivý zpráva obsahuje velmi velké hodnoty pro tento datový člen.</span><span class="sxs-lookup"><span data-stu-id="e0f38-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="e0f38-116">Obecně se vyhýbejte rozdělení na základě příchozích dat nebo dlouhé zpracování uživatelského kódu (zejména v případě malé množství příchozích dat může být způsobena dlouhé zpracování).</span><span class="sxs-lookup"><span data-stu-id="e0f38-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="e0f38-117">Při provádění analýzu zabezpečení z uživatelského kódu, nezapomeňte také zvážit všechny případy selhání (to znamená všechny kód pro větvení ve kterém jsou výjimky vyvolány).</span><span class="sxs-lookup"><span data-stu-id="e0f38-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="e0f38-118">Ultimate příklad uživatelského kódu je kód uvnitř vaší implementace služby pro každou operaci.</span><span class="sxs-lookup"><span data-stu-id="e0f38-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="e0f38-119">Zabezpečení vaší implementace služby je vaší povinností.</span><span class="sxs-lookup"><span data-stu-id="e0f38-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="e0f38-120">Je snadné neúmyslně vytvořit nezabezpečené operace implementace, které může vést k ohrožení zabezpečení s cílem odepření služby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="e0f38-121">Například operace, která přebírá řetězec a vrátí seznam zákazníků z databáze, jejichž název začíná tento řetězec.</span><span class="sxs-lookup"><span data-stu-id="e0f38-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="e0f38-122">Pokud pracujete s velkými databázemi a řetězec předávaný je právě jedno písmeno, váš kód může pokusit vytvořit zprávu větší než všechny dostupné paměti, což způsobí selhání celé služby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="e0f38-123">( <xref:System.OutOfMemoryException> Se nedá vrátit zpátky v [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] což vždy vede k ukončení aplikace.)</span><span class="sxs-lookup"><span data-stu-id="e0f38-123">(An <xref:System.OutOfMemoryException> is not recoverable in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] and always results in the termination of your application.)</span></span>

<span data-ttu-id="e0f38-124">Měli byste zajistit, že žádný škodlivý kód zapojené do elektrické zásuvky do různých bodů rozšiřitelnosti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="e0f38-125">To je obzvláště důležité, když spouštíte v částečném vztahu důvěryhodnosti, zpracování typů z částečně důvěryhodných sestavení nebo vytváření komponent použitelné částečně důvěryhodným kódem.</span><span class="sxs-lookup"><span data-stu-id="e0f38-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="e0f38-126">Další informace najdete v tématu "Částečné důvěryhodnosti hrozby" v další části.</span><span class="sxs-lookup"><span data-stu-id="e0f38-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="e0f38-127">Poznámka: při spouštění v částečném vztahu důvěryhodnosti, infrastruktura serializaci smlouvy dat podporuje pouze omezené dílčí sady dat kontraktu programovacího modelu – například privátní členy dat nebo typy pomocí <xref:System.SerializableAttribute> atributu nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="e0f38-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="e0f38-128">Další informace najdete v tématu [částečném vztahu důvěryhodnosti](../../../../docs/framework/wcf/feature-details/partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-128">For more information, see [Partial Trust](../../../../docs/framework/wcf/feature-details/partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="e0f38-129">Zabránit neúmyslnému informacím</span><span class="sxs-lookup"><span data-stu-id="e0f38-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="e0f38-130">Při navrhování Serializovatelné typy s ohledem na bezpečnost, přístup k informacím je možné žádný problém.</span><span class="sxs-lookup"><span data-stu-id="e0f38-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="e0f38-131">Vezměte v úvahu následující body:</span><span class="sxs-lookup"><span data-stu-id="e0f38-131">Consider the following points:</span></span>

- <span data-ttu-id="e0f38-132"><xref:System.Runtime.Serialization.DataContractSerializer> Programovací model umožňuje možnost vidět data privátní a interní mimo tento typ nebo sestavení během serializace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="e0f38-133">Kromě toho mohou být vystaveny tvar typu při exportu schématu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="e0f38-134">Ujistěte se, že vysvětlení vašeho typu serializaci projekce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="e0f38-135">Pokud nechcete, aby něco vystavit, zakažte jeho serializace (například použitím není <xref:System.Runtime.Serialization.DataMemberAttribute> atribut v případě kontraktu dat).</span><span class="sxs-lookup"><span data-stu-id="e0f38-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="e0f38-136">Mějte na paměti, že stejného typu může mít více serializaci projekce, v závislosti na serializátoru, který je používán.</span><span class="sxs-lookup"><span data-stu-id="e0f38-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="e0f38-137">Stejný typ vystavuje jednu sadu dat při použití s <xref:System.Runtime.Serialization.DataContractSerializer> a další sadu dat při použití s <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="e0f38-138">Náhodně pomocí nesprávného serializátor může způsobit zpřístupnění informací.</span><span class="sxs-lookup"><span data-stu-id="e0f38-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="e0f38-139">Použití <xref:System.Xml.Serialization.XmlSerializer> ve starší verzi vzdálené procedury volání (RPC) / kódovaného režimu může nechtěně vystavit tvar objektu grafu na straně odesílání na straně příjmu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="e0f38-140">Prevence útoků s cílem odepření služeb</span><span class="sxs-lookup"><span data-stu-id="e0f38-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="e0f38-141">Kvóty</span><span class="sxs-lookup"><span data-stu-id="e0f38-141">Quotas</span></span>

<span data-ttu-id="e0f38-142">Příčinou přijímající straně přidělit značné množství paměti je možný útok s cílem odepření služby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="e0f38-143">Zatímco tato část se soustřeďuje na problémy spotřeba paměti vyplývající z velkých zpráv, může dojít k dalším útokům.</span><span class="sxs-lookup"><span data-stu-id="e0f38-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="e0f38-144">Zprávy mohou například použít nevyrovnaný objem doba zpracování.</span><span class="sxs-lookup"><span data-stu-id="e0f38-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="e0f38-145">Útoky s cílem odepření služeb jsou obvykle zmírnit použití kvót.</span><span class="sxs-lookup"><span data-stu-id="e0f38-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="e0f38-146">Když dojde k překročení kvóty, <xref:System.ServiceModel.QuotaExceededException> obvykle je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="e0f38-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="e0f38-147">Bez kvót, škodlivých zpráv může způsobit všechnu dostupnou paměť přístup, což vede k <xref:System.OutOfMemoryException> výjimky nebo všechny dostupné balíčky přístupná, výsledkem <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="e0f38-148">Scénář – překročila se kvóta je obnovitelné; Jestliže ve spuštěné službě, je aktuálně zpracovávanou zprávu zahozena a stále spuštěný a zpracovávat další zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="e0f38-149">Scénáře přetečení-paměti a zásobníku, ale nejsou obnovitelné kdekoli v [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; služba ukončuje Pokud nalezne takové výjimky.</span><span class="sxs-lookup"><span data-stu-id="e0f38-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="e0f38-150">Kvóty ve službě WCF nezahrnují žádné předběžné přidělení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="e0f38-151">Například pokud <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> kvóty (tuto možnost najdete na různé třídy) je nastavený na 128 KB, neznamená, že 128 KB je automaticky přidělena pro každou zprávu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="e0f38-152">Skutečná velikost přidělené závisí na skutečnou velikost příchozí zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="e0f38-153">Mnoho kvóty jsou k dispozici na transportní vrstvě.</span><span class="sxs-lookup"><span data-stu-id="e0f38-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="e0f38-154">Jedná se o kvóty vynucuje konkrétní přenosový kanál používá (HTTP, TCP a tak dále).</span><span class="sxs-lookup"><span data-stu-id="e0f38-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="e0f38-155">Když toto téma popisuje některé z těchto kvót, tyto kvóty jsou podrobně popsány v [přenosové kvóty](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="e0f38-156">Zatřiďovací tabulka ohrožení zabezpečení</span><span class="sxs-lookup"><span data-stu-id="e0f38-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="e0f38-157">Obsahuje chybu, když kontraktů dat obsahují zatřiďovací tabulky nebo kolekce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="e0f38-158">Tento problém nastane, pokud velký počet hodnot jsou vloženy do zatřiďovací tabulku kde generují velký počet těchto hodnot stejnou hodnotu hash.</span><span class="sxs-lookup"><span data-stu-id="e0f38-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="e0f38-159">To může sloužit jako útok DOS.</span><span class="sxs-lookup"><span data-stu-id="e0f38-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="e0f38-160">Toto ohrožení zabezpečení je možné zmírnit tím, že nastavíte kvóty MaxReceivedMessageSize vazby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="e0f38-161">Při nastavování této kvóty prevence takové útoky musí věnovat pozornost.</span><span class="sxs-lookup"><span data-stu-id="e0f38-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="e0f38-162">Tato kvóta vloží horní limit velikosti zprávy WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="e0f38-163">Kromě toho Vyhněte se použití ve vašich smlouvách data zatřiďovací tabulky nebo kolekce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="e0f38-164">Omezení využití paměti bez datových proudů</span><span class="sxs-lookup"><span data-stu-id="e0f38-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="e0f38-165">Model zabezpečení kolem velkých zpráv závisí na datové proudy, jestli se používá.</span><span class="sxs-lookup"><span data-stu-id="e0f38-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="e0f38-166">V případě basic, Streamovat zprávy jsou ukládány do vyrovnávací paměti do paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="e0f38-167">V takovém případě použijte <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> kvóta na <xref:System.ServiceModel.Channels.TransportBindingElement> nebo na vazeb poskytovaných systémem pro ochranu před velkých zpráv omezením maximální velikost zprávy pro přístup k.</span><span class="sxs-lookup"><span data-stu-id="e0f38-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="e0f38-168">Všimněte si, že služba může zpracovávat více zpráv ve stejnou dobu, v takovém případě jsou všechny v paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="e0f38-169">Pomocí omezení funkce pro zmírnění této hrozby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="e0f38-170">Všimněte si také, `MaxReceivedMessageSize` není stanovili horní mez využití paměti za zprávy, ale umožňuje omezuje v rámci faktor konstantní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="e0f38-171">Například pokud `MaxReceivedMessageSize` je 1 MB a doručení zprávy do 1 MB a potom deserializovat, další paměť vyžádáním tak, aby obsahovala deserializovaný objekt grafu, což vede k celkové paměti a využití více než 1 MB.</span><span class="sxs-lookup"><span data-stu-id="e0f38-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="e0f38-172">Z tohoto důvodu se vyhněte se vytváření Serializovatelné typy, které by mohlo způsobit významné paměťové nároky bez množství příchozích dat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="e0f38-173">Například kontraktu dat "MyContract" s 50 volitelnými daty člena pole a další 100 privátní pole může být vytvořena s XML konstrukci "\<MyContract / >".</span><span class="sxs-lookup"><span data-stu-id="e0f38-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="e0f38-174">Tato konfigurace XML výsledkem paměti používané pro 150 pole.</span><span class="sxs-lookup"><span data-stu-id="e0f38-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="e0f38-175">Všimněte si, že datových členů jsou volitelné ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-175">Note that data members are optional by default.</span></span> <span data-ttu-id="e0f38-176">Tento problém nastane, pokud takový typ je součástí pole.</span><span class="sxs-lookup"><span data-stu-id="e0f38-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="e0f38-177">`MaxReceivedMessageSize` samostatně nestačí k útokům odmítnutí služby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="e0f38-178">Například deserializátor může vynutit deserializovat graf hluboce vnořený objekt (objekt, který obsahuje jiný objekt, který obsahuje jeden další a tak dále) příchozí zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="e0f38-179">Jak <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Xml.Serialization.XmlSerializer> volat metody ve vnořených způsob, jak rekonstruovat těchto grafů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="e0f38-180">Hluboká vnoření volání metody může vést k neodstranitelné <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="e0f38-181">Tuto hrozbu zmírnit nastavení <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> kvóty pro omezení úrovní vnoření XML, jak je popsáno v části "Pomocí XML bezpečně" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="e0f38-182">Nastavení na hodnotu dodatečných kvótách `MaxReceivedMessageSize` je zvlášť důležité při používání binárního kódování XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="e0f38-183">Pomocí binárního kódování odpovídá nich do jisté míry komprese: malou skupinu bajtů v příchozí zprávě můžou představovat velké množství dat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="e0f38-184">Díky tomu se i zpráva zasazené do `MaxReceivedMessageSize` limit může trvat až mnohem větší množství paměti v podobě plně rozbalený.</span><span class="sxs-lookup"><span data-stu-id="e0f38-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="e0f38-185">Ke zmírnění hrozeb. tyto specifické pro XML, všechny kvóty čtečky XML musí být nastavena správně, jak je popsáno v části "Pomocí XML bezpečně" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="e0f38-186">Omezení využití paměti se streamováním</span><span class="sxs-lookup"><span data-stu-id="e0f38-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="e0f38-187">Při vysílání datových proudů, můžete použít malé `MaxReceivedMessageSize` nastavení pro ochranu před útoky s cílem odepření služeb.</span><span class="sxs-lookup"><span data-stu-id="e0f38-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="e0f38-188">Složitější scénáře jsou však možné díky streamování.</span><span class="sxs-lookup"><span data-stu-id="e0f38-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="e0f38-189">Služba nahrávání souborů lze například soubory větší než všechnu dostupnou paměť.</span><span class="sxs-lookup"><span data-stu-id="e0f38-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="e0f38-190">V takovém případě nastavte `MaxReceivedMessageSize` velmi velké hodnoty, očekává se, že skoro žádná data do vyrovnávací paměti v paměti a zpráva datové proudy přímo na disk.</span><span class="sxs-lookup"><span data-stu-id="e0f38-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="e0f38-191">Pokud škodlivý zprávu můžete vynutit nějakým způsobem WCF vyrovnávací paměti pro data místo datových proudů v tomto případě `MaxReceivedMessageSize` už chrání proti zprávě přístup k všechnu dostupnou paměť.</span><span class="sxs-lookup"><span data-stu-id="e0f38-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="e0f38-192">Pro zmírnění této hrozby, existují kvóty specifická nastavení na různých komponent pro zpracování dat WCF tento limit ukládání do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="e0f38-193">Nejvýznamnější z nich je `MaxBufferSize` vlastnost u různých elementů přenosové vazby a standardní vazby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="e0f38-194">Při vysílání datových proudů, tato kvóta je třeba nastavit zohledněním maximální množství paměti, kterou jste ochotni přidělovat jednotlivým zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="e0f38-195">Stejně jako u `MaxReceivedMessageSize`, nastavení nevystavuje absolutní maximální využití paměti, ale jenom na omezuje v rámci faktor konstantní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="e0f38-196">Také jako s `MaxReceivedMessageSize`, mějte na paměti možnost více zpráv zpracovávaných současně.</span><span class="sxs-lookup"><span data-stu-id="e0f38-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="e0f38-197">Třída MaxBufferSize podrobnosti</span><span class="sxs-lookup"><span data-stu-id="e0f38-197">MaxBufferSize Details</span></span>

<span data-ttu-id="e0f38-198">`MaxBufferSize` Vlastnost omezuje žádné hromadné dělá WCF vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="e0f38-199">Například WCF vždy vyrovnávacích pamětí hlavičky SOAP a chyb SOAP, jakož i všech částí MIME najít tak, aby nebyl v pořadí fyzická čtení ve zprávě zpráv přenosu optimalizace mechanismus (MTOM).</span><span class="sxs-lookup"><span data-stu-id="e0f38-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="e0f38-200">Toto nastavení omezuje objem ukládání do vyrovnávací paměti ve všech těchto případech.</span><span class="sxs-lookup"><span data-stu-id="e0f38-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="e0f38-201">WCF toho dosahuje tím, že předáte `MaxBufferSize` hodnoty pro různé součásti, které může uložit do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="e0f38-202">Například některé <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> přetížení <xref:System.ServiceModel.Channels.Message> třídě `maxSizeOfHeaders` parametru.</span><span class="sxs-lookup"><span data-stu-id="e0f38-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="e0f38-203">Předá WCF `MaxBufferSize` hodnotu tomuto parametru a omezit tak velikost záhlaví SOAP ukládání do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="e0f38-204">Je důležité při použití nastavte tento parametr <xref:System.ServiceModel.Channels.Message> třídy přímo.</span><span class="sxs-lookup"><span data-stu-id="e0f38-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="e0f38-205">Obecně platí při použití komponenty ve službě WCF, která přebírá parametry kvót, je důležité, abyste pochopili důsledky zabezpečení tyto parametry a tyto hodnoty správně nastaveny.</span><span class="sxs-lookup"><span data-stu-id="e0f38-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="e0f38-206">Kodér MTOM zpráv má také `MaxBufferSize` nastavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="e0f38-207">Při použití standardní vazby, automaticky je nastavené na úrovni přenosu `MaxBufferSize` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="e0f38-208">Ale při použití element vazby kodér zprávy MTOM k vytvoření vlastní vazby, je důležité nastavit `MaxBufferSize` vlastnost na hodnotu bezpečné při streamování se používá.</span><span class="sxs-lookup"><span data-stu-id="e0f38-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="e0f38-209">Streamování útoky založenými na XML</span><span class="sxs-lookup"><span data-stu-id="e0f38-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="e0f38-210">`MaxBufferSize` samostatně nestačí k zajištění, že WCF nejde vynutit do ukládání do vyrovnávací paměti při streamování se očekává.</span><span class="sxs-lookup"><span data-stu-id="e0f38-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="e0f38-211">Například čtečky WCF XML vždy vyrovnávací paměti celý počáteční značce elementu XML při spouštění číst nového elementu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="e0f38-212">To se provádí tak, že jsou správně zpracovány obory názvů a atributů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="e0f38-213">Pokud `MaxReceivedMessageSize` je nakonfigurovaný jako velké (například povolit velkých souborů přímo na disk streamování scénář), lze vytvořit škodlivé zprávy kde je obsah celé zprávy velké počáteční značky elementu XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="e0f38-214">Pokus o čtení to vede <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="e0f38-215">Toto je jeden z mnoha možných založený na formátu XML denial-of-service útoků, které můžete všechny možné zmírnit použití kvót čtečky XML, popsané v části "Pomocí XML bezpečně" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="e0f38-216">Při vysílání datových proudů, je velmi důležité nastavit všechny tyto kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="e0f38-217">Kombinace streamování a ukládání do vyrovnávací paměti programovací modely</span><span class="sxs-lookup"><span data-stu-id="e0f38-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="e0f38-218">Mnoho možných útoků vzniknout při kombinování datových proudů a jiných datových proudů programovací modely ve stejné službě.</span><span class="sxs-lookup"><span data-stu-id="e0f38-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="e0f38-219">Předpokládejme, že se kontrakt služby s dvě operace: jeden má <xref:System.IO.Stream> a jiné přijímá pole nějakého vlastního typu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="e0f38-220">Předpokládejme také, která `MaxReceivedMessageSize` je nastaven na velké hodnoty, aby první operaci pro zpracování velkých streamů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="e0f38-221">Bohužel to znamená, že velkých zpráv je nyní možné odesílat druhou operaci a deserializátor vyrovnávací paměť dat v paměti jako pole před voláním operace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="e0f38-222">Toto je možný útok s cílem odepření služby: `MaxBufferSize` kvóty neomezuje velikost těla zprávy, což je deserializátor funguje s.</span><span class="sxs-lookup"><span data-stu-id="e0f38-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="e0f38-223">Z tohoto důvodu se vyhněte kombinování operace na základě datového proudu a bez streamování v jednom kontraktu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="e0f38-224">Pokud je naprosto nutné kombinovat dvou programovacích modelů, pomocí následujících opatření:</span><span class="sxs-lookup"><span data-stu-id="e0f38-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="e0f38-225">Vypnout <xref:System.Runtime.Serialization.IExtensibleDataObject> funkce tak, že nastavíte <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> vlastnost <xref:System.ServiceModel.ServiceBehaviorAttribute> k `true`.</span><span class="sxs-lookup"><span data-stu-id="e0f38-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="e0f38-226">Tím se zajistí, že jsou pouze členy, které jsou součástí kontraktu deserializovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="e0f38-227">Nastavte <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> vlastnost <xref:System.Runtime.Serialization.DataContractSerializer> bezpečné hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="e0f38-228">Tato kvóta je také k dispozici na <xref:System.ServiceModel.ServiceBehaviorAttribute> atribut nebo prostřednictvím konfigurace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="e0f38-229">Tato kvóta omezuje počet objektů, které jsou v jedné epizodě deserializace deserializovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="e0f38-230">Za normálních okolností je v jedné epizodě deserializovat každá operace parametr nebo zprávy část textu v kontraktu zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="e0f38-231">Při deserializaci pole každé položky pole se počítá jako samostatný objekt.</span><span class="sxs-lookup"><span data-stu-id="e0f38-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="e0f38-232">Nastaví všechny kvóty čtečky XML bezpečné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="e0f38-233">Věnujte pozornost <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, a <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> a vyhnout se řetězce v jiných datových proudů operace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="e0f38-234">Projděte si seznam známých typů, dodržujte při tom, že některý z nich může být vytvořena v okamžiku (viz oddíl "Zabránit neúmyslnému typy z načítání" dále v tomto tématu).</span><span class="sxs-lookup"><span data-stu-id="e0f38-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="e0f38-235">Nepoužívejte žádné typy, které implementují <xref:System.Xml.Serialization.IXmlSerializable> rozhraní, které velké množství dat ve vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="e0f38-236">Tyto typy nepřidávejte do seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="e0f38-237">Nepoužívejte <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> pole, <xref:System.Byte> pole nebo typy, které implementují <xref:System.Runtime.Serialization.ISerializable> v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="e0f38-238">Nepoužívejte <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> pole, <xref:System.Byte> pole nebo typy, které implementují <xref:System.Runtime.Serialization.ISerializable> v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="e0f38-239">Předchozí opatření použít, když operace Streamovat používá <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="e0f38-240">Nikdy Nekombinujte streamování a jiných datových proudů programování modely ve stejné službě používáte <xref:System.Xml.Serialization.XmlSerializer>, protože nemá ochranu <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="e0f38-241">Pomalé Stream útoky</span><span class="sxs-lookup"><span data-stu-id="e0f38-241">Slow Stream Attacks</span></span>

<span data-ttu-id="e0f38-242">Třídy datových proudů útoky s cílem odepření služeb nezahrnuje využití paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="e0f38-243">Místo toho útoku zahrnuje pomalé odesílatele a příjemce dat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="e0f38-244">Při čekání na data, která mají být odeslány nebo přijaty, jsou vyčerpání prostředků, jako jsou k dispozici připojení a vlákna.</span><span class="sxs-lookup"><span data-stu-id="e0f38-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="e0f38-245">Tato situace může nastat v důsledku napadením se zlými úmysly nebo z legitimní odesílatele a příjemce na pomalé síťové připojení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="e0f38-246">Zmírnit tyto útoky, nastavte vypršení časových limitů přenosové správně.</span><span class="sxs-lookup"><span data-stu-id="e0f38-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="e0f38-247">Další informace najdete v tématu [přenosové kvóty](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-247">For more information, see [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md).</span></span> <span data-ttu-id="e0f38-248">Za druhé, nikdy nepoužívejte synchronní `Read` nebo `Write` operace při práci s datovými proudy ve službě WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="e0f38-249">Bezpečně pomocí XML</span><span class="sxs-lookup"><span data-stu-id="e0f38-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="e0f38-250">I když tato část se týká XML, informace platí také pro dokumenty JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="e0f38-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="e0f38-251">Kvóty fungují podobně, pomocí [mapování mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-251">The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="e0f38-252">Zabezpečení čtečky XML</span><span class="sxs-lookup"><span data-stu-id="e0f38-252">Secure XML Readers</span></span>

<span data-ttu-id="e0f38-253">Informační sada XML tento balíček je základem zpracování všechny zprávy ve službě WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="e0f38-254">Pokud existuje přijímá data XML z nedůvěryhodného zdroje, počet možností útoku s cílem odepření služby, který musí zmírnit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="e0f38-255">WCF obsahuje speciální, zabezpečte čtečky XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="e0f38-256">Tyto čtenáři vytvářejí automaticky, když pomocí jedné z standardních kódování ve službě WCF (text, binary nebo MTOM).</span><span class="sxs-lookup"><span data-stu-id="e0f38-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="e0f38-257">Některé funkce zabezpečení na tyto čtenáři jsou vždy aktivní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="e0f38-258">Například čtecích zařízení nikdy Nezpracovávat definice typu dokumentu (DTD), které možným zdrojem útoky s cílem odepření služeb a nikdy by měly zobrazovat v legitimní zprávy protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="e0f38-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="e0f38-259">Další funkce zabezpečení zahrnují kvóty čtečky, které musí být nakonfigurované, které jsou popsány v následující části.</span><span class="sxs-lookup"><span data-stu-id="e0f38-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="e0f38-260">Při práci přímo s čtečky XML (například při psaní vlastních vlastní kodér, nebo při práci přímo s <xref:System.ServiceModel.Channels.Message> třídy), vždy používejte čtenáři zabezpečení WCF při pokusu o práci s nedůvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="e0f38-261">Vytvoření zabezpečené čtenáři volání jeden statický objekt pro vytváření přetížení metody <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, nebo <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> na <xref:System.Xml.XmlDictionaryReader> třídy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="e0f38-262">Při vytváření čtečky předávání hodnot zabezpečené kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="e0f38-263">Nevolejte `Create` přetížení metody.</span><span class="sxs-lookup"><span data-stu-id="e0f38-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="e0f38-264">Tyto nevytvářejte čtečku WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-264">These do not create a WCF reader.</span></span> <span data-ttu-id="e0f38-265">Místo toho se vytvoří čtečku, které nejsou chráněny funkce zabezpečení popsané v této části.</span><span class="sxs-lookup"><span data-stu-id="e0f38-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="e0f38-266">Čtečka kvóty</span><span class="sxs-lookup"><span data-stu-id="e0f38-266">Reader Quotas</span></span>

<span data-ttu-id="e0f38-267">Zabezpečené čtečky XML mít pět konfigurovatelné kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="e0f38-268">Nastavení se obvykle konfigurují pomocí `ReaderQuotas` vlastnost kódování prvků vazby nebo standardní vazby nebo pomocí <xref:System.Xml.XmlDictionaryReaderQuotas> objekt předán při vytváření čtečky.</span><span class="sxs-lookup"><span data-stu-id="e0f38-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="e0f38-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="e0f38-269">MaxBytesPerRead</span></span>

<span data-ttu-id="e0f38-270">Tato kvóta omezuje počet bajtů, které jsou pro čtení v jediném `Read` operace při čtení elementu start značku a její atributy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="e0f38-271">(V případech,-datovým proudem, se nepočítá samotný název elementu proti kvóty.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> je důležitá z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="e0f38-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="e0f38-272">Název elementu a jeho atributy jsou vždy posláním ve vyrovnávací paměti při jejich čtení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="e0f38-273">Proto je důležité, abyste správně nastavena tato kvóta v režimu, aby se zabránilo nadměrnému ukládání do vyrovnávací paměti při streamování se očekává datového proudu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="e0f38-274">Zobrazit `MaxDepth` kvóty části informace o skutečný objem ukládání do vyrovnávací paměti, které u něho.</span><span class="sxs-lookup"><span data-stu-id="e0f38-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="e0f38-275">Máte příliš mnoho atributů XML může použít nepřiměřené doba zpracování, protože názvy atributů musí být vráceny jedinečný.</span><span class="sxs-lookup"><span data-stu-id="e0f38-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="e0f38-276">`MaxBytesPerRead` omezuje tuto hrozbu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="e0f38-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="e0f38-277">MaxDepth</span></span>

<span data-ttu-id="e0f38-278">Tato kvóta omezuje maximální hloubka vnoření elementů XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="e0f38-279">Například dokument "\<A >\<B >\<C / >\</B >\</A >" má hloubka vnoření tři.</span><span class="sxs-lookup"><span data-stu-id="e0f38-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="e0f38-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> je důležité z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="e0f38-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="e0f38-281">`MaxDepth` komunikuje se službou `MaxBytesPerRead`: čtecí modul dat vždy udržuje v paměti pro aktuální element a všechny jeho předchůdce, tak maximální velikost paměti spotřeba čtečky je úměrný tato dvě nastavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="e0f38-282">Při deserializaci graf objektu nejhlouběji vnořená, deserializátor musí pro přístup k celý zásobník a vyvolat neodstranitelné <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="e0f38-283">Mezi XML vnoření a objekt vnoření pro obě existuje přímou spojitost s míněním <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="e0f38-284">Použití `MaxDepth` pro zmírnění této hrozby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="e0f38-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="e0f38-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="e0f38-286">Tato kvóta na omezení velikosti čtenářovu *tabulky názvů*.</span><span class="sxs-lookup"><span data-stu-id="e0f38-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="e0f38-287">Tabulka obsahuje některé řetězce (například obory názvů a předpony), jež byly objeveny při zpracování dokumentu XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="e0f38-288">Protože tyto řetězce jsou ukládány do vyrovnávací paměti v paměti, nastavte tuto kvótu, aby se zabránilo nadměrnému ukládání do vyrovnávací paměti při streamování se očekává.</span><span class="sxs-lookup"><span data-stu-id="e0f38-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="e0f38-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="e0f38-289">MaxStringContentLength</span></span>

<span data-ttu-id="e0f38-290">Tato kvóta omezení maximální velikost řetězce, který vrací čtecí funkce XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="e0f38-291">Tato kvóta neomezuje využití paměti v samotné čtecí funkce XML, ale v komponentě, která používá čtecí modul.</span><span class="sxs-lookup"><span data-stu-id="e0f38-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="e0f38-292">Například, když <xref:System.Runtime.Serialization.DataContractSerializer> použije čtečku zabezpečený pomocí <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, to není deserializaci řetězců větší než tuto kvótu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="e0f38-293">Při použití <xref:System.Xml.XmlDictionaryReader> třídy přímo, ne všechny metody dodržování tuto kvótu, ale pouze metody, které jsou vytvořené speciálně ke čtení řetězce, jako <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e0f38-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="e0f38-294"><xref:System.Xml.XmlReader.Value%2A> Vlastnost čtecího zařízení není ovlivněn tuto kvótu a neměl by tedy používat při protection poskytuje tato kvóta je nezbytné.</span><span class="sxs-lookup"><span data-stu-id="e0f38-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="e0f38-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="e0f38-295">MaxArrayLength</span></span>

<span data-ttu-id="e0f38-296">Tato kvóta omezuje maximální velikost pole primitivních elementů, které vrací čtecí funkce XML, včetně pole bajtů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="e0f38-297">Tato kvóta neomezuje využití paměti v samotné čtecí funkce XML, ale v libovolné součásti, která používá čtecí modul.</span><span class="sxs-lookup"><span data-stu-id="e0f38-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="e0f38-298">Například, když <xref:System.Runtime.Serialization.DataContractSerializer> použije čtečku zabezpečený pomocí <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, není ji deserializovat bajtová pole větší než tuto kvótu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="e0f38-299">Je důležité nastavit této kvóty při pokusu o kombinovat datových proudů a ve vyrovnávací paměti programovacích modelů v jeden kontrakt.</span><span class="sxs-lookup"><span data-stu-id="e0f38-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="e0f38-300">Mějte na paměti, že při použití <xref:System.Xml.XmlDictionaryReader> třídy přímo, pouze metody, které jsou vytvořené speciálně pro čtení pole libovolné velikosti určité primitivní typy, jako například <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, nerespektují tuto kvótu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="e0f38-301">Hrozby konkrétní binární kódování</span><span class="sxs-lookup"><span data-stu-id="e0f38-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="e0f38-302">Binární kódování WCF podporuje XML obsahuje *slovníku řetězce* funkce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="e0f38-303">Velký řetězec může být kódovaný pomocí jenom pár bajtů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="e0f38-304">To umožňuje významného zvýšení výkonu, ale zavádí nové hrozby s cílem odepření služeb, které musí být zmírnit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="e0f38-305">Existují dva druhy slovníky: *statické* a *dynamické*.</span><span class="sxs-lookup"><span data-stu-id="e0f38-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="e0f38-306">Statické slovník je integrovaný seznam dlouhé řetězce, které mohou být zastoupeny pomocí krátký kód v binární kódování.</span><span class="sxs-lookup"><span data-stu-id="e0f38-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="e0f38-307">Tento seznam řetězců vyřešen, když čtečka je vytvořen a nelze ji změnit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="e0f38-308">Žádný z řetězce ve statickém slovníku, který ve výchozím nastavení používá WCF není dostatečně velký, aby představovat závažné ohrožení denial-of-service, i když mohou být stále používány v slovníkový útok rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e0f38-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="e0f38-309">V pokročilých scénářích, kde zadáte vlastní statickém slovníku buďte opatrní při zavádění velké slovníku řetězce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="e0f38-310">Funkce dynamické slovníky umožňuje zprávy k definování vlastní řetězce a přidružit krátké kódy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="e0f38-311">Tato mapování řetězec kódu jsou uloženy v paměti během relace celé komunikace tak, aby následné zprávy není nutné znovu odeslat řetězce a může využívat kódy, které jsou již definovány.</span><span class="sxs-lookup"><span data-stu-id="e0f38-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="e0f38-312">Tyto řetězce můžou být libovolné délky a tedy představovat hrozbu závažnější než ty, které ve statickém slovníku.</span><span class="sxs-lookup"><span data-stu-id="e0f38-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="e0f38-313">První, který musí být zmírnit hrozby je možnost je dynamický slovník (tabulka mapování řetězec kódu), příliš velká.</span><span class="sxs-lookup"><span data-stu-id="e0f38-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="e0f38-314">Tento slovník může rozšířit v průběhu několika zprávy a proto `MaxReceivedMessageSize` kvóty nenabízí žádnou ochranu, protože se vztahuje pouze na každou zprávu samostatně.</span><span class="sxs-lookup"><span data-stu-id="e0f38-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="e0f38-315">Proto samostatné <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> na existuje vlastnost <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> , která omezuje velikost slovníku.</span><span class="sxs-lookup"><span data-stu-id="e0f38-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="e0f38-316">Na rozdíl od většiny jiných kvóty tuto kvótu platí i v případě zápis zpráv.</span><span class="sxs-lookup"><span data-stu-id="e0f38-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="e0f38-317">Pokud je překročena při čtení zprávy, `QuotaExceededException` je vyvolána jako obvykle.</span><span class="sxs-lookup"><span data-stu-id="e0f38-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="e0f38-318">Pokud je překročena při zápisu zprávy, jako jsou zapsány všechny řetězce, které způsobí překročení kvóty – bez použití funkce dynamické slovníky.</span><span class="sxs-lookup"><span data-stu-id="e0f38-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="e0f38-319">Slovník rozšíření hrozby</span><span class="sxs-lookup"><span data-stu-id="e0f38-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="e0f38-320">Významné třídy specifické pro binární soubor útoků vyplývá z rozšíření slovníku.</span><span class="sxs-lookup"><span data-stu-id="e0f38-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="e0f38-321">Krátké zprávy v binárním formátu může proměnit velmi objemné zprávy v textové formě plně rozšířené Pokud velké míře využívá funkce slovníky řetězec.</span><span class="sxs-lookup"><span data-stu-id="e0f38-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="e0f38-322">Faktor rozšíření pro dynamický slovník řetězce je omezená <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> kvóty, protože žádný dynamický slovník řetězec je větší než maximální velikost celého slovníku.</span><span class="sxs-lookup"><span data-stu-id="e0f38-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="e0f38-323"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, A `MaxArrayLength` vlastnosti pouze omezit spotřebu paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="e0f38-324">Jsou obvykle není nutné ke zmírnění hrozeb. jakékoli využití datovým proudem, protože využití paměti je již omezena `MaxReceivedMessageSize`.</span><span class="sxs-lookup"><span data-stu-id="e0f38-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="e0f38-325">Ale `MaxReceivedMessageSize` počítá předběžné rozšíření bajtů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="e0f38-326">Pokud binární kódování se používá, využití paměti může potenciálně jít dál `MaxReceivedMessageSize`, je omezen pouze faktorem <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="e0f38-327">Z tohoto důvodu je důležité vždy nastavit všechny kvóty reader (zejména <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) při používání binárního kódování.</span><span class="sxs-lookup"><span data-stu-id="e0f38-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="e0f38-328">Při použití společně s binárního kódování <xref:System.Runtime.Serialization.DataContractSerializer>, `IExtensibleDataObject` rozhraní může být potenciálně nebezpečného připojit slovníkový útok rozšíření.</span><span class="sxs-lookup"><span data-stu-id="e0f38-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="e0f38-329">Toto rozhraní poskytuje v podstatě neomezené úložiště pro libovolná data, která není součástí kontraktu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="e0f38-330">Pokud nelze nastavit kvóty dostatečně nízko tak, aby `MaxSessionSize` vynásobené `MaxReceivedMessageSize` nemá představovat problém, zakažte `IExtensibleDataObject` funkce při používání binárního kódování.</span><span class="sxs-lookup"><span data-stu-id="e0f38-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="e0f38-331">Nastavte `IgnoreExtensionDataObject` vlastnost `true` na `ServiceBehaviorAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="e0f38-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="e0f38-332">Případně, Neimplementujte `IExtensibleDataObject` rozhraní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="e0f38-333">Další informace najdete v tématu [kontraktů dat dopřednou](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-333">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="e0f38-334">Souhrn kvóty</span><span class="sxs-lookup"><span data-stu-id="e0f38-334">Quotas Summary</span></span>

<span data-ttu-id="e0f38-335">Následující tabulka shrnuje pokyny kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="e0f38-336">Podmínka</span><span class="sxs-lookup"><span data-stu-id="e0f38-336">Condition</span></span>|<span data-ttu-id="e0f38-337">Důležité kvóty pro nastavení</span><span class="sxs-lookup"><span data-stu-id="e0f38-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="e0f38-338">Žádné datové proudy nebo datových proudů malých zpráv, text nebo kódování MTOM</span><span class="sxs-lookup"><span data-stu-id="e0f38-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="e0f38-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, a `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="e0f38-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="e0f38-340">Žádné datové proudy nebo datových proudů malých zpráv, binární kódování</span><span class="sxs-lookup"><span data-stu-id="e0f38-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="e0f38-341">`MaxReceivedMessageSize`, `MaxSessionSize`a vše `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="e0f38-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="e0f38-342">Streamování velkých zpráv, text nebo kódování MTOM</span><span class="sxs-lookup"><span data-stu-id="e0f38-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="e0f38-343">`MaxBufferSize` a vše `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="e0f38-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="e0f38-344">Streamování velkých zpráv binární kódování</span><span class="sxs-lookup"><span data-stu-id="e0f38-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="e0f38-345">`MaxBufferSize`, `MaxSessionSize`a vše `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="e0f38-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="e0f38-346">Vypršení časových limitů transportní vrstvy musí být vždycky nastavená a nikdy nepoužívejte synchronního čtení/zápisy při streamování se používá, bez ohledu na to, zda jsou datové proudy velké nebo malé zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="e0f38-347">Pokud máte pochybnosti o kvótu, nastavte ji na hodnotu bezpečné místo zároveň je nechává otevřené.</span><span class="sxs-lookup"><span data-stu-id="e0f38-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="e0f38-348">Zabránit spuštění škodlivého kódu</span><span class="sxs-lookup"><span data-stu-id="e0f38-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="e0f38-349">Následující obecné třídy hrozeb můžete spustit kód a mít nežádoucí účinky:</span><span class="sxs-lookup"><span data-stu-id="e0f38-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="e0f38-350">Deserializátor načte typ škodlivý, nebezpečné nebo citlivé na zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="e0f38-351">Příchozí zpráva způsobí, že deserializátor k vytvoření instance typu obvykle bezpečné takovým způsobem, který má nežádoucí důsledky.</span><span class="sxs-lookup"><span data-stu-id="e0f38-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="e0f38-352">Následující části popisují tyto třídy další hrozby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="e0f38-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="e0f38-353">DataContractSerializer</span></span>

<span data-ttu-id="e0f38-354">(Pro informace o zabezpečení <xref:System.Xml.Serialization.XmlSerializer>, najdete v příslušné dokumentaci od.) Model zabezpečení pro <xref:System.Xml.Serialization.XmlSerializer> je podobná <xref:System.Runtime.Serialization.DataContractSerializer>a liší se většinou v podrobnostech.</span><span class="sxs-lookup"><span data-stu-id="e0f38-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="e0f38-355">Například <xref:System.Xml.Serialization.XmlIncludeAttribute> atribut se používá pro zahrnutí typ místo <xref:System.Runtime.Serialization.KnownTypeAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="e0f38-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="e0f38-356">Nicméně některé hrozby jedinečné pro <xref:System.Xml.Serialization.XmlSerializer> jsou popsány dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="e0f38-357">Ochrana proti neúmyslnému typů nejde načíst</span><span class="sxs-lookup"><span data-stu-id="e0f38-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="e0f38-358">Načítání typů neúmyslnému může mít závažné důsledky, zda typ se zlými úmysly nebo právě má vedlejší účinky, citlivé na zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="e0f38-359">Typ může obsahovat ohrožení zabezpečení zneužitelné, provádět akce citlivé na zabezpečení v jeho konstruktor nebo konstruktor třídy, mají velké paměť, která usnadňuje útoky s cílem odepření služeb, nebo může vyvolat výjimky neobnovitelná.</span><span class="sxs-lookup"><span data-stu-id="e0f38-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="e0f38-360">Typy mohou mít konstruktor třídy, na kterých běží jako typ načíst a před všechny instance jsou vytvořeny.</span><span class="sxs-lookup"><span data-stu-id="e0f38-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="e0f38-361">Z těchto důvodů je potřeba sada typů, které může načíst deserializátor ovládacích prvků.</span><span class="sxs-lookup"><span data-stu-id="e0f38-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="e0f38-362"><xref:System.Runtime.Serialization.DataContractSerializer> Deserializuje volně způsobem.</span><span class="sxs-lookup"><span data-stu-id="e0f38-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="e0f38-363">Nikdy načte common language runtime (CLR) typ a sestavení názvy z příchozích dat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="e0f38-364">To se podobá chování <xref:System.Xml.Serialization.XmlSerializer>, ale liší se od chování <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="e0f38-365">Volné párování představuje určitý stupeň zabezpečení, protože vzdálenému útočníkovi nesmí uvádět libovolného typu načíst jenom pojmenováním typu ve zprávě.</span><span class="sxs-lookup"><span data-stu-id="e0f38-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="e0f38-366"><xref:System.Runtime.Serialization.DataContractSerializer> Vždy může načíst typ, který je aktuálně očekávání podle smlouvy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="e0f38-367">Například, pokud kontrakt dat má datový člen typu `Customer`, <xref:System.Runtime.Serialization.DataContractSerializer> může načíst `Customer` zadejte při deserializuje tomuto datovému členu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="e0f38-368">Kromě toho <xref:System.Runtime.Serialization.DataContractSerializer> podporuje polymorfismus.</span><span class="sxs-lookup"><span data-stu-id="e0f38-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="e0f38-369">Datový člen mohou být deklarovány jako <xref:System.Object>, ale mohou obsahovat příchozích dat `Customer` instance.</span><span class="sxs-lookup"><span data-stu-id="e0f38-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="e0f38-370">To je možné pouze tehdy, pokud `Customer` typ byl proveden "známé" deserializátor prostřednictvím jednoho z těchto mechanismů:</span><span class="sxs-lookup"><span data-stu-id="e0f38-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="e0f38-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> atribut použité u typu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="e0f38-372">`KnownTypeAttribute` atribut určení metodu, která vrátí seznam typů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="e0f38-373">`ServiceKnownTypeAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="e0f38-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="e0f38-374">`KnownTypes` Konfigurační oddíl.</span><span class="sxs-lookup"><span data-stu-id="e0f38-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="e0f38-375">Seznam známých typů explicitně předán <xref:System.Runtime.Serialization.DataContractSerializer> během konstrukce, pokud používáte serializátoru, který je přímo.</span><span class="sxs-lookup"><span data-stu-id="e0f38-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="e0f38-376">Každá z těchto mechanismů zvyšuje zavedením další typy, které můžete načíst deserializátor.</span><span class="sxs-lookup"><span data-stu-id="e0f38-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="e0f38-377">Řídit každou z těchto mechanismů, ujistěte se, že žádné škodlivého nebo nežádoucího typy jsou přidány do seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="e0f38-378">Jakmile známý typ v rozsahu, je možné načíst kdykoli a nelze vytvořit instance daného typu, i v případě, že kontrakt zakazuje jejího použití.</span><span class="sxs-lookup"><span data-stu-id="e0f38-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="e0f38-379">Předpokládejme například, typ, který "MyDangerousType" je přidána do seznamu známých typů pomocí jedné z výše uvedených mechanismů.</span><span class="sxs-lookup"><span data-stu-id="e0f38-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="e0f38-380">To znamená, že:</span><span class="sxs-lookup"><span data-stu-id="e0f38-380">This means that:</span></span>

- <span data-ttu-id="e0f38-381">`MyDangerousType` je načten a jeho spuštěním konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="e0f38-382">I v případě, že deserializaci kontraktu dat s datovým členem řetězec škodlivých zpráv může způsobit stále instance `MyDangerousType` vytvořit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="e0f38-383">Kód v `MyDangerousType`, jako je například vlastnost setter může spustit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="e0f38-384">Po dokončení, pokusí se deserializátor přiřazení této instance na datový člen řetězec a neúspěšné a zobrazí se výjimka.</span><span class="sxs-lookup"><span data-stu-id="e0f38-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="e0f38-385">Při zápisu metodu, která vrátí seznam známých typů nebo při předávání přímo do seznamu <xref:System.Runtime.Serialization.DataContractSerializer> konstruktoru, zajistěte, aby kód, který připraví seznamu je zabezpečená a pracuje jenom důvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="e0f38-386">Při zadání známých typů v konfiguraci, ujistěte se, že je konfigurační soubor zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="e0f38-387">Vždy používat silné názvy v konfiguraci (zadáním veřejného klíče podepsané sestavení, ve které se nachází typ), ale neurčují verzi typ, který chcete načíst.</span><span class="sxs-lookup"><span data-stu-id="e0f38-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="e0f38-388">Zavaděč typ automaticky vybere nejnovější verze, pokud je to možné.</span><span class="sxs-lookup"><span data-stu-id="e0f38-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="e0f38-389">Pokud chcete zadat konkrétní verzi v konfiguraci, spusťte následující rizika: Typ může mít ohrožení zabezpečení, který může být stanovena v budoucí verzi, ale verze stále načítá, protože je explicitně zadaná v konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="e0f38-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="e0f38-390">Příliš mnoho známých typů má jiné důsledky: <xref:System.Runtime.Serialization.DataContractSerializer> Vytvoří mezipaměť kódu pro serializaci nebo deserializaci v doméně aplikace, s položkou pro každý typ musí serializovat a deserializovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="e0f38-391">Tato mezipaměť se nikdy vymaže tak dlouho, dokud běží v doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="e0f38-392">Útočník, který si je vědoma, že aplikace používá mnoho známé typy proto může způsobit deserializace všechny tyto typy, což způsobí mezipaměti využívat nepřiměřeně velké množství paměti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="e0f38-393">Znemožňuje uvolnění typy v nežádoucího stavu</span><span class="sxs-lookup"><span data-stu-id="e0f38-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="e0f38-394">Typ může mít interní konzistence omezení, které se musí vynutit.</span><span class="sxs-lookup"><span data-stu-id="e0f38-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="e0f38-395">Aby se zabránilo přerušení těchto omezení během deserializace musí věnovat pozornost.</span><span class="sxs-lookup"><span data-stu-id="e0f38-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="e0f38-396">Následující příklad typu představuje stav přetlakové komory na kosmické lodě a vynucuje omezení, že vnitřní a vnější dveře nejde otevřít ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="e0f38-397">Útočník může odesílat škodlivé zpráva přibližně následujícího znění, navigace omezení a že načtete objekt do neplatného stavu, který může mít neočekávané a nežádoucí důsledky.</span><span class="sxs-lookup"><span data-stu-id="e0f38-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="e0f38-398">Tato situace se můžete vyhnout tím, že je seznámen následující body:</span><span class="sxs-lookup"><span data-stu-id="e0f38-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="e0f38-399">Když <xref:System.Runtime.Serialization.DataContractSerializer> deserializuje Většina tříd, konstruktory se nespustí.</span><span class="sxs-lookup"><span data-stu-id="e0f38-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="e0f38-400">Proto není závislý na libovolný stav správy provedena v rámci konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="e0f38-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="e0f38-401">Použijte zpětná volání tak, aby byl objekt v platném stavu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="e0f38-402">Zpětné volání označené <xref:System.Runtime.Serialization.OnDeserializedAttribute> atribut je zvlášť užitečné, protože běží po deserializaci je kompletní a má možnost k prozkoumání a opravy celkového stavu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="e0f38-403">Další informace najdete v tématu [tolerantní zpětná volání serializace](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-403">For more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="e0f38-404">Nenavrhujte typy kontraktů dat spoléhat na všechny konkrétní pořadí, ve kterých se vlastnosti musí být volána funkce setter.</span><span class="sxs-lookup"><span data-stu-id="e0f38-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="e0f38-405">Je třeba dbát pomocí starší verze typů označené <xref:System.SerializableAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="e0f38-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="e0f38-406">Mnohé z nich byly navrženy pro práci s [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] vzdálené komunikace pro použití s jenom důvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-406">Many of them were designed to work with [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting for use with trusted data only.</span></span> <span data-ttu-id="e0f38-407">Existující typy označené tento atribut nemusí byly navrženy s stavu zabezpečení v úvahu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="e0f38-408">Nespoléhejte na <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> vlastnost `DataMemberAttribute` atribut zajistit přítomnost data, co se týče stavu zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the `DataMemberAttribute` attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="e0f38-409">Data mohou být vždy `null`, `zero`, nebo `invalid`.</span><span class="sxs-lookup"><span data-stu-id="e0f38-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="e0f38-410">Nikdy důvěryhodnosti grafu objektů v daném kontextu deserializovat zdroj nedůvěryhodná data bez ověřování se nejdřív.</span><span class="sxs-lookup"><span data-stu-id="e0f38-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="e0f38-411">Každého jednotlivého objektu může být v konzistentním stavu, ale graf objektu jako celek nesmí být.</span><span class="sxs-lookup"><span data-stu-id="e0f38-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="e0f38-412">Kromě toho i v případě režimu zachování graf objektu je zakázané, deserializovat graf může mít více odkazů na stejný objekt nebo mít cyklické odkazy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="e0f38-413">Další informace najdete v tématu [serializace a deserializace](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-413">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="e0f38-414">Bezpečně používat NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="e0f38-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="e0f38-415"><xref:System.Runtime.Serialization.NetDataContractSerializer> Je Serializační stroj, který používá určitou úzkou svázanost na typy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="e0f38-416">Podobá se to <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="e0f38-417">To znamená, určuje, jaký typ pro vytvoření instance načtením [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] názvů typů a sestavení z příchozí data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-417">That is, it determines which type to instantiate by reading the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type name from the incoming data.</span></span> <span data-ttu-id="e0f38-418">I když je součástí WCF, není nijak zadaný zapojení Tato serializační stroj; vlastní kód musí být napsané.</span><span class="sxs-lookup"><span data-stu-id="e0f38-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="e0f38-419">`NetDataContractSerializer` Slouží především pro usnadnění migrace z [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting do WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-419">The `NetDataContractSerializer` is provided primarily to ease migration from [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting to WCF.</span></span> <span data-ttu-id="e0f38-420">Další informace najdete v příslušné části v [serializace a deserializace](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="e0f38-420">For more information, see the relevant section in [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>

<span data-ttu-id="e0f38-421">Protože vlastní zprávě může znamenat libovolného typu je možné načíst, <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanismus je ze své podstaty nezabezpečené a by měla sloužit pouze dodávat důvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="e0f38-422">Je možné zabezpečit napsáním vazač zabezpečené a omezením typu typ, který umožňuje načíst pouze bezpečné typů (pomocí <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> vlastnost).</span><span class="sxs-lookup"><span data-stu-id="e0f38-422">It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property).</span></span>

<span data-ttu-id="e0f38-423">I v případě, že se používá pro důvěryhodného data, příchozí data můžou nedostatečně určovat typ, který chcete načíst, zejména v případě, <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> je nastavena na <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="e0f38-424">Každý, kdo má přístup do adresáře aplikace nebo do globální mezipaměti sestavení můžete nahradit typem škodlivý místo ten, který se má načíst.</span><span class="sxs-lookup"><span data-stu-id="e0f38-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="e0f38-425">Vždy zajistěte zabezpečení adresáře aplikace a globální mezipaměti sestavení správně nastavením oprávnění.</span><span class="sxs-lookup"><span data-stu-id="e0f38-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="e0f38-426">Obecně platí, že pokud je povoleno částečně důvěryhodným kódem přístup k vaší `NetDataContractSerializer` instance nebo jinak kontrolujete náhradní selektor (<xref:System.Runtime.Serialization.ISurrogateSelector>) nebo vazač serializace (<xref:System.Runtime.Serialization.SerializationBinder>), kód může vykonávat spoustu ovládací prvek průběhu procesu serializaci nebo deserializaci.</span><span class="sxs-lookup"><span data-stu-id="e0f38-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="e0f38-427">Například to může vložit libovolné typy, způsobit zpřístupnění informací, manipulovat s Výsledný graf objektu nebo serializovaná data nebo přetečení výsledná serializovaného datového proudu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="e0f38-428">Jiné potíže se zabezpečením s `NetDataContractSerializer` je útok DOS, není provádění hrozbu škodlivý kód.</span><span class="sxs-lookup"><span data-stu-id="e0f38-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="e0f38-429">Při použití `NetDataContractSerializer`vždy nastavte <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> kvótu pro bezpečné hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="e0f38-430">Je snadné vytvořit malé škodlivý zprávu, která přiděluje pole objektů, jejichž velikost je omezena pouze této kvóty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="e0f38-431">XmlSerializer specifické hrozby</span><span class="sxs-lookup"><span data-stu-id="e0f38-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="e0f38-432"><xref:System.Xml.Serialization.XmlSerializer> Model zabezpečení je podobná <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="e0f38-433">Několik hrozby, ale jsou jedinečné pro <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e0f38-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="e0f38-434"><xref:System.Xml.Serialization.XmlSerializer> Generuje *sestavení serializace* za běhu, které obsahují kód, který ve skutečnosti serializuje a deserializuje; tato sestavení se vytvářejí v adresáři dočasné soubory.</span><span class="sxs-lookup"><span data-stu-id="e0f38-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="e0f38-435">Pokud některé procesu nebo uživatel nemá přístupová práva do tohoto adresáře, se může přepsat serializaci/deserializaci kódu pomocí libovolného kódu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="e0f38-436"><xref:System.Xml.Serialization.XmlSerializer> Pak spustí tento kód namísto kódu pro serializaci nebo deserializaci pomocí kontext zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="e0f38-437">Ujistěte se, že oprávnění jsou nastavené správně na adresáře dočasných souborů k tomu nedocházelo.</span><span class="sxs-lookup"><span data-stu-id="e0f38-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="e0f38-438"><xref:System.Xml.Serialization.XmlSerializer> Má také režim, ve kterém použije místo aby generovala za běhu serializace předem generovaného sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="e0f38-439">Tento režim se aktivuje vždy, když <xref:System.Xml.Serialization.XmlSerializer> najdete vhodné serializace sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="e0f38-440"><xref:System.Xml.Serialization.XmlSerializer> Kontroly, zda byl podepsán sestavení serializace pomocí stejného klíče, který se použil k podepsání sestavení obsahující typy serializována.</span><span class="sxs-lookup"><span data-stu-id="e0f38-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="e0f38-441">To nabízí ochranu ze škodlivých sestavení se maskovaný jako sestavení serializace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="e0f38-442">Ale pokud je sestavení obsahující Serializovatelné typy není podepsaná, <xref:System.Xml.Serialization.XmlSerializer> nemůže provést tuto kontrolu a ten se správným názvem používá žádné sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="e0f38-443">To umožňuje spuštění škodlivého kódu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-443">This makes running malicious code possible.</span></span> <span data-ttu-id="e0f38-444">Vždy podepsat sestavení, které obsahují Serializovatelné typy nebo důsledně řídit přístup k adresáři vaší aplikace a mezipaměti globálního sestavení tak, aby zabránila zavlečení škodlivého sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="e0f38-445"><xref:System.Xml.Serialization.XmlSerializer> Můžou podléhat útoku DOS.</span><span class="sxs-lookup"><span data-stu-id="e0f38-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="e0f38-446"><xref:System.Xml.Serialization.XmlSerializer> Nemá `MaxItemsInObjectGraph` kvóty (tak, jak jsou k dispozici na <xref:System.Runtime.Serialization.DataContractSerializer>).</span><span class="sxs-lookup"><span data-stu-id="e0f38-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="e0f38-447">Díky tomu se deserializuje libovolné množství objektů jediným omezením velikosti zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="e0f38-448">Hrozby s částečnou důvěryhodností</span><span class="sxs-lookup"><span data-stu-id="e0f38-448">Partial Trust Threats</span></span>

<span data-ttu-id="e0f38-449">Mějte na paměti následující aspekty týkající se hrozeb týkající se kód s částečnou důvěryhodností.</span><span class="sxs-lookup"><span data-stu-id="e0f38-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="e0f38-450">Tyto hrozby obsahovat škodlivé částečně důvěryhodným kódem, jakož i škodlivý částečně důvěryhodným kódem v kombinaci s další scénáře útoků (například částečně důvěryhodným kódem, který vytvoří konkrétní řetězec a potom deserializaci).</span><span class="sxs-lookup"><span data-stu-id="e0f38-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="e0f38-451">Při použití součásti žádné serializace, nikdy uplatnit žádná oprávnění než použití, i v případě, že scénář celá serializace je v rámci oboru vaše kontrolní výraz a nezabýváte se všech nedůvěryhodná data nebo objekty.</span><span class="sxs-lookup"><span data-stu-id="e0f38-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="e0f38-452">Použití může vést k ohrožení zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="e0f38-453">V případech, kdy částečně důvěryhodným kódem má kontrolu nad procesu serializace, buď prostřednictvím bodů rozšiřitelnosti (náhrady), typy serializována, nebo jiným způsobem může způsobit částečně důvěryhodným kódem serializátor pro výstup velké množství data v serializovaném proudu, který může způsobit odepření služby (DoS) k příjemci tento datový proud.</span><span class="sxs-lookup"><span data-stu-id="e0f38-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="e0f38-454">Pokud serializujete data určená pro cíl, který je citlivý na ně DoS, serializaci částečně důvěryhodné typy nebo jinak umožní serializace ovládacího prvku částečně důvěryhodným kódem.</span><span class="sxs-lookup"><span data-stu-id="e0f38-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="e0f38-455">Pokud je povoleno částečně důvěryhodným kódem přístup k vaší <xref:System.Runtime.Serialization.DataContractSerializer> instance nebo jinak kontrolujete [náhrady kontraktů dat](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), uplatnit velkou kontrolu nad procesu serializace/deserializace.</span><span class="sxs-lookup"><span data-stu-id="e0f38-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="e0f38-456">Například to může vložit libovolné typy, způsobit zpřístupnění informací, manipulovat s Výsledný graf objektu nebo serializovaná data nebo přetečení výsledná serializovaného datového proudu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="e0f38-457">Ekvivalentní <xref:System.Runtime.Serialization.NetDataContractSerializer> hrozeb je popsaný v části "Použití NetDataContractSerializer bezpečně".</span><span class="sxs-lookup"><span data-stu-id="e0f38-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="e0f38-458">Pokud <xref:System.Runtime.Serialization.DataContractAttribute> atributu je použité u typu (nebo typ označen jako `[Serializable]` , ale není `ISerializable`), deserializátor může vytvořit instanci takového typu, i v případě, že všechny konstruktory jsou privátní nebo chráněné podle požadavků.</span><span class="sxs-lookup"><span data-stu-id="e0f38-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as `[Serializable]` but is not `ISerializable`), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="e0f38-459">Nikdy nepředpokládejte výsledek deserializace, pokud data k deserializaci není důvěryhodný a jste si jisti, že všechny známé typy jsou typy, které důvěřujete.</span><span class="sxs-lookup"><span data-stu-id="e0f38-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="e0f38-460">Všimněte si, že známých typů nejsou načtené z konfiguračního souboru aplikace (však jsou načteny z konfiguračního souboru počítače) při spouštění v částečném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="e0f38-461">Pokud předáte `DataContractSerializer` instanci s náhradní přidán do částečně důvěryhodným kódem, kód můžete změnit lze měnit nastavení na této náhradní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-461">If you pass a `DataContractSerializer` instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="e0f38-462">Deserializovaný objekt Pokud čtecí funkce XML (nebo data v něm) pochází z částečně důvěryhodného kódu, považovat za výsledný objekt deserializovaný nedůvěryhodná data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="e0f38-463">Fakt, který <xref:System.Runtime.Serialization.ExtensionDataObject> typ nemá žádné veřejné členy neznamená, že data v něm jsou zabezpečená.</span><span class="sxs-lookup"><span data-stu-id="e0f38-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="e0f38-464">Například pokud jste ze zdroje dat privileged deserializovat do objektu, ve kterém některá data se nachází, pak ručně, tento objekt částečně důvěryhodným kódem, částečně důvěryhodným kódem můžete číst data v `ExtensionDataObject` o serializaci objektu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="e0f38-465">Zvažte nastavení <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> k `true` při deserializaci na objekt, který je pozdější ze zdroje dat privileged předán částečně důvěryhodným kódem.</span><span class="sxs-lookup"><span data-stu-id="e0f38-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="e0f38-466"><xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> podporují serializaci privátní, chráněné, interní a veřejné členy v úplném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="e0f38-467">Nicméně v částečném vztahu důvěryhodnosti pouze veřejné členy lze serializovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="e0f38-468">A `SecurityException` je vyvolána, pokud se aplikace pokusí serializovat neveřejný člen.</span><span class="sxs-lookup"><span data-stu-id="e0f38-468">A `SecurityException` is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="e0f38-469">Povolit interní nebo chráněné členy interní se musí serializovat v částečném vztahu důvěryhodnosti, použijte `System.Runtime.CompilerServices.InternalsVisibleTo` atribut sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-469">To allow internal or protected internal members to be serialized in partial trust, use the `System.Runtime.CompilerServices.InternalsVisibleTo` assembly attribute.</span></span> <span data-ttu-id="e0f38-470">Tento atribut umožňuje sestavení, které chcete-li deklarovat, že její interní členy jsou viditelné pro některé sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="e0f38-471">V takovém případě sestavení, které chce mít jeho vnitřní členy serializovat deklaruje, že její interní členy jsou viditelné pro System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="e0f38-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="e0f38-472">Výhodou tohoto přístupu je, že nevyžaduje cestu k generování kódu se zvýšenými oprávněními.</span><span class="sxs-lookup"><span data-stu-id="e0f38-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="e0f38-473">Ve stejnou dobu existují dvě hlavní nevýhody.</span><span class="sxs-lookup"><span data-stu-id="e0f38-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="e0f38-474">První nevýhodou je, že vlastnost opt-in z `InternalsVisibleTo` atribut je celé sestavení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-474">The first disadvantage is that the opt-in property of the `InternalsVisibleTo` attribute is assembly-wide.</span></span> <span data-ttu-id="e0f38-475">To znamená nelze zadat, že pouze určité třída může mít jeho vnitřní členy serializovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="e0f38-476">Samozřejmě stále můžete není určená k serializaci konkrétní vnitřní člen, stačí přidat není `DataMember` atribut pro tohoto člena.</span><span class="sxs-lookup"><span data-stu-id="e0f38-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a `DataMember` attribute to that member.</span></span> <span data-ttu-id="e0f38-477">Podobně vývojář můžete také zvolit, jestli členem interní místo soukromé nebo chráněné, se týká mírné viditelnost.</span><span class="sxs-lookup"><span data-stu-id="e0f38-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="e0f38-478">Druhý nevýhodou je, že stále nepodporuje soukromé nebo chráněné členy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="e0f38-479">Pro ilustraci použití `InternalsVisibleTo` atribut v částečném vztahu důvěryhodnosti, vezměte v úvahu následující program:</span><span class="sxs-lookup"><span data-stu-id="e0f38-479">To illustrate the use of the `InternalsVisibleTo` attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="e0f38-480">V příkladu výše `PermissionsHelper.InternetZone` odpovídá `PermissionSet` pro částečnou důvěryhodností.</span><span class="sxs-lookup"><span data-stu-id="e0f38-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the `PermissionSet` for partial trust.</span></span> <span data-ttu-id="e0f38-481">Nyní, bez `InternalsVisibleToAttribute`, aplikace selže, vyvolání `SecurityException` označující, že neveřejné členy nejde serializovat v částečném vztahu důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="e0f38-481">Now, without `InternalsVisibleToAttribute`, the application will fail, throwing a `SecurityException` indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="e0f38-482">Nicméně pokud jsme do zdrojového souboru přidejte následující řádek, program se úspěšně spustí.</span><span class="sxs-lookup"><span data-stu-id="e0f38-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="e0f38-483">Další aspekty správy stavu</span><span class="sxs-lookup"><span data-stu-id="e0f38-483">Other State Management Concerns</span></span>

<span data-ttu-id="e0f38-484">Několik obavy týkající se správy stavu objektů jsou za zmínku:</span><span class="sxs-lookup"><span data-stu-id="e0f38-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="e0f38-485">Pokud používáte model programování podle datového proudu streamování přenosu, zpracování zprávy dochází při doručení zprávy.</span><span class="sxs-lookup"><span data-stu-id="e0f38-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="e0f38-486">Odesílatel zprávy se může přerušit operace odeslání uprostřed datový proud a ponechání kódu v nepředvídatelném stavu, pokud byla očekávána další obsah.</span><span class="sxs-lookup"><span data-stu-id="e0f38-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="e0f38-487">Obecně platí, nespoléhejte na datový proud je kompletní a neprovádějte žádnou práci v rámci operace na základě datového proudu, který se nedá vrátit zpět v případě, že datový proud byl přerušen.</span><span class="sxs-lookup"><span data-stu-id="e0f38-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="e0f38-488">To platí i pro situace, ve kterém zprávy mohou být poškozené za tělem streamování (například ho pravděpodobně chybí koncová značka pro obálku protokolu SOAP nebo může mít druhý text zprávy).</span><span class="sxs-lookup"><span data-stu-id="e0f38-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="e0f38-489">Použití `IExtensibleDataObject` funkce může způsobit, že citlivá data, aby byly vypuštěny.</span><span class="sxs-lookup"><span data-stu-id="e0f38-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="e0f38-490">Pokud přijímáte data z nedůvěryhodného zdroje do kontrakty dat s `IExtensibleObjectData` a později znovu generování ho na zabezpečený kanál, ve kterém jsou podepsané zprávy, můžete se potenciálně ručící za nic vědět o data.</span><span class="sxs-lookup"><span data-stu-id="e0f38-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="e0f38-491">Celkový stav, který odesíláte kromě toho může být neplatný, pokud jste známými i neznámými časti dat vezměte v úvahu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="e0f38-492">Nastavením buď selektivně rozšíření dat vlastnosti této situaci zabránili `null` nebo selektivně vypnutí `IExtensibleObjectData` funkce.</span><span class="sxs-lookup"><span data-stu-id="e0f38-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="e0f38-493">Import schématu</span><span class="sxs-lookup"><span data-stu-id="e0f38-493">Schema Import</span></span>

<span data-ttu-id="e0f38-494">Za normálních okolností proces import schématu pro generování typů dojde pouze v době návrhu, například při použití [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) na webové služby sloužící ke generování třídy klienta.</span><span class="sxs-lookup"><span data-stu-id="e0f38-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="e0f38-495">V pokročilejších scénářích, ale může zpracovat schématu v době běhu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="e0f38-496">Mějte na paměti, že to můžete zveřejnit můžete na riziko, s cílem odepření služby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="e0f38-497">Některé schéma může trvat dlouhou dobu, které se mají naimportovat.</span><span class="sxs-lookup"><span data-stu-id="e0f38-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="e0f38-498">Nikdy nepoužívejte <xref:System.Xml.Serialization.XmlSerializer> komponenty import schématu v takových scénářích pokud schémata pravděpodobně pochází z nedůvěryhodného zdroje.</span><span class="sxs-lookup"><span data-stu-id="e0f38-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="e0f38-499">Hrozby specifické pro integraci technologie ASP.NET AJAX</span><span class="sxs-lookup"><span data-stu-id="e0f38-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="e0f38-500">Když uživatel implementuje <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> nebo <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF zpřístupňuje koncový bod, který může přijmout zprávy XML a JSON.</span><span class="sxs-lookup"><span data-stu-id="e0f38-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="e0f38-501">Je však pouze jednu sadu kvóty čtečky, používají čtecí funkce XML a čtečky JSON.</span><span class="sxs-lookup"><span data-stu-id="e0f38-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="e0f38-502">Některá nastavení kvóty může být vhodné pro jeden Čtenář, ale příliš velký pro ostatní.</span><span class="sxs-lookup"><span data-stu-id="e0f38-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="e0f38-503">Při implementaci `WebScriptEnablingBehavior`, uživatel má povolenou možnost k vystavení proxy server JavaScript v koncovém bodě.</span><span class="sxs-lookup"><span data-stu-id="e0f38-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="e0f38-504">Musí přestat považovat následující problémy se zabezpečením:</span><span class="sxs-lookup"><span data-stu-id="e0f38-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="e0f38-505">Informace týkající se služby (názvy operace, názvy parametrů a tak dále) můžete získat prozkoumáním proxy server JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e0f38-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="e0f38-506">Při použití koncového bodu jazyka JavaScript, citlivé a soukromé informace může uchovávat v mezipaměti webového prohlížeče klienta.</span><span class="sxs-lookup"><span data-stu-id="e0f38-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="e0f38-507">Poznámka: pro komponenty</span><span class="sxs-lookup"><span data-stu-id="e0f38-507">A Note on Components</span></span>

<span data-ttu-id="e0f38-508">WCF je systém flexibilní a přizpůsobitelné.</span><span class="sxs-lookup"><span data-stu-id="e0f38-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="e0f38-509">Většina obsahu v tomto tématu se soustředí na nejběžnějších scénářů využití WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="e0f38-510">Je však možné kombinovat komponenty, které poskytuje WCF mnoha různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="e0f38-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="e0f38-511">Je důležité si uvědomit důsledky zabezpečení pomocí jednotlivých komponent.</span><span class="sxs-lookup"><span data-stu-id="e0f38-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="e0f38-512">Zejména:</span><span class="sxs-lookup"><span data-stu-id="e0f38-512">In particular:</span></span>

- <span data-ttu-id="e0f38-513">Pokud je nutné použít čtečky XML, použijte čtecích zařízení <xref:System.Xml.XmlDictionaryReader> třída poskytuje na rozdíl od jinými čtenáři.</span><span class="sxs-lookup"><span data-stu-id="e0f38-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="e0f38-514">Bezpečné čtenáři se vytvoří s použitím <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, nebo <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e0f38-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="e0f38-515">Nepoužívejte <xref:System.Xml.XmlReader.Create%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e0f38-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="e0f38-516">Vždy nakonfigurujte bezpečné kvóty čtecích zařízení.</span><span class="sxs-lookup"><span data-stu-id="e0f38-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="e0f38-517">Serializace moduly ve službě WCF jsou zabezpečené jenom při použití s zabezpečené čtečky XML z WCF.</span><span class="sxs-lookup"><span data-stu-id="e0f38-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="e0f38-518">Při použití <xref:System.Runtime.Serialization.DataContractSerializer> k deserializaci potenciálně nedůvěryhodná data, vždycky nastavený <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="e0f38-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="e0f38-519">Při vytváření zprávy, nastavte `maxSizeOfHeaders` parametr Pokud `MaxReceivedMessageSize` nenabízí dostatek ochrany.</span><span class="sxs-lookup"><span data-stu-id="e0f38-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="e0f38-520">Při vytváření kodéru, vždy nakonfigurovat příslušné kvóty, jako jsou například `MaxSessionSize` a `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="e0f38-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="e0f38-521">Pokud používáte filtr XPath zprávy, nastavte <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> a omezit tak množství filtr návštěv z uzlů XML.</span><span class="sxs-lookup"><span data-stu-id="e0f38-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="e0f38-522">Nepoužívejte výrazy XPath, které může trvat dlouhou dobu compute, aniž byste museli navštívit mnoha uzly.</span><span class="sxs-lookup"><span data-stu-id="e0f38-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="e0f38-523">Obecně platí při použití jakékoli součásti, která přijímá kvótu, pochopit jeho vliv na zabezpečení a nastavte ho na bezpečné hodnotu.</span><span class="sxs-lookup"><span data-stu-id="e0f38-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="e0f38-524">Viz také:</span><span class="sxs-lookup"><span data-stu-id="e0f38-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="e0f38-525">Známé typy kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="e0f38-525">Data Contract Known Types</span></span>](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)
