---
title: Strukturální přehled přenosu dat
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: 22d2ce71d850fc799304cadf7e8d7d8af2670d5d
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/18/2019
ms.locfileid: "59315878"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="608c8-102">Strukturální přehled přenosu dat</span><span class="sxs-lookup"><span data-stu-id="608c8-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="608c8-103">Windows Communication Foundation (WCF) můžete představit jako infrastruktura zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="608c8-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="608c8-104">Může přijímat zprávy, zpracovat je a jejich vypravování do uživatelského kódu pro další akce, nebo můžete vytvořit zprávy z dat zadané v uživatelském kódu a doručujte je na cíli.</span><span class="sxs-lookup"><span data-stu-id="608c8-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="608c8-105">Toto téma, které je určené pro pokročilé vývojáře, popisuje architekturu zpracování zpráv a omezením data.</span><span class="sxs-lookup"><span data-stu-id="608c8-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="608c8-106">Jednodušší, orientovaných zobrazení toho, jak odesílat a přijímat data, najdete v části [zadání přenosu dat v kontraktech služeb](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="608c8-107">Toto téma popisuje podrobnosti implementace WCF, které nejsou viditelné prozkoumáním objektový model WCF.</span><span class="sxs-lookup"><span data-stu-id="608c8-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="608c8-108">Dvě slova upozornění jsou v pořadí s ohledem na podrobnosti implementace dokument.</span><span class="sxs-lookup"><span data-stu-id="608c8-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="608c8-109">Popisy jsou nejprve zjednodušené; Skutečná implementace může být složitější z důvodu optimalizace nebo z jiných důvodů.</span><span class="sxs-lookup"><span data-stu-id="608c8-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="608c8-110">Za druhé, můžete se nikdy spoléhají na podrobnosti konkrétní implementace, dokonce i uvedeno, protože ty můžou změnit bez předchozího upozornění z verze na verzi nebo dokonce i v servisní verze.</span><span class="sxs-lookup"><span data-stu-id="608c8-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="608c8-111">Základní architektura</span><span class="sxs-lookup"><span data-stu-id="608c8-111">Basic Architecture</span></span>  
 <span data-ttu-id="608c8-112">V jádru možnosti zpracování zpráv WCF je <xref:System.ServiceModel.Channels.Message> třída, která je popsána v části [používání třídy Message](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span> <span data-ttu-id="608c8-113">Běhové komponenty technologie WCF je možné rozdělit do dvou hlavních částí: zásobník kanálu a architektura služby s <xref:System.ServiceModel.Channels.Message> třídy se spojovací bod.</span><span class="sxs-lookup"><span data-stu-id="608c8-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="608c8-114">Kanál zásobníku je zodpovědný za převod mezi platné <xref:System.ServiceModel.Channels.Message> instance a některá z akcí, která odpovídá odesílání nebo přijímání dat zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="608c8-115">Na straně odesílání trvá kanál zásobníku platný <xref:System.ServiceModel.Channels.Message> instance a po nějaké zpracování provede určitou akci, která odpovídá logicky k odeslání zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="608c8-116">Akce může odesílat TCP nebo HTTP paketů služby Řízení front zpráv služby Řízení front zpráv, zápis zprávy do databáze, ukládání do sdílené složky nebo jakoukoli jinou akci, v závislosti na implementaci.</span><span class="sxs-lookup"><span data-stu-id="608c8-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="608c8-117">Nejběžnější akce odesílá zprávy přes síťový protokol.</span><span class="sxs-lookup"><span data-stu-id="608c8-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="608c8-118">Na straně příjmu se stane opak – akce je zjištěna (který může být pakety TCP nebo HTTP přijaté nebo jakoukoli jinou akci), a po zpracování kanálu zásobníku převádí tuto akci platný <xref:System.ServiceModel.Channels.Message> instance.</span><span class="sxs-lookup"><span data-stu-id="608c8-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="608c8-119">Můžou využít WCF pomocí <xref:System.ServiceModel.Channels.Message> třídy a kanál zásobníku přímo.</span><span class="sxs-lookup"><span data-stu-id="608c8-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="608c8-120">To uděláte tak ale obtížné a časově náročné.</span><span class="sxs-lookup"><span data-stu-id="608c8-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="608c8-121">Kromě toho <xref:System.ServiceModel.Channels.Message> objekt nepodporuje metadata, takže se silnými typy klientů WCF nelze generovat, pokud používáte WCF tímto způsobem.</span><span class="sxs-lookup"><span data-stu-id="608c8-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="608c8-122">Proto WCF obsahuje rozhraní služby, které poskytuje snadným ovládáním programovací model, který vám pomůže vytvořit a přijímat `Message` objekty.</span><span class="sxs-lookup"><span data-stu-id="608c8-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="608c8-123">Architektura služby map služeb [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typů prostřednictvím pojem kontrakty služeb a odesílá zprávy do operace uživatelů, které jsou jednoduše [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] metody označené <xref:System.ServiceModel.OperationContractAttribute> atribut (Další podrobnosti najdete v tématu [Navrhování kontraktů služby](../../../../docs/framework/wcf/designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="608c8-123">The service framework maps services to [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types through the notion of service contracts, and dispatches messages to user operations that are simply [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)).</span></span> <span data-ttu-id="608c8-124">Tyto metody mohou mít parametry a vracet hodnoty.</span><span class="sxs-lookup"><span data-stu-id="608c8-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="608c8-125">Na straně služeb, převede příchozí architektura služby <xref:System.ServiceModel.Channels.Message> instancí do parametrů a převede návratové hodnoty do odesílaných <xref:System.ServiceModel.Channels.Message> instancí.</span><span class="sxs-lookup"><span data-stu-id="608c8-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="608c8-126">Na straně klienta se provádí opak.</span><span class="sxs-lookup"><span data-stu-id="608c8-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="608c8-127">Představme si třeba, `FindAirfare` operace níže.</span><span class="sxs-lookup"><span data-stu-id="608c8-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="608c8-128">Předpokládejme, že `FindAirfare` volá se na klientovi.</span><span class="sxs-lookup"><span data-stu-id="608c8-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="608c8-129">Architektura služby na straně klienta převede `FromCity` a `ToCity` parametry do odchozí <xref:System.ServiceModel.Channels.Message> instance a předá ji do zásobníku kanálu k odeslání.</span><span class="sxs-lookup"><span data-stu-id="608c8-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="608c8-130">Na straně služeb když <xref:System.ServiceModel.Channels.Message> instance e-mailu ze zásobníku kanál, architektura služby extrahuje relevantní data ze zprávy k naplnění `FromCity` a `ToCity` parametry a potom volání straně služby `FindAirfare` Metoda.</span><span class="sxs-lookup"><span data-stu-id="608c8-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="608c8-131">Po návratu metody rozhraní služby trvá vrácené celočíselné hodnotě a `IsDirectFlight` výstupní parametr a vytvoří <xref:System.ServiceModel.Channels.Message> instance objektu, který obsahuje tyto informace.</span><span class="sxs-lookup"><span data-stu-id="608c8-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="608c8-132">Pak předá `Message` instanci kanálu zásobníku odeslána zpět klientovi.</span><span class="sxs-lookup"><span data-stu-id="608c8-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="608c8-133">Na straně klienta <xref:System.ServiceModel.Channels.Message> instance, která obsahuje zprávy s odpovědí vyplývá ze zásobníku kanálu.</span><span class="sxs-lookup"><span data-stu-id="608c8-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="608c8-134">Architektura služby extrahuje návratovou hodnotu a `IsDirectFlight` hodnotu a vrátí do volajícího klienta.</span><span class="sxs-lookup"><span data-stu-id="608c8-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="608c8-135">Message – třída</span><span class="sxs-lookup"><span data-stu-id="608c8-135">Message Class</span></span>  
 <span data-ttu-id="608c8-136"><xref:System.ServiceModel.Channels.Message> Třída je zamýšlená jako abstraktní reprezentaci zprávy, ale jeho návrhu se silnou vazbu na zprávu protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="608c8-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="608c8-137">A <xref:System.ServiceModel.Channels.Message> obsahuje tři hlavní údaje: text zprávy, záhlaví zpráv a vlastnosti zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="608c8-138">Text zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-138">Message Body</span></span>  
 <span data-ttu-id="608c8-139">Text zprávy je určený k reprezentaci skutečná data datové části zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="608c8-140">Text zprávy je vždy reprezentována jako informační sadu XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="608c8-141">To neznamená, že všechny zprávy vytvořené ani přijmout ve službě WCF musí být ve formátu XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="608c8-142">Záleží zásobníku kanálu se rozhodnout, jak interpretovat obsah zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="608c8-143">Může generovat ve formátu XML, převeďte jej na jiném formátu nebo ještě ji vynechte úplně.</span><span class="sxs-lookup"><span data-stu-id="608c8-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="608c8-144">S největším počtem dodávek vazby WCF, samozřejmě, text zprávy je vyjádřena jako obsah XML v části tělo obálky protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="608c8-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="608c8-145">Je důležité si uvědomit, `Message` třídy nezbytně nemusí obsahovat vyrovnávací paměti s daty XML představující tělo.</span><span class="sxs-lookup"><span data-stu-id="608c8-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="608c8-146">Logicky `Message` obsahuje informační sadu XML, ale tento informační sadu dynamicky vytvořený a můžou existovat nikdy fyzicky v paměti.</span><span class="sxs-lookup"><span data-stu-id="608c8-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="608c8-147">Ukládání dat do datové části zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="608c8-148">Neexistuje žádný jednotný mechanismus k vložení dat do textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="608c8-149"><xref:System.ServiceModel.Channels.Message> Třída je abstraktní metody, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, který přebírá <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="608c8-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="608c8-150">Každá podtřída <xref:System.ServiceModel.Channels.Message> třídy je zodpovědná za potlačení této metody a zápis vlastní obsah.</span><span class="sxs-lookup"><span data-stu-id="608c8-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="608c8-151">Tělo zprávy obsahuje logicky informační sadu XML, který `OnWriteBodyContent` vytvoří.</span><span class="sxs-lookup"><span data-stu-id="608c8-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="608c8-152">Představte si třeba následující `Message` podtřídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="608c8-153">Fyzicky `AirfareRequestMessage` instance obsahuje pouze dva řetězce ("fromCity" a "toCity").</span><span class="sxs-lookup"><span data-stu-id="608c8-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="608c8-154">Však logicky zpráva obsahuje následující informační sadu XML:</span><span class="sxs-lookup"><span data-stu-id="608c8-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="608c8-155">Samozřejmě nejsou obvykle vytvoříte zprávy tímto způsobem, protože architektura služby můžete použít k vytvoření zprávy jako na předchozím z operace kontraktu parametry.</span><span class="sxs-lookup"><span data-stu-id="608c8-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="608c8-156">Kromě toho <xref:System.ServiceModel.Channels.Message> třída má statické `CreateMessage` metody, které můžete použít k vytvoření zpráv pomocí běžných typů obsahu: prázdný zprávy, zprávu, která obsahuje objekt serializován do formátu XML s <xref:System.Runtime.Serialization.DataContractSerializer>, zprávu, která obsahuje SOAP selhání, zprávu, která obsahuje kód XML reprezentována <xref:System.Xml.XmlReader>, a tak dále.</span><span class="sxs-lookup"><span data-stu-id="608c8-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="608c8-157">Získání dat z textu zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="608c8-158">Můžete extrahovat data uložená v textu zprávy dva hlavní způsoby:</span><span class="sxs-lookup"><span data-stu-id="608c8-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
-   <span data-ttu-id="608c8-159">Obsah celé zprávy najednou můžete získat voláním <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> metoda a předáním zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="608c8-160">Zprávu o dokončení text je zapsán do tohoto zapisovače.</span><span class="sxs-lookup"><span data-stu-id="608c8-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="608c8-161">Získávání těla celá zpráva v jednom okamžiku se také nazývá *zápisu zprávy*.</span><span class="sxs-lookup"><span data-stu-id="608c8-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="608c8-162">Zápis probíhá primárně v zásobníku kanál při odesílání zprávy – některé části zásobníku kanálu se obvykle získáte přístup k celé zprávy, kódovat a jeho odeslání.</span><span class="sxs-lookup"><span data-stu-id="608c8-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
-   <span data-ttu-id="608c8-163">Dalším způsobem, jak získat informace o mimo tělo zprávy je volání <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> a získat čtecí funkce XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="608c8-164">Tělo zprávy lze poté přistupovat sekvenčně, podle potřeby pomocí volání metody čtecího zařízení.</span><span class="sxs-lookup"><span data-stu-id="608c8-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="608c8-165">Získávání zprávu textu část jednotlivé se také nazývá *čtení zprávy*.</span><span class="sxs-lookup"><span data-stu-id="608c8-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="608c8-166">Čtení zprávy se používá především v rámci služby rozhraní při přijímání zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="608c8-167">Například, když <xref:System.Runtime.Serialization.DataContractSerializer> se používá, bude architektura služby získat čtecí funkce XML v těle a předejte jej do deserializace modul, který pak začne zprávu prvek po prvku pro čtení a vytváření odpovídající objekt grafu.</span><span class="sxs-lookup"><span data-stu-id="608c8-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="608c8-168">Text zprávy je možné načíst pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="608c8-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="608c8-169">Díky tomu je možné pracovat s posouváním pouze datové proudy.</span><span class="sxs-lookup"><span data-stu-id="608c8-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="608c8-170">Můžete například napsat <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> přepsání, která čte z <xref:System.IO.FileStream> a vrátí výsledky jako informační sadu XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="608c8-171">Musíte nikdy "zpět" na začátku souboru.</span><span class="sxs-lookup"><span data-stu-id="608c8-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="608c8-172">`WriteBodyContents` a `GetReaderAtBodyContents` metody jednoduše zkontrolujte, že nikdy nebyly načtené před text zprávy a poté zavolejte `OnWriteBodyContents` nebo `OnGetReaderAtBodyContents`v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="608c8-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="608c8-173">Použití zpráv ve WCF</span><span class="sxs-lookup"><span data-stu-id="608c8-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="608c8-174">Většina zprávy mohou být klasifikovány jako buď *odchozí* (ty, které jsou vytvořeny pomocí rozhraní služby do zásobníku channel) nebo *příchozí* (těch, které přicházejí z kanálu zásobníku a jsou interpretuje rozhraním služby).</span><span class="sxs-lookup"><span data-stu-id="608c8-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="608c8-175">Kromě toho zásobníku kanál můžou fungovat v režimu ve vyrovnávací paměti nebo datových proudů.</span><span class="sxs-lookup"><span data-stu-id="608c8-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="608c8-176">Architektura služby mohou také vystavovat proudu nebo nonstreamed programovací model.</span><span class="sxs-lookup"><span data-stu-id="608c8-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="608c8-177">To vede k případy uvedené v následující tabulce, spolu s zjednodušené podrobnostmi o jejich implementaci.</span><span class="sxs-lookup"><span data-stu-id="608c8-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="608c8-178">Typ zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-178">Message type</span></span>|<span data-ttu-id="608c8-179">Data těla zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-179">Body data in message</span></span>|<span data-ttu-id="608c8-180">Popište implementaci (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="608c8-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="608c8-181">Implementace čtení (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="608c8-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="608c8-182">Odchozí, vytvořené z nonstreamed programovací model</span><span class="sxs-lookup"><span data-stu-id="608c8-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="608c8-183">Data potřebná k zápisu zprávy (například objekt a <xref:System.Runtime.Serialization.DataContractSerializer> potřeba ho serializovat instance) \*</span><span class="sxs-lookup"><span data-stu-id="608c8-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="608c8-184">Vlastní logiku k zapsání zprávy podle uložených dat (například volání `WriteObject` na `DataContractSerializer` Pokud tomu tak serializátoru, který je používán) \*</span><span class="sxs-lookup"><span data-stu-id="608c8-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="608c8-185">Volání `OnWriteBodyContents`, výsledky ve vyrovnávací paměti, vraťte se čtecí funkce XML přes vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="608c8-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="608c8-186">Odchozí, vytvořené z proudu programovací model</span><span class="sxs-lookup"><span data-stu-id="608c8-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="608c8-187">`Stream` s daty, která má být proveden zápis \*</span><span class="sxs-lookup"><span data-stu-id="608c8-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="608c8-188">Zápis dat z pomocí uloženého datového proudu <xref:System.Xml.IStreamProvider> mechanismus \*</span><span class="sxs-lookup"><span data-stu-id="608c8-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="608c8-189">Volání `OnWriteBodyContents`, výsledky ve vyrovnávací paměti, vraťte se čtecí funkce XML přes vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="608c8-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="608c8-190">Příchozí z datových proudů kanál zásobníku</span><span class="sxs-lookup"><span data-stu-id="608c8-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="608c8-191">A `Stream` objekt, který představuje data přicházející přes síť pomocí <xref:System.Xml.XmlReader> nad ním</span><span class="sxs-lookup"><span data-stu-id="608c8-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="608c8-192">Vypsat obsah od uložené `XmlReader` pomocí `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="608c8-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="608c8-193">Vrátí uloženou `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="608c8-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="608c8-194">Příchozí ze zásobníku nonstreaming kanálu</span><span class="sxs-lookup"><span data-stu-id="608c8-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="608c8-195">Vyrovnávací paměť, která obsahuje text dat pomocí `XmlReader` nad ním</span><span class="sxs-lookup"><span data-stu-id="608c8-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="608c8-196">Zapíše obsah od uložené `XmlReader` pomocí `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="608c8-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="608c8-197">Vrátí uložené lang</span><span class="sxs-lookup"><span data-stu-id="608c8-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="608c8-198">\* Tyto položky nejsou implementované přímo v `Message` podtřídy, ale v podtřídy třídy <xref:System.ServiceModel.Channels.BodyWriter> třídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="608c8-199">Další informace o <xref:System.ServiceModel.Channels.BodyWriter>, naleznete v tématu [používání třídy Message](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="608c8-200">Záhlaví zpráv</span><span class="sxs-lookup"><span data-stu-id="608c8-200">Message Headers</span></span>  
 <span data-ttu-id="608c8-201">Zpráva může obsahovat záhlaví.</span><span class="sxs-lookup"><span data-stu-id="608c8-201">A message may contain headers.</span></span> <span data-ttu-id="608c8-202">Záhlaví logicky se skládá z XML informační sadu, která souvisí s názvem, obor názvů a několik dalších vlastností.</span><span class="sxs-lookup"><span data-stu-id="608c8-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="608c8-203">Záhlaví zprávy jsou přístupné pomocí `Headers` vlastnost <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="608c8-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="608c8-204">Je reprezentován jednotlivé hlavičky <xref:System.ServiceModel.Channels.MessageHeader> třídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="608c8-205">Za normálních okolností záhlaví zpráv se mapují na záhlaví zpráv SOAP při použití kanálu zásobníku nakonfigurováno pro práci s zprávy protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="608c8-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="608c8-206">Vložení informací do záhlaví zprávy a extrahování informací z ní je podobný používání tělo zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="608c8-207">Proces je poněkud jednodušší, protože streamování se nepodporuje.</span><span class="sxs-lookup"><span data-stu-id="608c8-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="608c8-208">Je možné pracovat s více než jednou obsah stejné záhlaví a záhlaví je přístupná v pořadí, vynucení záhlaví vždy být ukládány do vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="608c8-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="608c8-209">Neexistuje žádný k dispozici pro získání čtecí funkce XML v záhlaví pro obecné účely mechanismus, ale neexistuje `MessageHeader` WCF, který představuje čitelné hlavička s takovou schopnost vnitřní podtřídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="608c8-210">Tento typ `MessageHeader` vzniká zásobníkem kanálu, pokud zpráva hlavičky vlastní aplikace je k dispozici ve.</span><span class="sxs-lookup"><span data-stu-id="608c8-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="608c8-211">Architektura služby použít modul deserializace, jako tomu <xref:System.Runtime.Serialization.DataContractSerializer>, interpretovat tyto hlavičky.</span><span class="sxs-lookup"><span data-stu-id="608c8-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="608c8-212">Další informace najdete v tématu [používání třídy Message](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-212">For more information, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="608c8-213">Vlastnosti zprávy</span><span class="sxs-lookup"><span data-stu-id="608c8-213">Message Properties</span></span>  
 <span data-ttu-id="608c8-214">Zpráva může obsahovat vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="608c8-214">A message may contain properties.</span></span> <span data-ttu-id="608c8-215">A *vlastnost* libovolnou [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objekt, který je přidružený k názvu řetězce.</span><span class="sxs-lookup"><span data-stu-id="608c8-215">A *property* is any [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] object that is associated with a string name.</span></span> <span data-ttu-id="608c8-216">Vlastnosti jsou přístupné prostřednictvím `Properties` vlastnost `Message`.</span><span class="sxs-lookup"><span data-stu-id="608c8-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="608c8-217">Na rozdíl od text zprávy a záhlaví zpráv (což obvykle mapují na SOAP body a záhlaví SOAP, v uvedeném pořadí) jsou vlastnosti zprávy nejsou obvykle odesílané nebo přijímané spolu s zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="608c8-218">Vlastnosti zprávy existovat především jako komunikační mechanizmus k předávání dat o zprávy mezi různými kanály v zásobníku kanálu a mezi zásobníku kanálu a model služby.</span><span class="sxs-lookup"><span data-stu-id="608c8-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="608c8-219">Například je kanál přenosu HTTP jsou součástí WCF vyprodukovat různých stavové kódy HTTP, jako například "404 (Nenalezeno)" a "500 (vnitřní chyba serveru)," při odesílání odpovědi na klienty.</span><span class="sxs-lookup"><span data-stu-id="608c8-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="608c8-220">Před odesláním zprávy s odpovědí, zkontroluje, zda `Properties` z `Message` obsahovat vlastnost s názvem "httpResponse", který obsahuje objekt typu <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span><span class="sxs-lookup"><span data-stu-id="608c8-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="608c8-221">Pokud takovou vlastnost najde, se zabývá <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> vlastnosti a použít tento kód stavu.</span><span class="sxs-lookup"><span data-stu-id="608c8-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="608c8-222">Pokud se nenajde, výchozí "200 (OK)" kód se používá.</span><span class="sxs-lookup"><span data-stu-id="608c8-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="608c8-223">Další informace najdete v tématu [používání třídy Message](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-223">For more information, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="608c8-224">Zpráva jako celek</span><span class="sxs-lookup"><span data-stu-id="608c8-224">The Message as a Whole</span></span>  
 <span data-ttu-id="608c8-225">Zatím jsme mají popsané metody pro přístup k různé části zprávy v izolaci.</span><span class="sxs-lookup"><span data-stu-id="608c8-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="608c8-226">Ale <xref:System.ServiceModel.Channels.Message> třída rovněž poskytuje metody pro práci s celou zprávu jako celek.</span><span class="sxs-lookup"><span data-stu-id="608c8-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="608c8-227">Například `WriteMessage` Metoda zapíše celé zprávy do zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="608c8-228">Chcete-li to možné, musí být definována mapování mezi celý `Message` instanci a informační sadu XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="608c8-229">Ve skutečnosti takové mapování existuje: WCF pomocí standardu SOAP definuje toto mapování.</span><span class="sxs-lookup"><span data-stu-id="608c8-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="608c8-230">Když `Message` instance je zapsán jako informační sadu XML platný obálku protokolu SOAP, která obsahuje zprávy je výsledný informační sadu.</span><span class="sxs-lookup"><span data-stu-id="608c8-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="608c8-231">Proto `WriteMessage` by normálně proveďte následující kroky:</span><span class="sxs-lookup"><span data-stu-id="608c8-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="608c8-232">Zapsat element obálky protokolu SOAP počáteční značku.</span><span class="sxs-lookup"><span data-stu-id="608c8-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="608c8-233">Zapsat element záhlaví SOAP počáteční značku, vypsat všechny hlavičky a zavřít prvku záhlaví.</span><span class="sxs-lookup"><span data-stu-id="608c8-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="608c8-234">Zapsat element body SOAP počáteční značku.</span><span class="sxs-lookup"><span data-stu-id="608c8-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="608c8-235">Volání `WriteBodyContents` nebo ekvivalentní metody k zapsání textu.</span><span class="sxs-lookup"><span data-stu-id="608c8-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="608c8-236">Zavřete elementy textu a obálky.</span><span class="sxs-lookup"><span data-stu-id="608c8-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="608c8-237">V předchozích krocích jsou úzce vázané na standardu protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="608c8-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="608c8-238">Toto je složité fakt, že více verzí modulu protokolu SOAP existují, například není možné vypsat element obálky protokolu SOAP správně nainstalovat bez mého verze protokolu SOAP používá.</span><span class="sxs-lookup"><span data-stu-id="608c8-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="608c8-239">Také v některých případech může být žádoucí vypnutí této komplexní SOAP konkrétní mapování úplně.</span><span class="sxs-lookup"><span data-stu-id="608c8-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="608c8-240">Pro tyto účely `Version` vlastnost je k dispozici na `Message`.</span><span class="sxs-lookup"><span data-stu-id="608c8-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="608c8-241">Můžete nastavit na verzi protokolu SOAP k použití při zápisu zprávu nebo může být nastavena na `None` zabránit všechna SOAP konkrétní mapování.</span><span class="sxs-lookup"><span data-stu-id="608c8-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="608c8-242">Pokud `Version` je nastavena na `None`, metody, které pracují s act celá zpráva jako v případě, že zprávy se skládal z jeho těla pouze, například `WriteMessage` by jednoduše volala `WriteBodyContents` místo více kroků uvedených výše.</span><span class="sxs-lookup"><span data-stu-id="608c8-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="608c8-243">Očekává se, která na příchozích zprávách `Version` bude automaticky zjištěno a zařídit správné.</span><span class="sxs-lookup"><span data-stu-id="608c8-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="608c8-244">Kanál zásobníku</span><span class="sxs-lookup"><span data-stu-id="608c8-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="608c8-245">Kanály</span><span class="sxs-lookup"><span data-stu-id="608c8-245">Channels</span></span>  
 <span data-ttu-id="608c8-246">Jak je uvedeno dříve, kanál zásobníku je zodpovědný za převod odchozí <xref:System.ServiceModel.Channels.Message> instance některé akce na základě (jako je například odesílání paketů v síti) nebo převodu některé akce (např. přijetí síťových paketů) na příchozí `Message` instance.</span><span class="sxs-lookup"><span data-stu-id="608c8-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="608c8-247">Zásobník kanál se skládá z jednoho nebo několika kanálů, v pořadí řazení.</span><span class="sxs-lookup"><span data-stu-id="608c8-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="608c8-248">Odchozí `Message` instance předána první kanál v zásobníku (také nazývané *nejvyššího kanál*), který předává je na další kanál v zásobníku a tak dále.</span><span class="sxs-lookup"><span data-stu-id="608c8-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="608c8-249">Zpráva ukončení v poslední kanálu, která je volána *přenosový kanál*.</span><span class="sxs-lookup"><span data-stu-id="608c8-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="608c8-250">Příchozí zprávy pocházejí z přenosový kanál a z kanálu channel jsou předány do zásobníku.</span><span class="sxs-lookup"><span data-stu-id="608c8-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="608c8-251">Z nejvyšší kanálu obvykle v rámci služby předávání zpráv.</span><span class="sxs-lookup"><span data-stu-id="608c8-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="608c8-252">Když je obvykle vzor pro zprávy aplikace, některé kanály mohou fungovat trochu jinak, například mohli zasílat zprávy své vlastní infrastruktury bez předává zprávy z kanálu výše.</span><span class="sxs-lookup"><span data-stu-id="608c8-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="608c8-253">Při průchodu zásobníku kanály fungovat u zprávy různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="608c8-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="608c8-254">Nejběžnější operace je přidání hlavičky odchozích zpráv a čtení záhlaví na příchozí zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="608c8-255">Kanál může například compute digitální podpis zprávy a přidejte jako záhlaví.</span><span class="sxs-lookup"><span data-stu-id="608c8-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="608c8-256">Kanál může také zkontrolovat toto záhlaví digitální podpis na příchozí zprávy a blokování zpráv, které nemají žádný platný podpis v cestě zásobníkem kanálu provádění.</span><span class="sxs-lookup"><span data-stu-id="608c8-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="608c8-257">Kanály také často nastavte nebo zkontrolujte vlastnosti zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="608c8-258">Text zprávy je obvykle nedojde ke změně, i když je to povoleno, například zabezpečený kanál WCF můžete šifrovat tělo zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="608c8-259">Přenosové kanály a zpráva kodérů</span><span class="sxs-lookup"><span data-stu-id="608c8-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="608c8-260">Nejspodnějších kanálu v zásobníku je zodpovědný za skutečně transformace odchozí <xref:System.ServiceModel.Channels.Message>, jak upravit podle jiných kanálů na určitou akci.</span><span class="sxs-lookup"><span data-stu-id="608c8-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="608c8-261">Na straně příjmu, to je kanál, který převede některé akce do `Message` , jiné nástroje procesu.</span><span class="sxs-lookup"><span data-stu-id="608c8-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="608c8-262">Jak bylo uvedeno dříve, může se lišit akce: odesílání nebo přijímání síťových paketů pomocí různých protokolů, čtení nebo zápisu se zprávou v databázi, nebo služby Řízení front nebo vyřazování z fronty zpráv do fronty služby Řízení front zpráv, k poskytování ale několik příkladů.</span><span class="sxs-lookup"><span data-stu-id="608c8-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="608c8-263">Všechny tyto akce mají jedno společné: vyžadují transformaci mezi WCF`Message` instancí a skupinu skutečný počet bajtů, které mohou být odesílány, přijetí, číst, zapsat, zařazených do fronty nebo vyřazených z fronty.</span><span class="sxs-lookup"><span data-stu-id="608c8-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="608c8-264">Proces převodu `Message` do skupiny podle bajtů se nazývá *kódování*a reverzní procesem vytvoření `Message` ze skupiny bajtů se nazývá *dekódování*.</span><span class="sxs-lookup"><span data-stu-id="608c8-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="608c8-265">Většina přenosové kanály pomocí komponenty volá *zprávy kodérů* k provedení kódování a dekódování práce.</span><span class="sxs-lookup"><span data-stu-id="608c8-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="608c8-266">Kodér zprávy je podtřídou třídy <xref:System.ServiceModel.Channels.MessageEncoder> třídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="608c8-267">`MessageEncoder` obsahuje různé `ReadMessage` a `WriteMessage` přetížení metody pro převod mezi `Message` a skupiny bajtů.</span><span class="sxs-lookup"><span data-stu-id="608c8-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="608c8-268">Na straně odesílání vyrovnávací paměti přenosový kanál předá `Message` objekt, který přijal z kanálu nad ním na `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="608c8-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="608c8-269">Získá zpět pole bajtů, které poté používá k provedení akcí (například balení těchto bajtů jako platný pakety protokolu TCP a jejich odesílání do správné cíl).</span><span class="sxs-lookup"><span data-stu-id="608c8-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="608c8-270">Streamování kanál přenosu nejdříve vytvoří `Stream` (například přes odchozí připojení TCP) a poté předá i `Stream` a `Message` musí odeslat na příslušné `WriteMessage` přetížení, která zapíše zpráva .</span><span class="sxs-lookup"><span data-stu-id="608c8-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="608c8-271">Na straně příjmu extrahuje vyrovnávací paměti přenosový kanál Příchozí bajty (např. z příchozí pakety protokolu TCP) do pole a volání `ReadMessage` zobrazíte `Message` objektu, můžete předat další zásobníkem kanálu.</span><span class="sxs-lookup"><span data-stu-id="608c8-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="608c8-272">Streamování přenosový kanál vytvoří `Stream` objektu (například sítě datového proudu přes příchozí připojení protokolu TCP) a, který se předává `ReadMessage` chcete vrátit zpět `Message` objektu.</span><span class="sxs-lookup"><span data-stu-id="608c8-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="608c8-273">Není to povinné; oddělení mezi přenosové kanály a kodér zprávy je možné psát přenosový kanál, který nepoužívá kodéru zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="608c8-274">Ale výhodou toto oddělení je snadné složení.</span><span class="sxs-lookup"><span data-stu-id="608c8-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="608c8-275">Za předpokladu, přenosový kanál používá pouze základní <xref:System.ServiceModel.Channels.MessageEncoder>, můžete pracovat s WCF nebo kodéru zpráv třetích stran.</span><span class="sxs-lookup"><span data-stu-id="608c8-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="608c8-276">Stejného kodéru, je obvykle možné v jakémkoli jiném kanálu přenosu.</span><span class="sxs-lookup"><span data-stu-id="608c8-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="608c8-277">Operace kodéru zpráv</span><span class="sxs-lookup"><span data-stu-id="608c8-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="608c8-278">K popisu typické operaci kodéru, je vhodné vzít v úvahu následující čtyři případy.</span><span class="sxs-lookup"><span data-stu-id="608c8-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="608c8-279">Operace</span><span class="sxs-lookup"><span data-stu-id="608c8-279">Operation</span></span>|<span data-ttu-id="608c8-280">Komentář</span><span class="sxs-lookup"><span data-stu-id="608c8-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="608c8-281">Kódování a uložená do vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="608c8-281">Encoding, Buffered</span></span>|<span data-ttu-id="608c8-282">V režimu vyrovnávací paměti kodér obvykle vytvoří proměnné velikosti vyrovnávací paměti a pak vytvoří zapisovače XML nad ním.</span><span class="sxs-lookup"><span data-stu-id="608c8-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="608c8-283">Poté zavolá <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> ve zprávě zakódována, který zapíše hlavičky a potom na textu pomocí <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, jak je popsáno v předchozí části o `Message` v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="608c8-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="608c8-284">Pro přenosový kanál k použití se potom vrátí obsah vyrovnávací paměti (reprezentovány jako pole bajtů).</span><span class="sxs-lookup"><span data-stu-id="608c8-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="608c8-285">Kódování a streamování</span><span class="sxs-lookup"><span data-stu-id="608c8-285">Encoding, Streamed</span></span>|<span data-ttu-id="608c8-286">Operace je v režimu proudu, podobně jako výše, ale jednodušší.</span><span class="sxs-lookup"><span data-stu-id="608c8-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="608c8-287">Není nutné vyrovnávací paměti.</span><span class="sxs-lookup"><span data-stu-id="608c8-287">There is no need for a buffer.</span></span> <span data-ttu-id="608c8-288">Zapisovače XML se obvykle vytváří přes datový proud a <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> je volán na `Message` vypsat do tohoto zapisovače.</span><span class="sxs-lookup"><span data-stu-id="608c8-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="608c8-289">Dekódování, ukládány do vyrovnávací paměti</span><span class="sxs-lookup"><span data-stu-id="608c8-289">Decoding, Buffered</span></span>|<span data-ttu-id="608c8-290">Při dekódování v režimu vyrovnávací paměti, speciální `Message` podtřídy, který obsahuje data ve vyrovnávací paměti je obvykle vytvořen.</span><span class="sxs-lookup"><span data-stu-id="608c8-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="608c8-291">Jsou přečteny hlavičky zprávy a je vytvořen čtecí modul XML, který je umístěn v textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="608c8-292">Toto je čtecí modul, který bude vrácen s <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="608c8-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="608c8-293">Dekódování, streamování</span><span class="sxs-lookup"><span data-stu-id="608c8-293">Decoding, Streamed</span></span>|<span data-ttu-id="608c8-294">Při dekódování v proudu režimu, se obvykle vytvoří zvláštní zpráva podtřídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="608c8-295">Datový proud je pokročilý tak akorát na tyto hlavičky přečíst a umístěte ho na obsah zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="608c8-296">Čtecí funkce XML se pak vytvoří v datovém proudu.</span><span class="sxs-lookup"><span data-stu-id="608c8-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="608c8-297">Toto je čtecí modul, který bude vrácen s <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="608c8-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="608c8-298">Kodérů můžete provádět také další funkce.</span><span class="sxs-lookup"><span data-stu-id="608c8-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="608c8-299">Například u kodérů může vytvořit fond z XML čtečky a zapisovače.</span><span class="sxs-lookup"><span data-stu-id="608c8-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="608c8-300">Je nákladné pokaždé, když je zapotřebí vytvořit nový čtecí modul XML nebo zapisovač.</span><span class="sxs-lookup"><span data-stu-id="608c8-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="608c8-301">Proto kodérů obvykle udržovat fondu čtenářů a zapisovačů konfigurovat velikost fondu.</span><span class="sxs-lookup"><span data-stu-id="608c8-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="608c8-302">V popisech kodér operace je popsáno výše vždy, když frázi "Vytvoření čtečky a zapisovače XML" se používá, je obvykle znamená, že "proveďte jednu z fondu, nebo vytvořit novou, pokud není k dispozici."</span><span class="sxs-lookup"><span data-stu-id="608c8-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="608c8-303">Kodér (a `Message` podtřídy vytvoří při dekódování výplně) obsahují logiku k vrácení čtečky a zapisovače do fondů, jakmile už nejsou potřeba (například když `Message` je uzavřený).</span><span class="sxs-lookup"><span data-stu-id="608c8-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="608c8-304">WCF poskytuje tři kodérů zprávu, i když je možné vytvořit další vlastní typy.</span><span class="sxs-lookup"><span data-stu-id="608c8-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="608c8-305">Zadané typy jsou Text, binární soubor a zpráv přenosu optimalizace mechanismus (MTOM).</span><span class="sxs-lookup"><span data-stu-id="608c8-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="608c8-306">Tyto možnosti jsou popsány podrobně v [výběr kodéru zprávy](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-306">These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="608c8-307">Rozhraní IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="608c8-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="608c8-308">Při zápisu odchozí zprávy, která obsahuje tělo streamovaná do zapisovače XML <xref:System.ServiceModel.Channels.Message> využívá posloupnost volání podobně jako v následujícím jeho <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementace:</span><span class="sxs-lookup"><span data-stu-id="608c8-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
-   <span data-ttu-id="608c8-309">Zapisovat všechny potřebné informace před stream (například otevírání – značka XML).</span><span class="sxs-lookup"><span data-stu-id="608c8-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
-   <span data-ttu-id="608c8-310">Zápis datového proudu.</span><span class="sxs-lookup"><span data-stu-id="608c8-310">Write the stream.</span></span>  
  
-   <span data-ttu-id="608c8-311">Zapisovat všechny informace o streamu (například uzavírací značky XML).</span><span class="sxs-lookup"><span data-stu-id="608c8-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="608c8-312">Tento postup funguje dobře s kódování, které jsou podobné textové kódování XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="608c8-313">Ale některé kódování Neumísťujte informační sadu XML informace (například značky pro počáteční a koncovou elementů XML) společně s data obsažená v rámci prvků.</span><span class="sxs-lookup"><span data-stu-id="608c8-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="608c8-314">Kódování MTOM, například zprávy je rozdělit na více částí.</span><span class="sxs-lookup"><span data-stu-id="608c8-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="608c8-315">Jednou ze součástí obsahuje informační sadu XML, které mohou obsahovat odkazy na ostatní části pro obsah skutečným prvkem.</span><span class="sxs-lookup"><span data-stu-id="608c8-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="608c8-316">Informační sada XML je obvykle malé ve srovnání s datovým proudem obsah, proto je vhodné uložit do vyrovnávací paměti informační sadu, tak zapisovat a pak zapsat obsah datovým proudem způsobem.</span><span class="sxs-lookup"><span data-stu-id="608c8-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="608c8-317">To znamená, že čas zavření značky elementu je zapsán, datového proudu by neměla být napsán takto ještě.</span><span class="sxs-lookup"><span data-stu-id="608c8-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="608c8-318">Pro tento účel <xref:System.Xml.IStreamProvider> rozhraní se používá.</span><span class="sxs-lookup"><span data-stu-id="608c8-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="608c8-319">Rozhraní <xref:System.Xml.IStreamProvider.GetStream> metodu, která vrací datový proud, který má být proveden zápis.</span><span class="sxs-lookup"><span data-stu-id="608c8-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="608c8-320">Správný způsob k zapsání textu zapsal zprávu v <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> vypadá takto:</span><span class="sxs-lookup"><span data-stu-id="608c8-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="608c8-321">Zapisovat všechny potřebné informace před stream (například otevírání – značka XML).</span><span class="sxs-lookup"><span data-stu-id="608c8-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="608c8-322">Volání `WriteValue` přetížit na <xref:System.Xml.XmlDictionaryWriter> , která má <xref:System.Xml.IStreamProvider>, pomocí `IStreamProvider` implementace, která vrací datový proud, který má být proveden zápis.</span><span class="sxs-lookup"><span data-stu-id="608c8-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="608c8-323">Zapisovat všechny informace o streamu (například uzavírací značky XML).</span><span class="sxs-lookup"><span data-stu-id="608c8-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="608c8-324">S tímto přístupem zapisovací modul XML se zobrazí možnost výběru při volání <xref:System.Xml.IStreamProvider.GetStream> a vypsat streamovaná data.</span><span class="sxs-lookup"><span data-stu-id="608c8-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="608c8-325">Textové a binární zapisovače XML se například volání okamžitě a vypsat streamovaná obsah mezi úvodní a koncovou značkou.</span><span class="sxs-lookup"><span data-stu-id="608c8-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="608c8-326">Zapisovací funkce MTOM rozhodnout volání <xref:System.Xml.IStreamProvider.GetStream> později, až bude připravená k zápisu odpovídající část zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="608c8-327">Reprezentující Data v rámci služby</span><span class="sxs-lookup"><span data-stu-id="608c8-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="608c8-328">Jak je uvedeno v části "Základní architekturu" tohoto tématu, architektura služby je součástí WCF, který mimo jiné, je zodpovědný za převod mezi uživatelsky přívětivé programovací model pro data zprávy, ve skutečnosti `Message` instancí.</span><span class="sxs-lookup"><span data-stu-id="608c8-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="608c8-329">Za normálních okolností je reprezentován výměně zpráv v rámci služby jako [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] metoda označena <xref:System.ServiceModel.OperationContractAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="608c8-329">Normally, a message exchange is represented in the service framework as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="608c8-330">Metoda využít některé parametry a může vrátit návratovou hodnotu nebo parametry (nebo obojí).</span><span class="sxs-lookup"><span data-stu-id="608c8-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="608c8-331">Na straně služby vstupních parametrů představují příchozí zpráva a návratová hodnota a výstupní parametry představují odchozí zprávu.</span><span class="sxs-lookup"><span data-stu-id="608c8-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="608c8-332">Na straně klienta naopak je true.</span><span class="sxs-lookup"><span data-stu-id="608c8-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="608c8-333">Programovací model pro popis zpráv s použitím parametrů a návratové hodnoty je podrobně popsán v [zadání přenosu dat v kontraktech služeb](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="608c8-334">Tato část se však poskytli stručný přehled.</span><span class="sxs-lookup"><span data-stu-id="608c8-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="608c8-335">Programovací modely</span><span class="sxs-lookup"><span data-stu-id="608c8-335">Programming Models</span></span>  
 <span data-ttu-id="608c8-336">Architektura služby WCF podporuje pět různých programovacích modelů popisem zprávy:</span><span class="sxs-lookup"><span data-stu-id="608c8-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="608c8-337">1. Prázdná zpráva</span><span class="sxs-lookup"><span data-stu-id="608c8-337">1. The Empty Message</span></span>  
 <span data-ttu-id="608c8-338">Toto je nejjednodušší případ.</span><span class="sxs-lookup"><span data-stu-id="608c8-338">This is the simplest case.</span></span> <span data-ttu-id="608c8-339">K popisu prázdný příchozí zprávy, se nepoužívá žádné vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="608c8-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="608c8-340">K popisu prázdný odchozí zprávy, použijte návratovou hodnotu typu void a nepoužívají žádné výstupní parametry:</span><span class="sxs-lookup"><span data-stu-id="608c8-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="608c8-341">Všimněte si, že se liší od Jednosměrná operace kontraktu:</span><span class="sxs-lookup"><span data-stu-id="608c8-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="608c8-342">V `SetDesiredTemperature` například vzoru výměny zpráv obousměrný je popsáno.</span><span class="sxs-lookup"><span data-stu-id="608c8-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="608c8-343">Operace vrátí zprávy, ale je prázdný.</span><span class="sxs-lookup"><span data-stu-id="608c8-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="608c8-344">Je možné vrátit chybu z operace.</span><span class="sxs-lookup"><span data-stu-id="608c8-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="608c8-345">V příkladu "Nastavit žárovky" je jednosměrný vzoru výměny zpráv, takže neexistuje žádná odchozí zprávy k popisu.</span><span class="sxs-lookup"><span data-stu-id="608c8-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="608c8-346">Služba nemůže komunikovat v tomto případě libovolný stav zpět do klienta.</span><span class="sxs-lookup"><span data-stu-id="608c8-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="608c8-347">2. Používání třídy Message přímo</span><span class="sxs-lookup"><span data-stu-id="608c8-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="608c8-348">Je možné použít <xref:System.ServiceModel.Channels.Message> třídy (nebo některá z jejích podtříd) přímo v kontrakt operace.</span><span class="sxs-lookup"><span data-stu-id="608c8-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="608c8-349">V takovém případě stačí předá architektura služby `Message` z operace na kanálu zásobníku a naopak, se žádné další zpracování.</span><span class="sxs-lookup"><span data-stu-id="608c8-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="608c8-350">Existují dva hlavní případy použití `Message` přímo.</span><span class="sxs-lookup"><span data-stu-id="608c8-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="608c8-351">Můžete to pro pokročilé scénáře, pokud žádná z jiných programovacích modelů poskytuje dostatek flexibilitu k popisu zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="608c8-352">Například můžete chtít použít soubory na disku k podrobnému popisu zprávy, se stávají záhlaví zpráv a stát tělo zprávy obsah souboru vlastnosti souboru.</span><span class="sxs-lookup"><span data-stu-id="608c8-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="608c8-353">Potom můžete vytvořit něco podobného následujícímu.</span><span class="sxs-lookup"><span data-stu-id="608c8-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="608c8-354">Druhý běžné účely `Message` v kontrakt operace při služby nezáleží na konkrétní zprávy obsah a funguje jako na černé políčko ve zprávě.</span><span class="sxs-lookup"><span data-stu-id="608c8-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="608c8-355">Například může mít službu, která předává zprávy více ostatním příjemcům.</span><span class="sxs-lookup"><span data-stu-id="608c8-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="608c8-356">Kontrakt může být napsán takto.</span><span class="sxs-lookup"><span data-stu-id="608c8-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="608c8-357">Akce = "\*" řádku efektivně vypne odesílání zpráv a zajistí, že všechny zprávy odeslané do `IForwardingService` kontraktu dostanou k `ForwardMessage` operace.</span><span class="sxs-lookup"><span data-stu-id="608c8-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="608c8-358">(Za normálních okolností dispečer prozkoumá "Action" záhlaví zprávy k určení operace, která je určená pro zpracování na polovinu.</span><span class="sxs-lookup"><span data-stu-id="608c8-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="608c8-359">Akce = "\*" znamená "všechny možné hodnoty záhlaví akce".) Kombinací akcí = "\*" a pomocí zprávy jako parametr je označováno jako "univerzální kontrakt", protože je schopný přijímat všechny možné zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="608c8-360">Aby bylo možné odeslat všechny zprávy je to možné, použijte zprávy jako návratovou hodnotu a nastavte `ReplyAction` na "\*".</span><span class="sxs-lookup"><span data-stu-id="608c8-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="608c8-361">Architektura služby zabráníte přidání své vlastní záhlaví akce, umožňuje řídit tato záhlaví pomocí `Message` objektu se vrátit.</span><span class="sxs-lookup"><span data-stu-id="608c8-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="608c8-362">3. Kontrakty zpráv</span><span class="sxs-lookup"><span data-stu-id="608c8-362">3. Message Contracts</span></span>  
 <span data-ttu-id="608c8-363">WCF poskytuje deklarativní programovací model pro popis zprávy označované jako *kontrakty zprávy*.</span><span class="sxs-lookup"><span data-stu-id="608c8-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="608c8-364">Tento model je podrobně popsán v [použití kontraktů zpráv](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-364">This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span></span> <span data-ttu-id="608c8-365">V podstatě celá zpráva představuje jeden [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typ, který používá atributů, například <xref:System.ServiceModel.MessageBodyMemberAttribute> a <xref:System.ServiceModel.MessageHeaderAttribute> k popisu, které části třídy kontraktu zprávy by měl mapovat na kterou část zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-365">Essentially, the entire message is represented by a single [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="608c8-366">Kontrakty zpráv poskytují velké množství kontrolu nad výsledný `Message` instance (i když samozřejmě mnohem ovládací prvek jako pomocí `Message` přímo třídu).</span><span class="sxs-lookup"><span data-stu-id="608c8-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="608c8-367">Například zpráv se často skládají z více kusů informace, každý reprezentována vlastní – element XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="608c8-368">Tyto prvky může dojít buď přímo v textu (*úplné* režimu), nebo může být *zabalené* v včetně elementu jazyka XML.</span><span class="sxs-lookup"><span data-stu-id="608c8-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="608c8-369">Pomocí kontraktu zprávy programovací model umožňuje rozhodnutí úplné srovnání zabalená a název oboru názvů a název obálky ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="608c8-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="608c8-370">Následující příklad kódu kontraktu zprávy ukazuje tyto funkce.</span><span class="sxs-lookup"><span data-stu-id="608c8-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="608c8-371">Položky označené k serializaci (s <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, nebo jiné vztahující se atributy) musí být serializovatelný k účasti v kontraktu zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="608c8-372">Další informace najdete v části "Serializace" dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="608c8-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="608c8-373">4. Parametry</span><span class="sxs-lookup"><span data-stu-id="608c8-373">4. Parameters</span></span>  
 <span data-ttu-id="608c8-374">Jako vývojář, který chce popisují operace, která funguje na více částí dat často, není nutné stupeň ovládací prvek, který poskytuje kontraktů zpráv.</span><span class="sxs-lookup"><span data-stu-id="608c8-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="608c8-375">Například při vytváření nové služby, jeden nechce obvykle rozhodnutí úplné srovnání zabalená a rozhodnout o název prvku obálky.</span><span class="sxs-lookup"><span data-stu-id="608c8-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="608c8-376">Rozhodování o těchto často vyžaduje hlubokých znalostí webových služeb a SOAP.</span><span class="sxs-lookup"><span data-stu-id="608c8-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="608c8-377">Architektura služby WCF můžete automaticky vybrat nejlepší a interaktivní reprezentace SOAP pro odesílání nebo přijímání více souvisejících řadu informací, bez vynucení tyto možnosti na uživatele.</span><span class="sxs-lookup"><span data-stu-id="608c8-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="608c8-378">Tím se dosahuje tak, že jednoduše popisující tyto údaje jako parametry nebo návratové hodnoty pro kontrakt operace.</span><span class="sxs-lookup"><span data-stu-id="608c8-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="608c8-379">Představte si třeba následující operace kontraktu.</span><span class="sxs-lookup"><span data-stu-id="608c8-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="608c8-380">Architektura služby rozhodne automaticky umístit všechny tři údaje (`customerID`, `item`, a `quantity`) do textu zprávy a zalamování řádků je v prvku obálky s názvem `SubmitOrderRequest`.</span><span class="sxs-lookup"><span data-stu-id="608c8-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="608c8-381">Informace, které mají být odeslány nebo přijaty jako jednoduchý seznam parametrů operace kontraktu je doporučený postup, pokud speciální důvody pro přesun do kontraktu zprávy složitější popisující nebo `Message`– na základě programovacích modelů.</span><span class="sxs-lookup"><span data-stu-id="608c8-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="608c8-382">5. Stream</span><span class="sxs-lookup"><span data-stu-id="608c8-382">5. Stream</span></span>  
 <span data-ttu-id="608c8-383">Pomocí `Stream` nebo jeden z jejích podtříd kontrakt operace nebo jako část textu jedinou zprávy v kontraktu zprávy lze považovat za samostatný programovací model z těch, které jsou popsané výše.</span><span class="sxs-lookup"><span data-stu-id="608c8-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="608c8-384">Pomocí `Stream` tímto způsobem je jediný způsob, jak zajistit, že bude možné použít streamovaná způsobem nemá psaní vlastních datových proudů kompatibilní s vaší smlouvy `Message` podtřídy.</span><span class="sxs-lookup"><span data-stu-id="608c8-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="608c8-385">Další informace najdete v tématu [velkých objemů dat a datových proudů](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-385">For more information, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="608c8-386">Když `Stream` nebo jeden z jejích podtříd tímto způsobem je použít, není vyvolána serializátor.</span><span class="sxs-lookup"><span data-stu-id="608c8-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="608c8-387">Pro odchozí zprávy, speciální streamování `Message` vytvořit podtřídu a datový proud je zapsaný odhlašování, jak je popsáno v části na <xref:System.Xml.IStreamProvider> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="608c8-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="608c8-388">Pro příchozí zprávy, vytvoří architektura služby `Stream` podtřídy přes příchozí zprávy a poskytuje operace.</span><span class="sxs-lookup"><span data-stu-id="608c8-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="608c8-389">Omezení Model programování</span><span class="sxs-lookup"><span data-stu-id="608c8-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="608c8-390">Programovací modely výše popsané libovolně nelze kombinovat.</span><span class="sxs-lookup"><span data-stu-id="608c8-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="608c8-391">Například pokud operace přijímá typ kontraktu zprávy, kontrakt zprávy musí být jeho pouze vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="608c8-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="608c8-392">Kromě toho musí operaci pak vrátit prázdnou zprávu (typ vrácené hodnoty void) nebo jiné zprávy kontraktu.</span><span class="sxs-lookup"><span data-stu-id="608c8-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="608c8-393">Tato programovací model omezení jsou popsaná v tématech pro každou konkrétní programovací model: [Použití kontraktů zpráv](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [používání třídy Message](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), a [velkých objemů dat a streamování](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="608c8-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="608c8-394">Formátování zpráv</span><span class="sxs-lookup"><span data-stu-id="608c8-394">Message Formatters</span></span>  
 <span data-ttu-id="608c8-395">Programovací modely výše popsané podporují zapojení součásti volá *zprávy formátovací moduly* v rámci služby.</span><span class="sxs-lookup"><span data-stu-id="608c8-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="608c8-396">Formátování zpráv jsou typy, které implementují <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> nebo <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> rozhraní, nebo obojí pro použití v klienty a služby WCF, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="608c8-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="608c8-397">Formátování zpráv jsou obvykle zapojené do elektrické zásuvky podle chování.</span><span class="sxs-lookup"><span data-stu-id="608c8-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="608c8-398">Například <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> zpřístupní ve formátovacím modulu dat kontrakt zprávy.</span><span class="sxs-lookup"><span data-stu-id="608c8-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="608c8-399">To se provádí na straně služby tak, že nastavíte <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> do správné formátování v <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> metodu, nebo na straně klienta tím, že nastavíte <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> do správné formátování v <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> metoda.</span><span class="sxs-lookup"><span data-stu-id="608c8-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="608c8-400">V následující tabulce jsou uvedeny metody, které může implementovat formátovací modul zpráv.</span><span class="sxs-lookup"><span data-stu-id="608c8-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="608c8-401">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="608c8-401">Interface</span></span>|<span data-ttu-id="608c8-402">Metoda</span><span class="sxs-lookup"><span data-stu-id="608c8-402">Method</span></span>|<span data-ttu-id="608c8-403">Akce</span><span class="sxs-lookup"><span data-stu-id="608c8-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="608c8-404">Převede příchozí `Message` na parametry operace</span><span class="sxs-lookup"><span data-stu-id="608c8-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="608c8-405">Vytvoří odchozí `Message` z operace vrátit hodnotu/výstupní parametry</span><span class="sxs-lookup"><span data-stu-id="608c8-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="608c8-406">Vytvoří odchozí `Message` z parametry operace</span><span class="sxs-lookup"><span data-stu-id="608c8-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="608c8-407">Převede příchozí `Message` na návratovou hodnotu/výstupní parametry</span><span class="sxs-lookup"><span data-stu-id="608c8-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="608c8-408">Serializace</span><span class="sxs-lookup"><span data-stu-id="608c8-408">Serialization</span></span>  
 <span data-ttu-id="608c8-409">Při každém použití kontraktů zpráv nebo parametry k popisu obsah zprávy, je nutné použít serializace pro převod mezi [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typy a reprezentaci XML informační sadu.</span><span class="sxs-lookup"><span data-stu-id="608c8-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types and XML Infoset representation.</span></span> <span data-ttu-id="608c8-410">Serializace se používá na dalších místech WCF, například <xref:System.ServiceModel.Channels.Message> má obecný <xref:System.ServiceModel.Channels.Message.GetBody%2A> metodu, která vám umožní načíst celý text zprávy deserializovat do objektu.</span><span class="sxs-lookup"><span data-stu-id="608c8-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="608c8-411">WCF podporuje dvě technologie serializace "mimo pole" pro serializaci a deserializaci parametry a částí zprávy: <xref:System.Runtime.Serialization.DataContractSerializer> a `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="608c8-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="608c8-412">Kromě toho můžete napsat vlastní serializátory.</span><span class="sxs-lookup"><span data-stu-id="608c8-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="608c8-413">Však dalších součástí WCF (jako je obecný `GetBody` metody nebo SOAP k chybě serializace) může být omezena na používání jenom <xref:System.Runtime.Serialization.XmlObjectSerializer> podtřídy (<xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.NetDataContractSerializer>, ale ne <xref:System.Xml.Serialization.XmlSerializer>), nebo dokonce může být pevně určený jenom <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="608c8-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="608c8-414">`XmlSerializer` Serializační stroj se používá v [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] webové služby.</span><span class="sxs-lookup"><span data-stu-id="608c8-414">The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services.</span></span> <span data-ttu-id="608c8-415">`DataContractSerializer` Je nový Serializační stroj, který rozpozná nový model programování kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="608c8-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="608c8-416">`DataContractSerializer` je výchozí volbou a možnost použití `XmlSerializer` provádět na základě každou operaci pomocí <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> atribut.</span><span class="sxs-lookup"><span data-stu-id="608c8-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="608c8-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> a <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> zodpovídají chování operace pro formátování zpráv pro zapojení `DataContractSerializer` a `XmlSerializer`v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="608c8-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="608c8-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> Chování ve skutečnosti můžete pracovat s jakékoli serializátoru, který je odvozen z <xref:System.Runtime.Serialization.XmlObjectSerializer>, včetně <xref:System.Runtime.Serialization.NetDataContractSerializer> (podrobně popsány v pomocí samostatného serializace).</span><span class="sxs-lookup"><span data-stu-id="608c8-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="608c8-419">Chování volá jedno ze `CreateSerializer` přetížení virtuální metody pro získání serializátoru.</span><span class="sxs-lookup"><span data-stu-id="608c8-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="608c8-420">Chcete-li zařadit jiný serializátor, vytvořte nový <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> podtřídy a přepsání `CreateSerializer` přetížení.</span><span class="sxs-lookup"><span data-stu-id="608c8-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="608c8-421">Viz také:</span><span class="sxs-lookup"><span data-stu-id="608c8-421">See also</span></span>

- [<span data-ttu-id="608c8-422">Určování přenosu dat v kontraktech služby</span><span class="sxs-lookup"><span data-stu-id="608c8-422">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
