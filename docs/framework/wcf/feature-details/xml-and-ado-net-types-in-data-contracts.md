---
title: Typy XML a ADO.NET v kontraktech dat
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: b5d9c3362ebd69e587d58104e7ebc9d9e96a9020
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54603675"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="b40e4-102">Typy XML a ADO.NET v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="b40e4-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="b40e4-103">Datový model kontraktu Windows Communication Foundation (WCF) podporuje určité typy, které představují XML přímo.</span><span class="sxs-lookup"><span data-stu-id="b40e4-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="b40e4-104">Pokud tyto typy jsou serializován do formátu XML, serializátoru, který zapíše obsah XML z těchto typů bez dalšího zpracování.</span><span class="sxs-lookup"><span data-stu-id="b40e4-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="b40e4-105">Podporované typy jsou <xref:System.Xml.XmlElement>, pole <xref:System.Xml.XmlNode> (ale ne `XmlNode` zadejte vlastní), stejně jako typy, které implementují <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="b40e4-106"><xref:System.Data.DataSet> a <xref:System.Data.DataTable> typ, jakož i typové datové sady, se běžně používají při programování pro databázi.</span><span class="sxs-lookup"><span data-stu-id="b40e4-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="b40e4-107">Tyto typy implementace `IXmlSerializable` rozhraní a jsou proto serializovatelný v datech smlouvy modelu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="b40e4-108">Některé speciální aspekty pro tyto typy jsou uvedené na konci tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="b40e4-109">Typy XML</span><span class="sxs-lookup"><span data-stu-id="b40e4-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="b40e4-110">– Element XML</span><span class="sxs-lookup"><span data-stu-id="b40e4-110">Xml Element</span></span>  
 <span data-ttu-id="b40e4-111">`XmlElement` Typ serializován pomocí jeho obsah XML.</span><span class="sxs-lookup"><span data-stu-id="b40e4-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="b40e4-112">Například pomocí následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="b40e4-113">To je serializován do formátu XML následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="b40e4-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b40e4-114">Všimněte si, že element obálky, a datový člen `<myDataMember>` je stále k dispozici.</span><span class="sxs-lookup"><span data-stu-id="b40e4-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="b40e4-115">Neexistuje žádný způsob odebrání tohoto elementu v modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="b40e4-116">Serializátory, které zpracovávají tohoto modelu ( <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.NetDataContractSerializer>) může vysílat speciální atributy do tohoto prvku obálky.</span><span class="sxs-lookup"><span data-stu-id="b40e4-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="b40e4-117">Tyto atributy zahrnout atribut "nulový" standardní Instance schématu XML (povolení `XmlElement` bude `null`) a atributu "typ" (povolení `XmlElement` použije polymorphically).</span><span class="sxs-lookup"><span data-stu-id="b40e4-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="b40e4-118">Navíc následující atributy XML jsou specifické pro WCF: "Id", "Ref", "Type" a "Sestavení".</span><span class="sxs-lookup"><span data-stu-id="b40e4-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="b40e4-119">Tyto atributy mohou být vygenerován pro podporovat použití `XmlElement` s povoleným režimem uchování objektu grafu, nebo se <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b40e4-120">(Další informace o režimu objektu grafu a zachovávání s rozlišením, naleznete v tématu [serializace a deserializace](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="b40e4-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="b40e4-121">Pole nebo kolekce `XmlElement` jsou povolené a jsou zpracovány jako ostatní pole nebo kolekce.</span><span class="sxs-lookup"><span data-stu-id="b40e4-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="b40e4-122">To znamená, je element obálky pro celou kolekci a element samostatné obálky (podobně jako `<myDataMember>` v předchozím příkladu) pro každý `XmlElement` v poli.</span><span class="sxs-lookup"><span data-stu-id="b40e4-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="b40e4-123">K deserializaci `XmlElement` vytvoří deserializátor z příchozí XML.</span><span class="sxs-lookup"><span data-stu-id="b40e4-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="b40e4-124">Platný nadřazený <xref:System.Xml.XmlDocument> deserializátor poskytuje.</span><span class="sxs-lookup"><span data-stu-id="b40e4-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="b40e4-125">Ujistěte se, že XML fragment, který je deserializovat do `XmlElement` definuje všechny předpony, které používá a nevyžaduje žádné definice předponu od nadřazených elementů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="b40e4-126">Toto je problém, pouze pokud používáte `DataContractSerializer` pro přístup k XML z jiného (jinou hodnotu než`DataContractSerializer`) zdroje.</span><span class="sxs-lookup"><span data-stu-id="b40e4-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="b40e4-127">Při použití s `DataContractSerializer`, `XmlElement` může být přiřazen polymorphically, ale jenom na datový člen typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="b40e4-128">I v případě, že implementuje <xref:System.Collections.IEnumerable>, `XmlElement` nelze použít jako typ kolekce a nejde přiřadit <xref:System.Collections.IEnumerable> datový člen.</span><span class="sxs-lookup"><span data-stu-id="b40e4-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="b40e4-129">Stejně jako u všech polymorfní přiřazení `DataContractSerializer` vysílá názvem kontraktu dat ve výsledném souboru XML – v takovém případě je "XmlElement" v "http://schemas.datacontract.org/2004/07/System.Xml" oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="b40e4-130">S `NetDataContractSerializer`, žádné platné polymorfní přiřazení `XmlElement` (k `Object` nebo `IEnumerable`) se nepodporuje.</span><span class="sxs-lookup"><span data-stu-id="b40e4-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="b40e4-131">Nepokoušejte se použít buď serializátory s typy odvozené od `XmlElement`, ať už jsou přiřazeny polymorphically nebo ne.</span><span class="sxs-lookup"><span data-stu-id="b40e4-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="b40e4-132">Pole typu XmlNode</span><span class="sxs-lookup"><span data-stu-id="b40e4-132">Array of XmlNode</span></span>  
 <span data-ttu-id="b40e4-133">Pomocí pole <xref:System.Xml.XmlNode> je velmi podobný používání `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="b40e4-134">Pomocí pole `XmlNode` vám zajistí větší flexibilitu než použití `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="b40e4-135">Můžete napsat více elementů v rámci datový člen zabalení elementu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="b40e4-136">Můžete také vložit obsah než prvky uvnitř datový člen zabalení elementu, například pro komentáře XML.</span><span class="sxs-lookup"><span data-stu-id="b40e4-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="b40e4-137">Nakonec můžete umístit atributy do obalu datový člen element.</span><span class="sxs-lookup"><span data-stu-id="b40e4-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="b40e4-138">To vše lze dosáhnout vyplnění pole `XmlNode` s konkrétními odvozené třídy `XmlNode` například <xref:System.Xml.XmlAttribute>, `XmlElement` nebo <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="b40e4-139">Například pomocí následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="b40e4-140">Při serializován, výsledný XML je podobná následující kód.</span><span class="sxs-lookup"><span data-stu-id="b40e4-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b40e4-141">Všimněte si, že element obálky datový člen `<myDataMember>` obsahuje atribut, komentáře a dva elementy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="b40e4-142">Jedná se o čtyři `XmlNode` instancí, které byly serializovat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="b40e4-143">Pole `XmlNode` , že výsledkem neplatný kód XML nejde serializovat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="b40e4-144">Například pole dvou `XmlNode` instance, kde je první z nich `XmlElement` a druhý je <xref:System.Xml.XmlAttribute> je neplatný, protože toto pořadí neodpovídá žádné platné instance XML (není žádné místo pro atribut, který chcete připojit).</span><span class="sxs-lookup"><span data-stu-id="b40e4-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="b40e4-145">Pro deserializaci pole `XmlNode`, uzly jsou vytvořeny a naplněny informace z příchozích XML.</span><span class="sxs-lookup"><span data-stu-id="b40e4-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="b40e4-146">Platný nadřazený <xref:System.Xml.XmlDocument> deserializátor poskytuje.</span><span class="sxs-lookup"><span data-stu-id="b40e4-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="b40e4-147">Všechny uzly jsou deserializovat, včetně všech atributů na elementu obálky datový člen, ale s výjimkou atributy tam umístili serializátory WCF (např. slouží k označení polymorfní přiřazení atributy).</span><span class="sxs-lookup"><span data-stu-id="b40e4-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="b40e4-148">Platí výstrahou o definování všechny předpony oboru názvů ve fragmentu XML pro deserializaci pole `XmlNode` stejně to dělá k deserializaci `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="b40e4-149">Při serializátory pomocí objektu grafu a zachovávání s rozlišením zapnuté, rovnost objektů je zachována pouze na úrovni `XmlNode` pole, nikoli jednotlivé `XmlNode` instancí.</span><span class="sxs-lookup"><span data-stu-id="b40e4-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="b40e4-150">Nepokoušejte se serializovat pole `XmlNode` kde jeden nebo více uzlů je nastaven na `null`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="b40e4-151">Je povolený pro člen celého pole bude `null`, ale ne pro každý jednotlivec `XmlNode` obsažené v poli.</span><span class="sxs-lookup"><span data-stu-id="b40e4-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="b40e4-152">Pokud člen celého pole má hodnotu null, obsahuje element obálky datový člen speciální atribut, který označuje, že má hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b40e4-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="b40e4-153">K deserializaci člen celého pole také změní na hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b40e4-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="b40e4-154">Pouze pravidelných polí z `XmlNode` zachází speciálně modulem pro serializaci.</span><span class="sxs-lookup"><span data-stu-id="b40e4-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="b40e4-155">Datové členy deklarované jako typy kolekcí, které obsahují `XmlNode`, nebo datové členy deklarované jako pole typů odvozených z `XmlNode`, nejsou speciálně zpracovány.</span><span class="sxs-lookup"><span data-stu-id="b40e4-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="b40e4-156">Proto nejsou obvykle serializovatelný nesplňují také jednu z jiných kritérií pro serializaci.</span><span class="sxs-lookup"><span data-stu-id="b40e4-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="b40e4-157">Pole nebo kolekce polí `XmlNode` jsou povoleny.</span><span class="sxs-lookup"><span data-stu-id="b40e4-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="b40e4-158">Element obálky pro celou kolekci a element samostatné obálky (podobně jako `<myDataMember>` v předchozím příkladu) pro každé pole `XmlNode` vnější pole nebo kolekce.</span><span class="sxs-lookup"><span data-stu-id="b40e4-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="b40e4-159">Naplnění datový člen typu <xref:System.Array> z `Object` nebo `Array` z `IEnumerable` s `XmlNode` instance nemá za následek datový člen se zachází jako `Array` z `XmlNode` instancí.</span><span class="sxs-lookup"><span data-stu-id="b40e4-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="b40e4-160">Každý člen pole je samostatně serializovat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="b40e4-161">Při použití s `DataContractSerializer`, pole `XmlNode` je možné přiřadit polymorphically, ale jenom na datový člen typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="b40e4-162">I v případě, že implementuje `IEnumerable`, pole `XmlNode` nelze použít jako typ kolekce a přiřadit `IEnumerable` datový člen.</span><span class="sxs-lookup"><span data-stu-id="b40e4-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="b40e4-163">Stejně jako u všech polymorfní přiřazení `DataContractSerializer` vysílá názvem kontraktu dat ve výsledném souboru XML – v takovém případě je "ArrayOfXmlNode" v "http://schemas.datacontract.org/2004/07/System.Xml" oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="b40e4-164">Při použití s `NetDataContractSerializer`, žádné platné přiřazení `XmlNode` pole je podporován.</span><span class="sxs-lookup"><span data-stu-id="b40e4-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="b40e4-165">Schema Considerations</span><span class="sxs-lookup"><span data-stu-id="b40e4-165">Schema Considerations</span></span>  
 <span data-ttu-id="b40e4-166">Podrobnosti o mapování schématu XML typů najdete v tématu [schéma kontraktů dat – referenční informace](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="b40e4-167">Tato část poskytuje přehled důležitých bodů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="b40e4-168">Datový člen typu `XmlElement` je mapován na prvek definované pomocí následující anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="b40e4-169">Datový člen třídy zadejte pole `XmlNode` se mapuje na element definovány pomocí následující anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="b40e4-170">Typy implementující rozhraní IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b40e4-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="b40e4-171">Typy, které implementují `IXmlSerializable` rozhraní jsou plně podporovány `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="b40e4-172"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> Atribut by měl vždy použít pro tyto typy řídit jejich schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="b40e4-173">Existují tři typy prvků typy, které implementují `IXmlSerializable`: typy, které představují libovolného obsahu, typy, které představují jeden prvek a starší verze <xref:System.Data.DataSet> typy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="b40e4-174">Typy obsahu použít metodu schématu poskytovatele určeného `XmlSchemaProviderAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="b40e4-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b40e4-175">Metoda nevrací `null`a <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost pro atribut je ponecháno na jeho výchozí hodnotu `false`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="b40e4-176">Toto je nejběžnější použití `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="b40e4-177">Typy elementů se používají při `IXmlSerializable` typ musí řídit svůj vlastní název kořenového elementu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="b40e4-178">K označení typu jako typ elementu, nastavte <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> vlastnost <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atribut `true` nebo vrátí hodnotu null z metody zprostředkovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="b40e4-179">Metoda poskytovatele schématu je volitelné pro typy prvků – můžete zadat hodnotu null namísto názvu metody v `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="b40e4-180">Nicméně pokud `IsAny` je `true` a metody zprostředkovatele schématu není zadána, metoda musí vracet hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b40e4-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="b40e4-181">Starší verze <xref:System.Data.DataSet> typy jsou `IXmlSerializable` typy, které nejsou označené `XmlSchemaProviderAttribute` atribut.</span><span class="sxs-lookup"><span data-stu-id="b40e4-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b40e4-182">Místo toho spoléhají na <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> metody pro generování schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="b40e4-183">Tento model se používá pro `DataSet` typu a jeho typové datové sady odvozená třída v dřívějších verzích rozhraní .NET Framework, ale je zastaralá a je podporován pouze kvůli starším verzím.</span><span class="sxs-lookup"><span data-stu-id="b40e4-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="b40e4-184">Nezadávejte Spolehněte se na tento model a vždycky používat `XmlSchemaProviderAttribute` do vaší `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="b40e4-185">Typy rozhraní IXmlSerializable obsahu</span><span class="sxs-lookup"><span data-stu-id="b40e4-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="b40e4-186">Při serializaci datový člen typu, který implementuje `IXmlSerializable` a je typem obsahu jako dříve definovali, serializátoru, který zapíše element obálky pro člen a předejte jí ovládací prvek dat <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b40e4-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="b40e4-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> Implementace může zapisovat všechny XML, včetně přidávání atributů do element obálky.</span><span class="sxs-lookup"><span data-stu-id="b40e4-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="b40e4-188">Po `WriteXml` je Hotovo, serializátor zavře elementu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="b40e4-189">Při deserializaci datový člen typu, který implementuje `IXmlSerializable` a obsahu zadat jako definovaný dříve, pozice deserializátor čtecí funkce XML na element obálky pro datový člen a předejte ovládací prvek <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b40e4-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="b40e4-190">Metoda musí číst celý prvek, včetně počáteční a koncovou značku.</span><span class="sxs-lookup"><span data-stu-id="b40e4-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="b40e4-191">Ujistěte se, že vaše `ReadXml` kód zpracovává případ, ve kterém je prázdný element.</span><span class="sxs-lookup"><span data-stu-id="b40e4-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="b40e4-192">Kromě toho vaše `ReadXml` implementace neměli byste tedy spoléhat na element obálky jmenován určitým způsobem.</span><span class="sxs-lookup"><span data-stu-id="b40e4-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="b40e4-193">Je název zvoleném serializátoru, který se může lišit.</span><span class="sxs-lookup"><span data-stu-id="b40e4-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="b40e4-194">Je povoleno přiřadit `IXmlSerializable` typy obsahu polymorphically, třeba k datům členy typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="b40e4-195">Může se také atribut instance typu mít hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="b40e4-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="b40e4-196">A konečně, je možné použít `IXmlSerializable` typy s objektu grafu a zachovávání s rozlišením povolen a <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b40e4-197">Všechny tyto funkce vyžadují serializátor WCF připojit určité atributy do prvku obálky ("nulový" a "type" v oboru názvů Instance schématu XML a "Id", "Ref", "Type" a "Sestavení" v oboru názvů specifických WCF).</span><span class="sxs-lookup"><span data-stu-id="b40e4-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="b40e4-198">Atributy se mají ignorovat při implementaci ReadXml</span><span class="sxs-lookup"><span data-stu-id="b40e4-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="b40e4-199">Před předáním řízení pro vaše `ReadXml` kód, deserializátor zkontroluje prvek XML, zjistí tyto speciální atributy XML a funguje na ně.</span><span class="sxs-lookup"><span data-stu-id="b40e4-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="b40e4-200">Například, pokud je "nulový" `true`, deserializovat hodnotu null a `ReadXml` není volána.</span><span class="sxs-lookup"><span data-stu-id="b40e4-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="b40e4-201">Pokud se zjistí polymorfismus obsah elementu se deserializovat jako by to byla jiného typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="b40e4-202">Implementace polymorphically přiřazený typ `ReadXml` je volána.</span><span class="sxs-lookup"><span data-stu-id="b40e4-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="b40e4-203">V každém případě `ReadXml` implementace by měl ignorovat tyto speciální atributy, protože deserializátor zpracovává.</span><span class="sxs-lookup"><span data-stu-id="b40e4-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="b40e4-204">Důležité informace o schématu pro typy obsahu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b40e4-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="b40e4-205">Při exportu schématu `IXmlSerializable` typ obsahu, je volána metoda poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="b40e4-206"><xref:System.Xml.Schema.XmlSchemaSet> Se předá metodě poskytovatele schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="b40e4-207">Metodu můžete přidat libovolné platné schéma k sadě schémat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="b40e4-208">Sada schéma obsahuje schéma, které je již znám v době, kdy dojde k exportu schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="b40e4-209">Když metoda poskytovatele schématu musí přidat položku do sady schémat, musíte určit Pokud <xref:System.Xml.Schema.XmlSchema> s odpovídající obor názvů již existuje v sadě.</span><span class="sxs-lookup"><span data-stu-id="b40e4-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="b40e4-210">Pokud ano, metoda poskytovatele schématu musí přidat novou položku do stávající `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="b40e4-211">V opačném případě se musí vytvořit nový `XmlSchema` instance.</span><span class="sxs-lookup"><span data-stu-id="b40e4-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="b40e4-212">To je důležité, pokud pole `IXmlSerializable` typy se používají.</span><span class="sxs-lookup"><span data-stu-id="b40e4-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="b40e4-213">Pokud máte například `IXmlSerializable` typ, který získá exportovat jako typ "A" v oboru názvů "B", je možné, že podle času je volána metoda poskytovatele schématu schématu nastavení už obsahuje schéma pro "B" typ "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="b40e4-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="b40e4-214">Kromě přidání typů, který chcete <xref:System.Xml.Schema.XmlSchemaSet>, metoda poskytovatele schématu pro typy obsahu musí vrátit nenulovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="b40e4-215">Může vrátit <xref:System.Xml.XmlQualifiedName> , který určuje název typu schématu pro daný `IXmlSerializable` typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="b40e4-216">Tento kvalifikovaný název slouží taky jako data názvem a oborem názvů pro typ kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="b40e4-217">Je povoleno návratový typ, který neexistuje v sadě hned po návratu metody zprostředkovatele schématu schémat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="b40e4-218">Ale očekává se, že v době všechny související typy jsou exportovány ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> metoda je volána pro všechny typy relevantní na <xref:System.Runtime.Serialization.XsdDataContractExporter> a <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> získat přístup k vlastnosti), typ existuje v sadě schémat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="b40e4-219">Přístup k `Schemas` vlastnost před všechny relevantní `Export` byly provedeny volání může vést <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="b40e4-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="b40e4-220">Další informace o procesu exportu, naleznete v tématu [export schémat ze tříd](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-220">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="b40e4-221">Metoda poskytovatele schéma může taky vrátit <xref:System.Xml.Schema.XmlSchemaType> používat.</span><span class="sxs-lookup"><span data-stu-id="b40e4-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="b40e4-222">Typ může nebo nemusí být anonymní.</span><span class="sxs-lookup"><span data-stu-id="b40e4-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="b40e4-223">Pokud je anonymní, schéma pro `IXmlSerializable` typu se exportuje jako anonymního typu pokaždé, když `IXmlSerializable` typ používá jako datový člen.</span><span class="sxs-lookup"><span data-stu-id="b40e4-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="b40e4-224">`IXmlSerializable` Typ stále má název kontraktu dat a obor názvů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="b40e4-225">(Tím se určuje, jak je popsáno v [názvy datových kontraktů](../../../../docs/framework/wcf/feature-details/data-contract-names.md) s tím rozdílem, že <xref:System.Runtime.Serialization.DataContractAttribute> atributu nelze použít k přizpůsobení názvu.) Pokud není anonymní, musí být jeden z typů v `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="b40e4-226">Tento případ je ekvivalentní k vrácení `XmlQualifiedName` typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="b40e4-227">Kromě toho se pro typ exportuje globální prvek prohlášení.</span><span class="sxs-lookup"><span data-stu-id="b40e4-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="b40e4-228">Pokud typ nemá <xref:System.Xml.Serialization.XmlRootAttribute> atribut WebMethod, element má stejný název a obor názvů jako kontraktu dat a jeho vlastnost "nillable" má hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="b40e4-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="b40e4-229">Jedinou výjimkou je obor názvů schématu ("http://www.w3.org/2001/XMLSchema") – Pokud typ kontraktu dat je v tomto oboru názvů, odpovídající globální element je v oboru názvů prázdné, protože je zakázaná pro přidání nových elementů do oboru názvů schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="b40e4-230">Pokud má typ `XmlRootAttribute` atribut WebMethod, globální prvek prohlášení je exportovat pomocí následující: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> a <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b40e4-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="b40e4-231">Výchozí hodnoty s `XmlRootAttribute` použity jsou názvem kontraktu dat, prázdný obor názvů a "nillable" je true.</span><span class="sxs-lookup"><span data-stu-id="b40e4-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="b40e4-232">Stejná pravidla deklarace globální element se vztahují na typy starší datová sada.</span><span class="sxs-lookup"><span data-stu-id="b40e4-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="b40e4-233">Všimněte si, že `XmlRootAttribute` nemůže přepsat globální prvek prohlášení přidané prostřednictvím vlastního kódu buď přidat do `XmlSchemaSet` pomocí metody poskytovatele schématu nebo prostřednictvím `GetSchema` pro datovou sadu starší verze typů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="b40e4-234">Typy elementů IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b40e4-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="b40e4-235">`IXmlSerializable` typy elementů mít buď `IsAny` vlastnost nastavena na hodnotu `true` nebo jejich schématu poskytovatele metoda vrátit `null`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="b40e4-236">Serializace a deserializace typ elementu je velmi podobná serializace a deserializace typu obsahu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="b40e4-237">Existují však několik důležitých rozdílů:</span><span class="sxs-lookup"><span data-stu-id="b40e4-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="b40e4-238">`WriteXml` Implementace má napsat přesně jeden element (který samozřejmě může obsahovat více podřízených prvků).</span><span class="sxs-lookup"><span data-stu-id="b40e4-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="b40e4-239">To by neměl být zápis atributů mimo tento jeden element více na stejné úrovni elementy nebo smíšený obsah.</span><span class="sxs-lookup"><span data-stu-id="b40e4-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="b40e4-240">Element může být prázdný.</span><span class="sxs-lookup"><span data-stu-id="b40e4-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="b40e4-241">`ReadXml` Implementace by neměla číst element obálky.</span><span class="sxs-lookup"><span data-stu-id="b40e4-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="b40e4-242">Očekává se číst jeden element, který `WriteXml` vytvoří.</span><span class="sxs-lookup"><span data-stu-id="b40e4-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="b40e4-243">Při serializaci typ elementu pravidelně (například jako datový člen v kontraktu dat), serializátoru, který vypíše element obálky, a před voláním `WriteXml`, stejně jako u typů obsahu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="b40e4-244">Ale při serializaci typ elementu na nejvyšší úrovni, serializátoru, který je výstupem však nejsou obvykle element obálky, a po elementu, který `WriteXml` zapíše název kořenového adresáře a obor názvů byly explicitně určena při vytváření serializátoru v `DataContractSerializer` nebo `NetDataContractSerializer` konstruktory.</span><span class="sxs-lookup"><span data-stu-id="b40e4-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="b40e4-245">Další informace najdete v tématu [serializace a deserializace](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="b40e4-246">Při serializaci typ elementu na nejvyšší úrovni bez zadání kořenový název a obor názvů v době konstrukce <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> a <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> v podstatě nic nedělá a <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> volání `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="b40e4-247">V tomto režimu serializovaného objektu nemůže mít hodnotu null a nemůže být přiřazen polymorphically.</span><span class="sxs-lookup"><span data-stu-id="b40e4-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="b40e4-248">Navíc nelze povolit zachování graf objektu a `NetDataContractSerializer` nelze použít.</span><span class="sxs-lookup"><span data-stu-id="b40e4-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="b40e4-249">Při deserializaci typ elementu na nejvyšší úrovni bez zadání kořenový název a obor názvů v době konstrukce <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> vrátí `true` Pokud nemůže najít začátek libovolný element.</span><span class="sxs-lookup"><span data-stu-id="b40e4-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="b40e4-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> s `verifyObjectName` parametr nastaven na `true` se chová stejně jako `IsStartObject` před skutečně čtení objektu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="b40e4-251">`ReadObject` ovládací prvek pak předá `ReadXml` metody.</span><span class="sxs-lookup"><span data-stu-id="b40e4-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="b40e4-252">Schéma exportovat pro typy prvků je stejné jako v případě `XmlElement` zadejte, jak je popsáno v předchozí části, s tím rozdílem, že metoda poskytovatele schématu můžete přidat žádné další schéma, aby <xref:System.Xml.Schema.XmlSchemaSet> stejně jako u typů obsahu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="b40e4-253">Použití `XmlRootAttribute` atribut s typy prvků není povoleno a globální prvek prohlášení jsou emitovány nikdy pro tyto typy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="b40e4-254">Rozdíl oproti třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="b40e4-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="b40e4-255">`IXmlSerializable` Rozhraní a `XmlSchemaProviderAttribute` a `XmlRootAttribute` atributy také rozumí <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b40e4-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="b40e4-256">Existují však určité rozdíly v tom, jak jsou považovány v datovém modelu smlouvy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="b40e4-257">Důležité rozdíly jsou shrnuté v následujících tématech:</span><span class="sxs-lookup"><span data-stu-id="b40e4-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="b40e4-258">Metoda poskytovatele schématu musí být veřejné má být použitelná ve `XmlSerializer`, ale nemusí být veřejné být použitelné v datovém modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="b40e4-259">Při volání metody zprostředkovatele schématu `IsAny` má hodnotu true v datovém modelu smlouvy, ale ne s `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="b40e4-260">Když `XmlRootAttribute` atribut není k dispozici pro obsah nebo starší datová sada typů, `XmlSerializer` exportuje globální prvek prohlášení v oboru názvů prázdné.</span><span class="sxs-lookup"><span data-stu-id="b40e4-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="b40e4-261">V datovém modelu smlouvy oboru názvů použitého je obvykle obor názvů kontraktu dat jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="b40e4-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="b40e4-262">Mějte na paměti tyto rozdíly při vytváření typů, které se používají u obou technologií serializace.</span><span class="sxs-lookup"><span data-stu-id="b40e4-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="b40e4-263">Import schématu rozhraní IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="b40e4-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="b40e4-264">Při importu schématu generovaném z `IXmlSerializable` typy, existuje několik možností:</span><span class="sxs-lookup"><span data-stu-id="b40e4-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="b40e4-265">Generované schéma může být schématu platný datový kontrakt, jak je popsáno v [schéma kontraktů dat – referenční informace](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="b40e4-266">V tomto případě obvyklým způsobem můžete importovat schéma a typy kontraktů běžných dat jsou generovány.</span><span class="sxs-lookup"><span data-stu-id="b40e4-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="b40e4-267">Generované schéma nemusí být platný datový kontrakt schéma.</span><span class="sxs-lookup"><span data-stu-id="b40e4-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="b40e4-268">Například metodu schématu poskytovatele může vygenerovat schéma, které zahrnuje atributy XML, které nejsou podporovány v datovém modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="b40e4-269">V takovém případě můžete importovat schéma jako `IXmlSerializable` typy.</span><span class="sxs-lookup"><span data-stu-id="b40e4-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="b40e4-270">Tento režim importu se nenachází na ve výchozím nastavení lze snadno ji však povolit – například s `/importXmlTypes` přepínač příkazového řádku [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="b40e4-271">To je podrobně popsáno [import schématu pro generování třídy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="b40e4-272">Všimněte si, že musíte pracovat přímo s XML pro typ instance.</span><span class="sxs-lookup"><span data-stu-id="b40e4-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="b40e4-273">Mohou také zvážit použití jiné technologie serializace, který podporuje používání nástroje většímu počtu schématu – naleznete v tématu o používání `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="b40e4-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="b40e4-274">Můžete chtít znovu použít stávající `IXmlSerializable` typy v proxy namísto generování nové.</span><span class="sxs-lookup"><span data-stu-id="b40e4-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="b40e4-275">V takovém případě funkce odkazované typy popsaná v import schématu pro téma generovat typy lze označující typ, který chcete znovu použít.</span><span class="sxs-lookup"><span data-stu-id="b40e4-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="b40e4-276">To odpovídá pomocí `/reference` zapnout svcutil.exe, který určuje sestavení, který obsahuje typy pro opětovné použití.</span><span class="sxs-lookup"><span data-stu-id="b40e4-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="b40e4-277">Představuje libovolný dokument XML v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="b40e4-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="b40e4-278">`XmlElement`, Pole `XmlNode` a `IXmlSerializable` typy umožňují vložit libovolný dokument XML do datového modelu v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="b40e4-279">`DataContractSerializer` a `NetDataContractSerializer` předat obsahu k zapisovací modul XML tohoto XML kódu používá, bez zásahů do procesu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="b40e4-280">Uživatelé vytvářející obsah XML však může vynutit určitá omezení na XML, které zapisují.</span><span class="sxs-lookup"><span data-stu-id="b40e4-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="b40e4-281">Konkrétně tady jsou některé důležité příklady:</span><span class="sxs-lookup"><span data-stu-id="b40e4-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="b40e4-282">Zapisovače XML obvykle neumožňují deklarace dokumentu XML (například \<? xml verze = "1.0'? >) v průběhu psaní jiného dokumentu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="b40e4-283">Nelze provést úplné dokumentu XML a serializaci jako `Array` z `XmlNode` datový člen.</span><span class="sxs-lookup"><span data-stu-id="b40e4-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="b40e4-284">K tomuto účelu musí buď pruhu deklaraci dokumentu nebo použijte vlastní schéma kódování který ho zastupuje.</span><span class="sxs-lookup"><span data-stu-id="b40e4-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="b40e4-285">Všechny zapisovače XML zadat s použitím technologie WCF odmítnout pokyny pro zpracování XML (\<?</span><span class="sxs-lookup"><span data-stu-id="b40e4-285">All of the XML writers supplied with WCF reject XML processing instructions (\<?</span></span> <span data-ttu-id="b40e4-286">…</span><span class="sxs-lookup"><span data-stu-id="b40e4-286">…</span></span> <span data-ttu-id="b40e4-287">? >) a dokumentu definice typů (\<!</span><span class="sxs-lookup"><span data-stu-id="b40e4-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="b40e4-288">…</span><span class="sxs-lookup"><span data-stu-id="b40e4-288">…</span></span> <span data-ttu-id="b40e4-289">>), protože nejsou povoleny v zprávy protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="b40e4-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="b40e4-290">Znovu můžete použít vlastní kódovací mechanismus jsme toto omezení.</span><span class="sxs-lookup"><span data-stu-id="b40e4-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="b40e4-291">Pokud je nutné zahrnout v výsledný soubor XML, můžete napsat vlastní kodér, který používá zapisovače XML, které je podporují.</span><span class="sxs-lookup"><span data-stu-id="b40e4-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="b40e4-292">Při implementaci `WriteXml`, vyhněte se volání <xref:System.Xml.XmlWriter.WriteRaw%2A> metoda zapisovače XML.</span><span class="sxs-lookup"><span data-stu-id="b40e4-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="b40e4-293">WCF využívá širokou škálu kódování XML (včetně binární soubor), je velmi obtížné nebo nemožné používat `WriteRaw` tak, že výsledek je použitelná v jakémkoli kódování.</span><span class="sxs-lookup"><span data-stu-id="b40e4-293">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="b40e4-294">Při implementaci `WriteXml`, vyhněte se použití <xref:System.Xml.XmlWriter.WriteEntityRef%2A> a <xref:System.Xml.XmlWriter.WriteNmToken%2A> metody, které nejsou podporovány na zapisovače XML zadat s použitím technologie WCF.</span><span class="sxs-lookup"><span data-stu-id="b40e4-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="b40e4-295">Pomocí datové sady, typový DataSet a DataTable</span><span class="sxs-lookup"><span data-stu-id="b40e4-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="b40e4-296">Pomocí těchto typů se plně podporuje v datovém modelu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="b40e4-297">Při použití těchto typů, zvažte následující body:</span><span class="sxs-lookup"><span data-stu-id="b40e4-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="b40e4-298">Schéma pro tyto typy (zejména <xref:System.Data.DataSet> a jeho typu odvozené třídy) možná vzájemná spolupráce s některé platformy bez WCF, nebo může mít za následek nízký použitelnost při použití s těmito platformami.</span><span class="sxs-lookup"><span data-stu-id="b40e4-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="b40e4-299">Kromě toho používání `DataSet` typu může mít vliv na výkon.</span><span class="sxs-lookup"><span data-stu-id="b40e4-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="b40e4-300">Nakonec ho může to ztížit za vás na verzi vaší aplikace v budoucnu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="b40e4-301">Zvažte použití explicitně definované datové typy kontraktů místo `DataSet` typy ve vašich smlouvách.</span><span class="sxs-lookup"><span data-stu-id="b40e4-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="b40e4-302">Při importu `DataSet` nebo `DataTable` schéma, je důležité, abyste tyto typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="b40e4-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="b40e4-303">Pomocí nástroje Svcutil.exe příkazového řádku, můžete to provést předáním názvu sestavení System.Data.dll `/reference` přepnout.</span><span class="sxs-lookup"><span data-stu-id="b40e4-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="b40e4-304">Pokud importujete schéma typové datové sady, musí odkazovat typové datové sady typu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="b40e4-305">Pomocí Svcutil.exe, předat umístění sestavení typové datové sady, které chcete `/reference` přepnout.</span><span class="sxs-lookup"><span data-stu-id="b40e4-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="b40e4-306">Další informace o odkazování na typy, najdete v článku [import schématu pro generování třídy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b40e4-306">For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="b40e4-307">Podpora pro typové datové sady v datovém modelu smlouvy je omezená.</span><span class="sxs-lookup"><span data-stu-id="b40e4-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="b40e4-308">Typové datové sady lze serializovat a deserializovat a můžete exportovat jejich schématu.</span><span class="sxs-lookup"><span data-stu-id="b40e4-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="b40e4-309">Ale kontraktu dat. není schopna generovat nový import schématu zadané typy datové sady ze schématu, jako je jenom znovu použít existující.</span><span class="sxs-lookup"><span data-stu-id="b40e4-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="b40e4-310">Může odkazovat na existující typové datové sady s použitím `/r` zapnout Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="b40e4-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="b40e4-311">Při pokusu o použití Svcutil.exe bez `/r` přepněte se na službu, která používá typové datové sady, alternativní serializátor (objekt XmlSerializer) je automaticky vybrána.</span><span class="sxs-lookup"><span data-stu-id="b40e4-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="b40e4-312">Pokud musíte použít objektu DataContractSerializer a musí generovat datové sady ze schématu, můžete použít následující postup: generování typů typové datové sady (s použitím nástroje Xsd.exe s `/d` přepnout na službu), zkompilujte typy a pak přejděte na jejich použití `/r` zapnout Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="b40e4-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b40e4-313">Viz také:</span><span class="sxs-lookup"><span data-stu-id="b40e4-313">See also</span></span>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="b40e4-314">Použití kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="b40e4-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="b40e4-315">Typy podporované serializátorem kontraktu dat</span><span class="sxs-lookup"><span data-stu-id="b40e4-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
