---
title: Serializace a deserializace
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: a6bbc2fe4bf68b50153075a251d23deebda78de5
ms.sourcegitcommit: 37616676fde89153f563a485fc6159fc57326fc2
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/23/2019
ms.locfileid: "69988658"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="40a1e-102">Serializace a deserializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-102">Serialization and Deserialization</span></span>
<span data-ttu-id="40a1e-103">Windows Communication Foundation (WCF) obsahuje nový modul serializace, <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="40a1e-103">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="40a1e-104"><xref:System.Runtime.Serialization.DataContractSerializer> Překládá mezi objekty .NET Framework a XML v obou směrech.</span><span class="sxs-lookup"><span data-stu-id="40a1e-104">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="40a1e-105">Toto téma vysvětluje, jak serializátor funguje.</span><span class="sxs-lookup"><span data-stu-id="40a1e-105">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="40a1e-106">Při serializaci .NET Framework objektů, serializátor rozumí celé řadě programovacích modelů serializace, včetně nového modelu *kontraktu dat* .</span><span class="sxs-lookup"><span data-stu-id="40a1e-106">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="40a1e-107">Úplný seznam podporovaných typů najdete v tématu [typy podporované serializátorem kontraktu dat](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-107">For a full list of supported types, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="40a1e-108">Úvod do kontraktů dat najdete v tématu [Použití kontraktů dat](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-108">For an introduction to data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="40a1e-109">Při deserializaci kódu XML serializátor používá <xref:System.Xml.XmlReader> třídy a. <xref:System.Xml.XmlWriter></span><span class="sxs-lookup"><span data-stu-id="40a1e-109">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="40a1e-110">Podporuje <xref:System.Xml.XmlDictionaryReader> také třídy a <xref:System.Xml.XmlDictionaryWriter> , které jim umožňují vydávat optimalizované XML v některých případech, například při použití binárního formátu XML služby WCF.</span><span class="sxs-lookup"><span data-stu-id="40a1e-110">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="40a1e-111">WCF zahrnuje i doprovodný serializátor <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="40a1e-111">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="40a1e-112">Rozhraní <xref:System.Runtime.Serialization.NetDataContractSerializer> je podobné <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> serializátorům a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> , protože také generuje .NET Framework názvy typů jako součást serializovaných dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-112">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span> <span data-ttu-id="40a1e-113">Používá se, pokud jsou stejné typy sdíleny na serializaci a na konci serializace.</span><span class="sxs-lookup"><span data-stu-id="40a1e-113">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="40a1e-114">A jsou odvozeny od <xref:System.Runtime.Serialization.XmlObjectSerializer>společné základní třídy,. <xref:System.Runtime.Serialization.NetDataContractSerializer> <xref:System.Runtime.Serialization.DataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="40a1e-114">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="40a1e-115"><xref:System.Runtime.Serialization.DataContractSerializer> Serializovat řetězce obsahující řídicí znaky s hexadecimální hodnotou nižší než 20 jako entity XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-115">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="40a1e-116">To může způsobit problém s klientem jiného typu než WCF při odesílání takových dat službě WCF.</span><span class="sxs-lookup"><span data-stu-id="40a1e-116">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="40a1e-117">Vytvoření instance DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="40a1e-117">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="40a1e-118">Vytvoření instance <xref:System.Runtime.Serialization.DataContractSerializer> je důležitým krokem.</span><span class="sxs-lookup"><span data-stu-id="40a1e-118">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="40a1e-119">Po dokončení konstrukce nemůžete změnit žádné nastavení.</span><span class="sxs-lookup"><span data-stu-id="40a1e-119">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="40a1e-120">Zadání kořenového typu</span><span class="sxs-lookup"><span data-stu-id="40a1e-120">Specifying the Root Type</span></span>  
 <span data-ttu-id="40a1e-121">*Kořenový typ* je typ, který instance jsou serializovány nebo deserializovány.</span><span class="sxs-lookup"><span data-stu-id="40a1e-121">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="40a1e-122">Má mnoho přetížení konstruktoru, ale alespoň kořenový typ musí být dodán `type` pomocí parametru. <xref:System.Runtime.Serialization.DataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="40a1e-122">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="40a1e-123">Serializátor vytvořený pro určitý kořenový typ nelze použít k serializaci (nebo deserializaci) jiného typu, pokud typ není odvozen z kořenového typu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-123">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="40a1e-124">Následující příklad ukazuje dvě třídy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-124">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="40a1e-125">Tento kód vytvoří instanci `DataContractSerializer` `Person` třídy, kterou lze použít pouze k serializaci nebo deserializaci instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-125">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="40a1e-126">Určení známých typů</span><span class="sxs-lookup"><span data-stu-id="40a1e-126">Specifying Known Types</span></span>  
 <span data-ttu-id="40a1e-127">Pokud jsou polymorfismus zapojeny do serializovaných typů, které již nejsou zpracovávány pomocí <xref:System.Runtime.Serialization.KnownTypeAttribute> atributu nebo nějakého jiného mechanismu, je nutné předat do konstruktoru serializátoru `knownTypes` pomocí parametru seznam možných známých typů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-127">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="40a1e-128">Další informace o známých typů najdete v tématu [známé typy kontraktů dat](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-128">For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="40a1e-129">Následující příklad ukazuje třídu, `LibraryPatron`, která obsahuje kolekci konkrétního typu `LibraryItem`,.</span><span class="sxs-lookup"><span data-stu-id="40a1e-129">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="40a1e-130">Druhá třída definuje `LibraryItem` typ.</span><span class="sxs-lookup"><span data-stu-id="40a1e-130">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="40a1e-131">Třetí a čtyři třídy (`Book` a `Newspaper`) dědí z `LibraryItem` třídy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-131">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="40a1e-132">Následující kód vytvoří instanci serializátoru pomocí `knownTypes` parametru.</span><span class="sxs-lookup"><span data-stu-id="40a1e-132">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="40a1e-133">Určení výchozího kořenového názvu a oboru názvů</span><span class="sxs-lookup"><span data-stu-id="40a1e-133">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="40a1e-134">Obvykle při serializaci objektu je výchozí název a obor názvů nejvzdálenějšího elementu XML určen podle názvu a oboru názvů kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-134">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="40a1e-135">Názvy všech vnitřních prvků jsou určeny z názvů datových členů a jejich obor názvů je obor názvů kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-135">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="40a1e-136">Následující příklad nastaví `Name` a `Namespace` hodnoty v konstruktorech <xref:System.Runtime.Serialization.DataContractAttribute> tříd a <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="40a1e-136">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="40a1e-137">Serializace instance `Person` třídy vytvoří jazyk XML podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-137">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="40a1e-138">Můžete však přizpůsobit výchozí název a obor názvů kořenového prvku předáním hodnot `rootName` parametrů a `rootNamespace` do <xref:System.Runtime.Serialization.DataContractSerializer> konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="40a1e-138">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="40a1e-139">Všimněte si, `rootNamespace` že nemá vliv na obor názvů obsažených prvků, které odpovídají datovým členům.</span><span class="sxs-lookup"><span data-stu-id="40a1e-139">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="40a1e-140">Má vliv pouze na obor názvů nejvzdálenějšího prvku.</span><span class="sxs-lookup"><span data-stu-id="40a1e-140">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="40a1e-141">Tyto hodnoty mohou být předány jako řetězce nebo instance <xref:System.Xml.XmlDictionaryString> třídy, aby bylo možné jejich optimalizaci použít v binárním formátu XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-141">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="40a1e-142">Nastavení maximální kvóty objektů</span><span class="sxs-lookup"><span data-stu-id="40a1e-142">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="40a1e-143">Některá `DataContractSerializer` přetížení konstruktoru `maxItemsInObjectGraph` mají parametr.</span><span class="sxs-lookup"><span data-stu-id="40a1e-143">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="40a1e-144">Tento parametr určuje maximální počet objektů, které serializátor serializace nebo deserializace v rámci jediného <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> volání metody.</span><span class="sxs-lookup"><span data-stu-id="40a1e-144">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="40a1e-145">(Metoda vždy přečte jeden kořenový objekt, ale tento objekt může mít v datových členech jiné objekty.</span><span class="sxs-lookup"><span data-stu-id="40a1e-145">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="40a1e-146">Tyto objekty mohou mít jiné objekty atd.) Výchozí hodnota je 65536.</span><span class="sxs-lookup"><span data-stu-id="40a1e-146">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="40a1e-147">Všimněte si, že při serializaci nebo deserializaci polí se všechny položky pole počítají jako samostatný objekt.</span><span class="sxs-lookup"><span data-stu-id="40a1e-147">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="40a1e-148">Všimněte si také, že některé objekty můžou mít velké množství paměti, takže tato kvóta nemusí být dostačující k tomu, aby se zabránilo útokům DOS (Denial of Service).</span><span class="sxs-lookup"><span data-stu-id="40a1e-148">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="40a1e-149">Další informace najdete v tématu věnovaném [bezpečnostním hlediskům pro data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-149">For more information, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="40a1e-150">Pokud potřebujete zvýšit tuto kvótu nad rámec výchozí hodnoty, je důležité tak učinit jak na straně odesílajícího (serializace), tak na příjmu (deserializaci), protože platí pro při čtení a zápisu dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-150">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="40a1e-151">Výměna cest</span><span class="sxs-lookup"><span data-stu-id="40a1e-151">Round Trips</span></span>  
 <span data-ttu-id="40a1e-152">K *kruhovému přenosu* dojde v případě deserializace objektu a jeho opětovné serializace v jedné operaci.</span><span class="sxs-lookup"><span data-stu-id="40a1e-152">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="40a1e-153">Proto přechází z formátu XML do instance objektu a zpět do datového proudu XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-153">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="40a1e-154">Některá `DataContractSerializer` přetížení konstruktoru `ignoreExtensionDataObject` mají parametr, který je ve výchozím nastavení nastaven na `false` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-154">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="40a1e-155">V tomto výchozím režimu lze data odesílat z novější verze kontraktu dat prostřednictvím starší verze a zpět na novější verzi bez ztráty, pokud kontrakt dat implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="40a1e-155">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="40a1e-156">Předpokládejme například, `Person` že verze 1 kontraktu dat `Name` obsahuje `Nickname` datové členy a `PhoneNumber` a verze 2 přidá člena.</span><span class="sxs-lookup"><span data-stu-id="40a1e-156">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="40a1e-157">Pokud `IExtensibleDataObject` je implementována při odesílání informací z verze 2 na verzi 1 `Nickname` , jsou data uložena a poté znovu vygenerována, když jsou data znovu serializována; proto během odezvy se neztratí žádná data.</span><span class="sxs-lookup"><span data-stu-id="40a1e-157">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="40a1e-158">Další informace najdete v tématu [kontrakty dat kompatibilní](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) s dopředné a [verze kontraktu dat](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-158">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) and [Data Contract Versioning](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="40a1e-159">Otázky týkající se platnosti zabezpečení a schématu u zpátečních cest</span><span class="sxs-lookup"><span data-stu-id="40a1e-159">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="40a1e-160">Zpáteční cesty můžou mít vliv na zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="40a1e-160">Round trips may have security implications.</span></span> <span data-ttu-id="40a1e-161">Například deserializace a ukládání velkých objemů nadbytečná data může představovat bezpečnostní riziko.</span><span class="sxs-lookup"><span data-stu-id="40a1e-161">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="40a1e-162">Může dojít k potížím se zabezpečením při opětovném generování těchto dat, což neexistuje způsob, jak je ověřit, zejména pokud se jedná o digitální podpisy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-162">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="40a1e-163">Například v předchozím scénáři může koncový bod verze 1 podepsat `Nickname` hodnotu, která obsahuje škodlivá data.</span><span class="sxs-lookup"><span data-stu-id="40a1e-163">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="40a1e-164">V některých případech se může jednat o platnosti schématu: koncový bod může chtít vždycky vygenerovat data, která striktně vyhovují příslušné uvedené smlouvě, a ne žádné další hodnoty.</span><span class="sxs-lookup"><span data-stu-id="40a1e-164">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="40a1e-165">V předchozím příkladu kontrakt koncového bodu verze 1 říká, že posílá pouze `Name` a `PhoneNumber`a pokud se používá ověřování schématu, vygenerování nadbytečné `Nickname` hodnoty způsobí, že se ověření nezdaří.</span><span class="sxs-lookup"><span data-stu-id="40a1e-165">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="40a1e-166">Povolení a zakázání zpátečních cest</span><span class="sxs-lookup"><span data-stu-id="40a1e-166">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="40a1e-167">Pokud chcete vypnout zpáteční cesty, Neimplementujte <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="40a1e-167">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="40a1e-168">Pokud nemáte žádnou kontrolu nad typy, nastavte `ignoreExtensionDataObject` parametr na `true` , aby dosáhl stejného efektu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-168">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="40a1e-169">Zachování grafu objektu</span><span class="sxs-lookup"><span data-stu-id="40a1e-169">Object Graph Preservation</span></span>  
 <span data-ttu-id="40a1e-170">V normálním případě serializátor nezáleží na identitě objektu, jak je uvedeno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-170">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="40a1e-171">Následující kód vytvoří nákupní objednávku.</span><span class="sxs-lookup"><span data-stu-id="40a1e-171">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="40a1e-172">Všimněte si `billTo` , `shipTo` že a pole jsou nastavena na stejnou instanci objektu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-172">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="40a1e-173">Vygenerovaný kód XML však duplicitní informace duplikuje a vypadá podobně jako následující kód XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-173">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="40a1e-174">Tento přístup ale má následující vlastnosti, které mohou být nežádoucí:</span><span class="sxs-lookup"><span data-stu-id="40a1e-174">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="40a1e-175">Předepsané.</span><span class="sxs-lookup"><span data-stu-id="40a1e-175">Performance.</span></span> <span data-ttu-id="40a1e-176">Replikace dat je neefektivní.</span><span class="sxs-lookup"><span data-stu-id="40a1e-176">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="40a1e-177">Cyklické odkazy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-177">Circular references.</span></span> <span data-ttu-id="40a1e-178">Pokud objekty odkazují samy na sebe, dokonce i přes jiné objekty, serializace podle výsledků replikace vede k nekonečné smyčce.</span><span class="sxs-lookup"><span data-stu-id="40a1e-178">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="40a1e-179">(Serializátor vyvolá výjimku, <xref:System.Runtime.Serialization.SerializationException> Pokud k tomu dojde.)</span><span class="sxs-lookup"><span data-stu-id="40a1e-179">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="40a1e-180">Sémantiku.</span><span class="sxs-lookup"><span data-stu-id="40a1e-180">Semantics.</span></span> <span data-ttu-id="40a1e-181">Někdy je důležité zachovat fakt, že dva odkazy odkazují na stejný objekt, a ne na dva identické objekty.</span><span class="sxs-lookup"><span data-stu-id="40a1e-181">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="40a1e-182">Z těchto důvodů `preserveObjectReferences` mají některá `DataContractSerializer` přetížení konstruktoru parametr (výchozí hodnota je `false`).</span><span class="sxs-lookup"><span data-stu-id="40a1e-182">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="40a1e-183">Pokud je tento parametr nastaven na `true`, je použita speciální metoda kódování odkazů na objekty, který je použit pouze pro WCF.</span><span class="sxs-lookup"><span data-stu-id="40a1e-183">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="40a1e-184">Při nastavení na `true`je příklad kódu XML nyní podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-184">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="40a1e-185">Obor názvů "ser" odkazuje na standardní obor názvů serializace `http://schemas.microsoft.com/2003/10/Serialization/`,.</span><span class="sxs-lookup"><span data-stu-id="40a1e-185">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="40a1e-186">Každá část dat je serializována pouze jednou a s daným číslem ID a následné použití má za následek odkaz na již serializovaná data.</span><span class="sxs-lookup"><span data-stu-id="40a1e-186">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="40a1e-187">V případě, že jsou v kontraktu `XMLElement`dat přítomné atributy ID i "ref", je dodržen atribut "ref" a atribut "ID" se ignoruje.</span><span class="sxs-lookup"><span data-stu-id="40a1e-187">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="40a1e-188">Je důležité pochopit omezení tohoto režimu:</span><span class="sxs-lookup"><span data-stu-id="40a1e-188">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="40a1e-189">Kód XML, `DataContractSerializer` který `preserveObjectReferences` je nastaven na `true` hodnotu, nelze vzájemně spolupracovat s jinými technologiemi a lze k němu přistupovat pouze jinou `DataContractSerializer` instancí `preserveObjectReferences` , a `true`to i s nastavením na.</span><span class="sxs-lookup"><span data-stu-id="40a1e-189">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="40a1e-190">Pro tuto funkci neexistuje žádná podpora metadat (schémat).</span><span class="sxs-lookup"><span data-stu-id="40a1e-190">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="40a1e-191">Vytvořené schéma je platné pouze v případě `preserveObjectReferences` , že je nastavena na. `false`</span><span class="sxs-lookup"><span data-stu-id="40a1e-191">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="40a1e-192">Tato funkce může způsobit pomalejší spuštění procesu serializace a deserializace.</span><span class="sxs-lookup"><span data-stu-id="40a1e-192">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="40a1e-193">I když data není nutné replikovat, je nutné v tomto režimu provést zvláštní porovnání objektů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-193">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="40a1e-194">Když je `maxItemsInObjectGraph` režim povolený, je obzvláště důležité nastavit hodnotu na správnou kvótu. `preserveObjectReferences`</span><span class="sxs-lookup"><span data-stu-id="40a1e-194">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="40a1e-195">Vzhledem k tomu, jak jsou v tomto režimu zpracovávány pole, je snadné vytvořit malou škodlivou zprávu, která má za následek omezenou spotřebu paměti omezenou pouze `maxItemsInObjectGraph` kvótou.</span><span class="sxs-lookup"><span data-stu-id="40a1e-195">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="40a1e-196">Zadání náhrady pro kontrakt dat</span><span class="sxs-lookup"><span data-stu-id="40a1e-196">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="40a1e-197">Některá `DataContractSerializer` přetížení konstruktoru `dataContractSurrogate` mají parametr, který může být nastaven na `null`hodnotu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-197">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="40a1e-198">V opačném případě můžete použít k zadání *náhrady za kontrakt dat*, což je typ, který implementuje <xref:System.Runtime.Serialization.IDataContractSurrogate> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="40a1e-198">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="40a1e-199">Pak můžete použít rozhraní k přizpůsobení procesu serializace a deserializace.</span><span class="sxs-lookup"><span data-stu-id="40a1e-199">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="40a1e-200">Další informace najdete v tématu [náhrada za kontrakty dat](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-200">For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="40a1e-201">Serializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-201">Serialization</span></span>  
 <span data-ttu-id="40a1e-202">Následující informace platí pro jakoukoliv třídu, která dědí z <xref:System.Runtime.Serialization.XmlObjectSerializer>třídy, <xref:System.Runtime.Serialization.DataContractSerializer> včetně tříd a <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="40a1e-202">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="40a1e-203">Jednoduchá serializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-203">Simple Serialization</span></span>  
 <span data-ttu-id="40a1e-204">Nejzákladnější způsob serializace objektu je předat <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metodě.</span><span class="sxs-lookup"><span data-stu-id="40a1e-204">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="40a1e-205">Existují tři přetížení, jedno pro zápis do <xref:System.IO.Stream> <xref:System.Xml.XmlWriter>, nebo <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="40a1e-205">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="40a1e-206">V případě <xref:System.IO.Stream> přetížení je výstupem XML v kódování UTF-8.</span><span class="sxs-lookup"><span data-stu-id="40a1e-206">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="40a1e-207"><xref:System.Xml.XmlDictionaryWriter> S přetížením serializátor optimalizuje svůj výstup pro binární XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-207">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="40a1e-208">Při použití <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metody serializátor používá výchozí název a obor názvů pro prvek obálky a zapíše jej společně s obsahem (viz předchozí část určení výchozího kořenového názvu a oboru názvů).</span><span class="sxs-lookup"><span data-stu-id="40a1e-208">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="40a1e-209">Následující příklad ukazuje zápis pomocí <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="40a1e-209">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="40a1e-210">To vytváří XML podobně jako následující.</span><span class="sxs-lookup"><span data-stu-id="40a1e-210">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="40a1e-211">Krok za krokem serializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-211">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="40a1e-212">Použijte metody <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> a<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> pro zápis elementu end, zápis obsahu objektu a zavření prvku obálky, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="40a1e-212">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="40a1e-213">Nejsou k dispozici žádná <xref:System.IO.Stream> přetížení těchto metod.</span><span class="sxs-lookup"><span data-stu-id="40a1e-213">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="40a1e-214">Tato podrobná serializace má dvě společná použití.</span><span class="sxs-lookup"><span data-stu-id="40a1e-214">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="40a1e-215">Jedním z nich je vložení obsahu, jako jsou atributy nebo `WriteStartObject` komentáře `WriteObjectContent`mezi a, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-215">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="40a1e-216">To vytváří XML podobně jako následující.</span><span class="sxs-lookup"><span data-stu-id="40a1e-216">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="40a1e-217">Dalším běžným použitím je vyhnout se <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> použití <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> a zcela a napsat vlastní prvek obálky (nebo dokonce přepsat obálku zcela), jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-217">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="40a1e-218">To vytváří XML podobně jako následující.</span><span class="sxs-lookup"><span data-stu-id="40a1e-218">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="40a1e-219">Použití serializace na základě kroku může vést ke schématu – neplatné XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-219">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="40a1e-220">Deserializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-220">Deserialization</span></span>  
 <span data-ttu-id="40a1e-221">Následující informace platí pro jakoukoliv třídu, která dědí z <xref:System.Runtime.Serialization.XmlObjectSerializer>třídy, <xref:System.Runtime.Serialization.DataContractSerializer> včetně tříd a <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="40a1e-221">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="40a1e-222">Nejzákladnější způsob, jak zrušit serializaci objektu, je zavolat jedno z <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> přetížení metody.</span><span class="sxs-lookup"><span data-stu-id="40a1e-222">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="40a1e-223">Existují tři přetížení, jedno pro čtení pomocí <xref:System.Xml.XmlDictionaryReader> `XmlReader`, nebo `Stream`.</span><span class="sxs-lookup"><span data-stu-id="40a1e-223">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="40a1e-224">Všimněte si, `Stream` že přetížení vytvoří text <xref:System.Xml.XmlDictionaryReader> , který není chráněn žádnými kvótami a měl by být použit pouze pro čtení důvěryhodných dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-224">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="40a1e-225">Všimněte si také, že objekt `ReadObject` , který vrací metodu, musí být převedena na příslušný typ.</span><span class="sxs-lookup"><span data-stu-id="40a1e-225">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="40a1e-226">Následující kód vytvoří instanci <xref:System.Runtime.Serialization.DataContractSerializer> třídy <xref:System.Xml.XmlDictionaryReader>a a `Person` poté deserializaci instance.</span><span class="sxs-lookup"><span data-stu-id="40a1e-226">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="40a1e-227">Před voláním <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> metody umístěte čtecí modul XML na prvek obálky nebo na uzel bez obsahu, který předchází prvku obálky.</span><span class="sxs-lookup"><span data-stu-id="40a1e-227">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="40a1e-228">To lze provést voláním <xref:System.Xml.XmlReader.Read%2A> metody <xref:System.Xml.XmlReader> nebo jejího <xref:System.Xml.XmlReader.NodeType%2A>odvození a otestováním, jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-228">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="40a1e-229">Všimněte si, že je možné číst atributy tohoto prvku obálky před tím, než se `ReadObject`čtecí modul dopustí do.</span><span class="sxs-lookup"><span data-stu-id="40a1e-229">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="40a1e-230">Při použití jednoho z jednoduchých `ReadObject` přetížení vyhledá deserializátor výchozí název a obor názvů v prvku obálky (viz předchozí oddíl určení výchozího kořenového názvu a oboru názvů ") a vyvolá výjimku, pokud nalezne neznámou hodnotu. objekt.</span><span class="sxs-lookup"><span data-stu-id="40a1e-230">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="40a1e-231">V předchozím příkladu `<Person>` je očekáván prvek obálky.</span><span class="sxs-lookup"><span data-stu-id="40a1e-231">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="40a1e-232"><xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> Metoda je volána k ověření, zda je čtecí modul umístěn na elementu, který je pojmenován podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="40a1e-232">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="40a1e-233">Existuje způsob, jak zakázat tuto kontrolu názvu elementu obálky; Některá přetížení `ReadObject` metody přebírají parametr `verifyObjectName`Boolean, který je ve výchozím nastavení nastaven na `true` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-233">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="40a1e-234">Při nastavení na `false`je ignorován název a obor názvů prvku obálky.</span><span class="sxs-lookup"><span data-stu-id="40a1e-234">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="40a1e-235">To je užitečné pro čtení XML, které bylo napsáno pomocí podrobného mechanismu serializace popsané výše.</span><span class="sxs-lookup"><span data-stu-id="40a1e-235">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="40a1e-236">Použití NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="40a1e-236">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="40a1e-237">Hlavní `DataContractSerializer` rozdíl mezi <xref:System.Runtime.Serialization.NetDataContractSerializer> a je, že `DataContractSerializer` používá názvy kontraktů dat, zatímco `NetDataContractSerializer` výstupy jsou úplné .NET Framework sestavení a názvů typů v serializovaném kódu XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-237">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="40a1e-238">To znamená, že mezi koncovými body serializace a deserializace musí být sdíleny přesně stejné typy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-238">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="40a1e-239">To znamená, že známý typ mechanismu není vyžadován s, `NetDataContractSerializer` protože přesné typy, které mají být deserializovány, jsou vždy známy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-239">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="40a1e-240">Může ale dojít k několika problémům:</span><span class="sxs-lookup"><span data-stu-id="40a1e-240">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="40a1e-241">Bezpečnost.</span><span class="sxs-lookup"><span data-stu-id="40a1e-241">Security.</span></span> <span data-ttu-id="40a1e-242">Je načten libovolný typ nalezený v souboru XML deserializovat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-242">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="40a1e-243">To lze zneužít k vynucení načítání škodlivých typů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-243">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="40a1e-244">Použití s nedůvěryhodnými daty by mělo být provedeno pouze v případě, že je <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> použit *pořadač serializace* (pomocí vlastnosti nebo parametru konstruktoru). `NetDataContractSerializer`</span><span class="sxs-lookup"><span data-stu-id="40a1e-244">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="40a1e-245">Pořadač povoluje načtení pouze bezpečných typů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-245">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="40a1e-246">Mechanizmus pořadače je totožný s typem <xref:System.Runtime.Serialization> , který používá obor názvů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-246">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="40a1e-247">Správa verzí.</span><span class="sxs-lookup"><span data-stu-id="40a1e-247">Versioning.</span></span> <span data-ttu-id="40a1e-248">Použití úplného typu a názvů sestavení v jazyce XML přísně omezuje způsob, jakým mohou být typy verzí.</span><span class="sxs-lookup"><span data-stu-id="40a1e-248">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="40a1e-249">Následující nelze změnit: názvy typů, obory názvů, názvy sestavení a verze sestavení.</span><span class="sxs-lookup"><span data-stu-id="40a1e-249">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="40a1e-250">Nastavení vlastnosti nebo parametru konstruktoru na <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> místo výchozí hodnoty <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> umožňuje použít změny verze sestavení, ale ne pro obecné typy parametrů. <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A></span><span class="sxs-lookup"><span data-stu-id="40a1e-250">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="40a1e-251">Vzájemné.</span><span class="sxs-lookup"><span data-stu-id="40a1e-251">Interoperability.</span></span> <span data-ttu-id="40a1e-252">Vzhledem k tomu, že .NET Framework typ a názvy sestavení jsou součástí XML, jiné platformy, než je .NET Framework, nemají přístup k výsledným datům.</span><span class="sxs-lookup"><span data-stu-id="40a1e-252">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="40a1e-253">Předepsané.</span><span class="sxs-lookup"><span data-stu-id="40a1e-253">Performance.</span></span> <span data-ttu-id="40a1e-254">Zápis typů a názvů sestavení významně zvyšuje velikost výsledného kódu XML.</span><span class="sxs-lookup"><span data-stu-id="40a1e-254">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="40a1e-255">Tento mechanismus je podobný binárnímu souboru nebo serializaci SOAP, kterou používá .NET Framework Vzdálená komunikace <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> (konkrétně <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>, a).</span><span class="sxs-lookup"><span data-stu-id="40a1e-255">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="40a1e-256">Použití rozhraní `NetDataContractSerializer` je podobné jako `DataContractSerializer`použití, s následujícími rozdíly:</span><span class="sxs-lookup"><span data-stu-id="40a1e-256">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="40a1e-257">Konstruktory nevyžadují zadání kořenového typu.</span><span class="sxs-lookup"><span data-stu-id="40a1e-257">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="40a1e-258">Můžete serializovat libovolný typ se stejnou instancí `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="40a1e-258">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="40a1e-259">Konstruktory nepřijímají seznam známých typů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-259">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="40a1e-260">Pokud jsou názvy typů serializovány do XML, je mechanismus známých typů zbytečné.</span><span class="sxs-lookup"><span data-stu-id="40a1e-260">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="40a1e-261">Konstruktory neakceptují náhradu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="40a1e-261">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="40a1e-262">Místo toho přijmou parametr s <xref:System.Runtime.Serialization.ISurrogateSelector> názvem `surrogateSelector` <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> (který se mapuje na vlastnost).</span><span class="sxs-lookup"><span data-stu-id="40a1e-262">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="40a1e-263">Toto je starší náhradní mechanismus.</span><span class="sxs-lookup"><span data-stu-id="40a1e-263">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="40a1e-264">Konstruktory přijímají parametr s názvem `assemblyFormat` <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> , který se mapuje na <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="40a1e-264">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="40a1e-265">Jak bylo popsáno dříve, lze použít k vylepšení možností správy verzí serializátoru.</span><span class="sxs-lookup"><span data-stu-id="40a1e-265">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="40a1e-266">Jedná se o stejný <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanismus jako v binárním souboru nebo v serializaci SOAP.</span><span class="sxs-lookup"><span data-stu-id="40a1e-266">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="40a1e-267">Konstruktory přijímají <xref:System.Runtime.Serialization.StreamingContext> parametr s názvem `context` , který se mapuje <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> na vlastnost.</span><span class="sxs-lookup"><span data-stu-id="40a1e-267">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="40a1e-268">Tuto možnost můžete použít k předávání informací do serializovaných typů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-268">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="40a1e-269">Toto použití je shodné <xref:System.Runtime.Serialization.StreamingContext> s mechanismem používaným v jiných <xref:System.Runtime.Serialization> třídách.</span><span class="sxs-lookup"><span data-stu-id="40a1e-269">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="40a1e-270"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> Metodya<xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> jsou aliasy pro <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> metody a.<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A></span><span class="sxs-lookup"><span data-stu-id="40a1e-270">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="40a1e-271">Existují pro zajištění jednotnějšího programovacího modelu pomocí binárního souboru nebo serializace SOAP.</span><span class="sxs-lookup"><span data-stu-id="40a1e-271">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="40a1e-272">Další informace o těchto funkcích naleznete v tématu [binární serializace](../../../standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="40a1e-272">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="40a1e-273">Formáty XML, které jsou `NetDataContractSerializer` `DataContractSerializer` a používají obvykle, nejsou kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="40a1e-273">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="40a1e-274">To znamená, že při pokusu o serializaci jedním z těchto serializátorů a deserializace u druhého není podporován scénář.</span><span class="sxs-lookup"><span data-stu-id="40a1e-274">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="40a1e-275">Všimněte si také, že `NetDataContractSerializer` nevýstupuje úplný .NET Framework typ a název sestavení pro každý uzel v grafu objektů.</span><span class="sxs-lookup"><span data-stu-id="40a1e-275">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="40a1e-276">Vypisuje tyto informace pouze tam, kde je dvojznačný.</span><span class="sxs-lookup"><span data-stu-id="40a1e-276">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="40a1e-277">To znamená výstup na úrovni kořenového objektu a pro všechny polymorfní případy.</span><span class="sxs-lookup"><span data-stu-id="40a1e-277">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="40a1e-278">Viz také:</span><span class="sxs-lookup"><span data-stu-id="40a1e-278">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="40a1e-279">Binární serializace</span><span class="sxs-lookup"><span data-stu-id="40a1e-279">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="40a1e-280">Typy podporované serializátorem kontraktu dat</span><span class="sxs-lookup"><span data-stu-id="40a1e-280">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
