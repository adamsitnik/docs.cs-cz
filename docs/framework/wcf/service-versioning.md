---
title: Verze služby
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: f3cb01531c594df5262963567438b47cbbed58a2
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/22/2019
ms.locfileid: "69923020"
---
# <a name="service-versioning"></a><span data-ttu-id="9cbc8-102">Verze služby</span><span class="sxs-lookup"><span data-stu-id="9cbc8-102">Service Versioning</span></span>
<span data-ttu-id="9cbc8-103">Po počátečním nasazení a potenciálně delší dobu během své životnosti, služeb (a koncových bodů, které zveřejňuje) může být potřeba změnit z nejrůznějších důvodů, jako jsou třeba změny obchodních potřeb, požadavky na informační technologie nebo jiné adresy Chyba.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="9cbc8-104">Každá změna zavádí novou verzi služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="9cbc8-105">Toto téma vysvětluje, jak zvážit správu verzí v Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="9cbc8-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="9cbc8-106">Čtyři kategorie změn služby</span><span class="sxs-lookup"><span data-stu-id="9cbc8-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="9cbc8-107">Změny služeb, které mohou být požadovány, lze klasifikovat do čtyř kategorií:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="9cbc8-108">Změny kontraktu: Například může být přidána operace, nebo je možné přidat nebo změnit datový prvek ve zprávě.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="9cbc8-109">Změny adresy: Například služba se přesune na jiné místo, kde koncové body mají nové adresy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="9cbc8-110">Změny vazeb: Například změna mechanismu zabezpečení nebo změny nastavení.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="9cbc8-111">Změny implementace: Například při změně implementace interní metody.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="9cbc8-112">Některé z těchto změn se nazývají "přerušení" a jiné jsou "nerozdělitelné".</span><span class="sxs-lookup"><span data-stu-id="9cbc8-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="9cbc8-113">Změna je nepřerušená, pokud se všechny zprávy, které by byly úspěšně zpracovány v předchozí verzi, úspěšně zpracovaly v nové verzi.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="9cbc8-114">Jakékoli změny, které nesplňují toto kritérium, jsou zásadní změnou.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="9cbc8-115">Orientace služby a správa verzí</span><span class="sxs-lookup"><span data-stu-id="9cbc8-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="9cbc8-116">Jednou z principyí služby je, že služby a klienti jsou autonomní (nebo nezávislé).</span><span class="sxs-lookup"><span data-stu-id="9cbc8-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="9cbc8-117">Mimo jiné to znamená, že vývojáři služeb nemůžou předpokládat, že ovládají nebo dokonce znají informace o všech klientech služeb.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="9cbc8-118">Tím se eliminuje možnost opětovného sestavení a opětovného nasazení všech klientů, když služba změní verze.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="9cbc8-119">Toto téma předpokládá, že služba dodržuje tyto principem, a proto musí být změněna nebo "se správou" verzí nezávisle na svých klientech.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="9cbc8-120">V případech, kdy je zásadní změna neočekávaná a nelze se jí vyhnout, může aplikace zvolit ignorování tohoto principem a vyžadovat, aby klienti znovu vytvořili a nasadili novou verzi služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="9cbc8-121">Správa verzí kontraktů</span><span class="sxs-lookup"><span data-stu-id="9cbc8-121">Contract Versioning</span></span>  
 <span data-ttu-id="9cbc8-122">Smlouvy používané klientem nemusí být stejné jako kontrakt používaný službou. potřebují být jenom kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="9cbc8-123">Pro kontrakty služeb se dá přidat nové operace vystavené službou, ale existující operace se nedají odebrat ani změnit sémanticky.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="9cbc8-124">U kontraktů dat se dají přidat nové definice typu schématu, ale existující definice typu schématu se nedají změnit rozlomeným způsobem.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="9cbc8-125">Průlomové změny můžou zahrnovat odebrání datových členů nebo změnu jejich datového typu konstrukce.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="9cbc8-126">Tato funkce umožňuje službě určitou zeměpisnou šířku při změně verze svých smluv bez přerušujících klientů.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="9cbc8-127">Následující dvě části vysvětlují nepřerušené a zásadní změny, které je možné provést na data WCF a kontrakty služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="9cbc8-128">Správa verzí kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="9cbc8-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="9cbc8-129">Tato část se zabývá používáním správy verzí dat při <xref:System.Runtime.Serialization.DataContractSerializer> použití <xref:System.Runtime.Serialization.DataContractAttribute> tříd a.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="9cbc8-130">Striktní verze</span><span class="sxs-lookup"><span data-stu-id="9cbc8-130">Strict Versioning</span></span>  
 <span data-ttu-id="9cbc8-131">V mnoha scénářích, kdy dochází k potížím s změnou verzí, vývojář služby nemá kontrolu nad klienty, a proto nemůže vytvořit předpoklady, jak by mohly reagovat na změny ve zprávě XML nebo schématu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="9cbc8-132">V těchto případech je potřeba zaručit, že se nové zprávy ověřují oproti starému schématu, a to z těchto důvodů:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="9cbc8-133">Původní klienti byli vyvinuti s předpokladem, že se schéma nezmění.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="9cbc8-134">Nemusí podařit zpracovat zprávy, pro které nebyly nikdy navrženy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="9cbc8-135">Starší klienti mohou provádět skutečné ověření schématu proti původnímu schématu před tím, než se bude pokoušet o zpracování zpráv.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="9cbc8-136">Doporučený postup v takových scénářích je považovat stávající kontrakty dat za neměnné a vytvořit nové s jedinečnými názvy XML kvalifikovaných názvů.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="9cbc8-137">Vývojář služby by pak buď přidal nové metody do existující smlouvy o službě, nebo vytvořil novou kontrakt služby s metodami, které používají novou kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="9cbc8-138">Často se jedná o případ, kdy vývojář služby potřebuje napsat nějakou obchodní logiku, která by se měla spustit ve všech verzích kontraktu dat a obchodním kódem specifickém pro každou verzi kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="9cbc8-139">Příloha na konci tohoto tématu vysvětluje, jak lze použít rozhraní pro splnění této potřeby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="9cbc8-140">Správa verzí LAX</span><span class="sxs-lookup"><span data-stu-id="9cbc8-140">Lax Versioning</span></span>  
 <span data-ttu-id="9cbc8-141">V mnoha dalších scénářích může vývojář služby provést předpoklad, že přidání nového volitelného člena do kontraktu dat nebude rušit stávající klienty.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="9cbc8-142">To vyžaduje, aby vývojář služby zkontroloval, jestli stávající klienti neprováděli ověřování schématu a jestli ignorují neznámé datové členy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="9cbc8-143">V těchto scénářích je možné využít výhod funkcí kontraktu dat pro přidání nových členů do nepřerušeného způsobu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="9cbc8-144">Vývojář služby může tento předpoklad s jistotou provést, pokud byly funkce kontraktů dat pro správu verzí pro první verzi služby již použity.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="9cbc8-145">WCF, webové služby ASP.NET a mnoho dalších zásobníků webových služeb podporují *správu verzí LAX*: to znamená, že nevyvolávají výjimky pro nové neznámé datové členy v přijatých datech.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="9cbc8-146">Nemusíte se snadno domnívat, že přidáním nového člena nedojde k přerušení stávajících klientů.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="9cbc8-147">Pokud si nejste jistí, že všichni klienti můžou zpracovávat správu verzí Lax, doporučuje se používat přísné pokyny pro správu verzí a považovat kontrakty dat za neměnné.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="9cbc8-148">Podrobné pokyny pro LAX i striktní správu kontraktů dat najdete v tématu [osvědčené postupy: Správa verzí](../../../docs/framework/wcf/best-practices-data-contract-versioning.md)kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="9cbc8-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="9cbc8-149">Odlišení mezi kontraktem dat a typy .NET</span><span class="sxs-lookup"><span data-stu-id="9cbc8-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="9cbc8-150">Třídu nebo strukturu .NET lze projektovat jako kontrakt <xref:System.Runtime.Serialization.DataContractAttribute> dat použitím atributu na třídu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="9cbc8-151">Typ .NET a jeho výčnělky mají dva různé věci.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="9cbc8-152">Je možné mít více typů .NET se stejnou projekcí kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="9cbc8-153">Toto rozlišení je zvlášť užitečné v případě, že vám umožní změnit typ .NET při zachování kontraktu s plánovanými daty, což zachovává kompatibilitu se stávajícími klienty i v přísném smyslu slova.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="9cbc8-154">Existují dvě věci, které byste měli vždycky udělat, abyste zachovali toto rozlišení mezi typem .NET a kontraktem dat:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="9cbc8-155"><xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> Zadejte a .<xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A></span><span class="sxs-lookup"><span data-stu-id="9cbc8-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="9cbc8-156">Vždy byste měli zadat název a obor názvů kontraktu dat, abyste zabránili zveřejnění názvu a oboru názvů .NET typu v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="9cbc8-157">Tímto způsobem se rozhodnete, že pokud později změníte obor názvů nebo název typu .NET, váš kontrakt dat zůstane stejný.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="9cbc8-158">Zadejte <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="9cbc8-159">Vždy byste měli zadat název svých datových členů, abyste zabránili zveřejnění názvu člena .NET v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="9cbc8-160">Tímto způsobem se rozhodnete, že pokud se později rozhodnete změnit název .NET člena, váš kontrakt dat zůstane stejný.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="9cbc8-161">Změna nebo odebrání členů</span><span class="sxs-lookup"><span data-stu-id="9cbc8-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="9cbc8-162">Změna názvu nebo datového typu člena nebo odebrání datových členů je zásadní změnou, i když je povolená Správa verzí Lax.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="9cbc8-163">Pokud je to nezbytné, vytvořte novou kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="9cbc8-164">Pokud je Kompatibilita služby Vysoká důležitost, může být vhodné ignorovat nepoužívané datové členy ve vašem kódu a nechat je na místě.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="9cbc8-165">Pokud rozdělíte datový člen na více členů, můžete zvážit, že stávající člen je v místě jako vlastnost, která může provádět požadované rozdělení a opětovné agregace pro klienty nižší úrovně (klienti, kteří nejsou upgradováni na nejnovější verzi).</span><span class="sxs-lookup"><span data-stu-id="9cbc8-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="9cbc8-166">Podobně se změny v názvu nebo oboru názvů kontraktu dat mění.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="9cbc8-167">Zpáteční cesty neznámých dat</span><span class="sxs-lookup"><span data-stu-id="9cbc8-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="9cbc8-168">V některých scénářích je potřeba "zpáteční trip" neznámá data, která pocházejí od členů přidaných v nové verzi.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="9cbc8-169">Například služba "versionNew" odesílá data s některými nově přidanými členy do klienta "versionOld".</span><span class="sxs-lookup"><span data-stu-id="9cbc8-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="9cbc8-170">Klient při zpracování zprávy ignoruje nově přidané členy, ale znovu odešle stejná data, včetně nově přidaných členů, zpátky do služby versionNew.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="9cbc8-171">Typický scénář pro toto je aktualizace dat, kde se data načítají ze služby, která se změnila a vrátí.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="9cbc8-172">Chcete-li povolit příkaz round-trip pro konkrétní typ, musí tento typ <xref:System.Runtime.Serialization.IExtensibleDataObject> implementovat rozhraní.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="9cbc8-173">Rozhraní obsahuje jednu vlastnost, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> která <xref:System.Runtime.Serialization.ExtensionDataObject> vrací typ.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="9cbc8-174">Vlastnost se používá k uložení jakýchkoli dat z budoucích verzí kontraktu dat, který není aktuální verzí znám.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="9cbc8-175">Tato data jsou neprůhledná pro klienta, ale při serializaci instance se obsah <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> vlastnosti zapisuje se zbytkem dat členů kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="9cbc8-176">Doporučuje se, aby všechny typy implementovaly toto rozhraní tak, aby vyhovovalo novým a neznámým budoucím členům.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="9cbc8-177">Knihovny datových kontraktů</span><span class="sxs-lookup"><span data-stu-id="9cbc8-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="9cbc8-178">Mohou existovat knihovny kontraktů dat, ve kterých je smlouva publikována v centrálním úložišti, a implementace služeb a typů implementuje a zveřejňuje kontrakty dat z daného úložiště.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="9cbc8-179">V takovém případě, když publikujete kontrakt dat do úložiště, nemáte žádnou kontrolu nad tím, kdo vytvoří typy, které ji implementují.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="9cbc8-180">Proto nemůžete smlouvu po publikování změnit, takže její vynechání je efektivně neměnné.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="9cbc8-181">Při použití objektu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="9cbc8-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="9cbc8-182">Stejné zásady správy verzí platí při použití <xref:System.Xml.Serialization.XmlSerializer> třídy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="9cbc8-183">Když je potřeba striktní Správa verzí, považovat kontrakty dat za neměnné a vytvoří nové kontrakty dat s jedinečnými a kvalifikovanými názvy pro nové verze.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="9cbc8-184">Pokud jste si jisti, že je možné použít správu verzí Lax, můžete přidat nové serializovatelné členy v nových verzích, ale ne měnit nebo odebírat stávající členy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9cbc8-185">Používá atributy a<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>pro podporu kulatých Trip neznámých dat. <xref:System.Xml.Serialization.XmlAnyElementAttribute> <xref:System.Xml.Serialization.XmlSerializer></span><span class="sxs-lookup"><span data-stu-id="9cbc8-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="9cbc8-186">Správa verzí kontraktů zpráv</span><span class="sxs-lookup"><span data-stu-id="9cbc8-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="9cbc8-187">Pokyny pro správu verzí kontraktů zpráv jsou velmi podobné kontraktům s daty správy verzí.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="9cbc8-188">Pokud je potřeba striktní Správa verzí, neměli byste měnit text zprávy, ale místo toho můžete vytvořit nový kontrakt zprávy s jedinečným kvalifikovaným názvem.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="9cbc8-189">Pokud víte, že můžete použít správu verzí Lax, můžete přidat nové části těla zprávy, ale nemůžete je změnit nebo odebrat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="9cbc8-190">Tento návod platí pro smlouvy se zabalením a zabaleného hlášení.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="9cbc8-191">Záhlaví zpráv může být vždy přidáno i v případě, že se používá striktní Správa verzí.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="9cbc8-192">Příznak MustUnderstand může mít vliv na správu verzí.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="9cbc8-193">Obecně platí, že model správy verzí pro hlavičky v rámci WCF je jak je popsáno ve specifikaci SOAP.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="9cbc8-194">Správa verzí kontraktů služeb</span><span class="sxs-lookup"><span data-stu-id="9cbc8-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="9cbc8-195">Podobně jako správa verzí kontraktů dat zahrnuje také operace přidávání, změny a odebírání operací služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="9cbc8-196">Zadání názvu, oboru názvů a akce</span><span class="sxs-lookup"><span data-stu-id="9cbc8-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="9cbc8-197">Ve výchozím nastavení je název kontraktu služby název rozhraní.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="9cbc8-198">Jeho výchozí obor názvů je http://tempuri.org "" a akce každé operace http://tempuri.org/contractname/methodname je "".</span><span class="sxs-lookup"><span data-stu-id="9cbc8-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="9cbc8-199">Doporučuje se explicitně zadat název a obor názvů pro kontrakt služby a akci pro každou operaci vyhnout používání http://tempuri.org příkazu "" a zabránit zveřejnění názvů rozhraní a metod v kontraktu služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="9cbc8-200">Přidání parametrů a operací</span><span class="sxs-lookup"><span data-stu-id="9cbc8-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="9cbc8-201">Přidání operací služby vystavených službou je nepřerušená změna, protože stávající klienti nemusí být o těchto nových operacích zajisti.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9cbc8-202">Přidávání operací do duplexního kontraktu zpětného volání je zásadní změna.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="9cbc8-203">Mění se parametry operace nebo návratové typy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="9cbc8-204">Změna parametrů nebo návratových typů obecně představuje zásadní změnu, pokud nový typ neimplementuje stejný kontrakt dat implementovaný starým typem.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="9cbc8-205">Chcete-li takovou změnu provést, přidejte novou operaci do kontraktu služby nebo Definujte novou kontrakt služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="9cbc8-206">Odebírání operací</span><span class="sxs-lookup"><span data-stu-id="9cbc8-206">Removing Operations</span></span>  
 <span data-ttu-id="9cbc8-207">Odebírání operací je také zásadní změna.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="9cbc8-208">Pokud chcete takovou změnu udělat, definujte novou kontrakt služby a zpřístupněte ji na novém koncovém bodu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="9cbc8-209">Smlouvy o selhání</span><span class="sxs-lookup"><span data-stu-id="9cbc8-209">Fault Contracts</span></span>  
 <span data-ttu-id="9cbc8-210"><xref:System.ServiceModel.FaultContractAttribute> Atribut umožňuje vývojářům kontraktu služby zadat informace o chybách, které mohou být vráceny z operací smlouvy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="9cbc8-211">Seznam chyb popsaných v kontraktu služby není považován za vyčerpávající.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="9cbc8-212">Operace může kdykoli vracet chyby, které nejsou popsány ve smlouvě.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="9cbc8-213">Proto se změna množiny chyb popsaných ve smlouvě nepovažuje za přerušení.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="9cbc8-214">Přidejte například novou chybu ke smlouvě pomocí <xref:System.ServiceModel.FaultContractAttribute> nebo odeberte existující chybu ze smlouvy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="9cbc8-215">Knihovny kontraktů služeb</span><span class="sxs-lookup"><span data-stu-id="9cbc8-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="9cbc8-216">Organizace mohou mít knihovny smluv, kde je smlouva publikována v centrálním úložišti, a implementátori služeb implementují smlouvy z tohoto úložiště.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="9cbc8-217">Pokud v takovém případě publikujete kontrakt služby do úložiště, nebudete mít kontrolu nad tím, kdo vytvoří služby, které ji implementují.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="9cbc8-218">Proto nemůžete po publikování změnit kontrakt služby, protože ho bude efektivně neproměnlivý.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="9cbc8-219">WCF podporuje dědičnost kontraktu, která se dá použít k vytvoření nové smlouvy, která rozšiřuje stávající smlouvy.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="9cbc8-220">Chcete-li použít tuto funkci, definujte nové rozhraní kontraktu služby, které dědí z původního rozhraní kontraktu služby, a poté přidejte do nového rozhraní metody.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="9cbc8-221">Pak změníte službu, která implementuje starou smlouvu pro implementaci nové smlouvy, a změňte definici koncového bodu "versionOld" tak, aby používala nový kontrakt.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="9cbc8-222">U klientů "versionOld" se koncový bod bude i nadále zobrazovat jako vystavení kontraktu "versionOld"; pro klienty "versionNew" se zobrazí koncový bod pro vystavení kontraktu "versionNew".</span><span class="sxs-lookup"><span data-stu-id="9cbc8-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="9cbc8-223">Správa verzí adres a vazeb</span><span class="sxs-lookup"><span data-stu-id="9cbc8-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="9cbc8-224">Změny adresy a vazby koncového bodu jsou zásadní, pokud klienti nemůžou dynamicky zjišťovat novou adresu nebo vazbu nového koncového bodu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="9cbc8-225">Jedním z mechanismů pro implementaci této funkce je použití registru popisu a integrace univerzálního zjišťování a způsobu vyvolání služby UDDI, když se klient pokusí komunikovat s koncovým bodem a při selhání se dotazuje na dobře známou službu UDDI. registr pro aktuální metadata koncového bodu</span><span class="sxs-lookup"><span data-stu-id="9cbc8-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="9cbc8-226">Klient pak použije adresu a vazbu z těchto metadat ke komunikaci s koncovým bodem.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="9cbc8-227">Pokud je tato komunikace úspěšná, klient uloží adresu a informace o vazbě pro budoucí použití.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="9cbc8-228">Směrovací služba a správa verzí</span><span class="sxs-lookup"><span data-stu-id="9cbc8-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="9cbc8-229">Pokud změny provedené ve službě přerušují změny a potřebujete mít dvě nebo víc různých verzí služby spuštěných současně, můžete použít směrovací službu WCF ke směrování zpráv do příslušné instance služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="9cbc8-230">Směrovací služba WCF používá směrování na základě obsahu, jinak řečeno, používá informace v rámci zprávy k určení, kam zprávu směrovat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="9cbc8-231">Další informace o směrovací službě WCF najdete v tématu [Služba směrování](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="9cbc8-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="9cbc8-232">Příklad toho, jak používat směrovací službu WCF pro správu verzí služby, najdete v tématu [How to: Verze](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md)služby.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="9cbc8-233">Příloha</span><span class="sxs-lookup"><span data-stu-id="9cbc8-233">Appendix</span></span>  
 <span data-ttu-id="9cbc8-234">Obecné pokyny k vytváření verzí kontraktů dat v případě, že je potřeba striktní Správa verzí, je zacházet s tím, že se kontrakty dat při nutnosti změny nemění a vytvářejí nové.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="9cbc8-235">Pro každou novou kontrakt dat je třeba vytvořit novou třídu, proto je třeba zajistit, aby se zabránilo nutnosti přecházet existující kód, který byl napsán z hlediska staré třídy kontraktu dat, a přepsat jej z hlediska nové třídy kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="9cbc8-236">Jedním z těchto mechanismů je použití rozhraní k definování členů jednotlivých kontraktů dat a zápis interního implementačního kódu z podmínek rozhraní, nikoli tříd kontraktů dat, které implementují rozhraní.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="9cbc8-237">Následující kód pro verzi 1 služby zobrazuje `IPurchaseOrderV1` rozhraní `PurchaseOrderV1`a:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="9cbc8-238">I když by se operace kontraktu služby napsaly na `PurchaseOrderV1`základě, je skutečná obchodní logika z `IPurchaseOrderV1`pohledu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="9cbc8-239">Pak, ve verzi 2, by bylo nové `IPurchaseOrderV2` rozhraní a nová `PurchaseOrderV2` třída, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="9cbc8-240">Servisní smlouva by se aktualizovala tak, aby zahrnovala nové operace, které jsou `PurchaseOrderV2`zapsané ve smyslu.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="9cbc8-241">Existující obchodní logika vytvořená v souvislosti `IPurchaseOrderV1` s tím `OrderDate` bude i nadále `PurchaseOrderV2` fungovat pro a nová obchodní logika, která potřebuje vlastnost, bude zapsána v souvislosti s `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="9cbc8-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9cbc8-242">Viz také:</span><span class="sxs-lookup"><span data-stu-id="9cbc8-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="9cbc8-243">Ekvivalence kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="9cbc8-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="9cbc8-244">Zpětná volání serializace tolerantní k verzím</span><span class="sxs-lookup"><span data-stu-id="9cbc8-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
