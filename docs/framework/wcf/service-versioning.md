---
title: Verze služby
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: 6b72558be4a367505ff18f10406785bc21fddd2c
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/28/2019
ms.locfileid: "64606006"
---
# <a name="service-versioning"></a><span data-ttu-id="22242-102">Verze služby</span><span class="sxs-lookup"><span data-stu-id="22242-102">Service Versioning</span></span>
<span data-ttu-id="22242-103">Po počátečním nasazení a potenciálně několikrát během jejich životního cyklu služeb (a koncové body, které, která zpřístupňují) potřebovat změnit pro celou řadu důvodů, jako je například změna obchodních potřeb, požadavků informačních technologií, nebo jiné řešení problémy.</span><span class="sxs-lookup"><span data-stu-id="22242-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="22242-104">Každá změna zavádí novou verzi služby.</span><span class="sxs-lookup"><span data-stu-id="22242-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="22242-105">Toto téma vysvětluje, jak vzít v úvahu správy verzí Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="22242-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="22242-106">Čtyři kategorie změny služby</span><span class="sxs-lookup"><span data-stu-id="22242-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="22242-107">Změny služeb, které může být vyžadováno, je možné rozdělit do čtyř kategorií:</span><span class="sxs-lookup"><span data-stu-id="22242-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="22242-108">Změny smlouvy: Například operace, které mohou být přidány nebo datový prvek ve zprávě mohou přidat nebo změnit.</span><span class="sxs-lookup"><span data-stu-id="22242-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="22242-109">Vyřešení změn: Například služba přesune do jiného umístění, kde mají nové adresy koncových bodů.</span><span class="sxs-lookup"><span data-stu-id="22242-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="22242-110">Vazba změny: Třeba změny zabezpečení mechanismus nebo změnit její nastavení.</span><span class="sxs-lookup"><span data-stu-id="22242-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="22242-111">Provádění změn: Například interní metoda implementaci změny.</span><span class="sxs-lookup"><span data-stu-id="22242-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="22242-112">Některé z těchto změn se používá označení "slov" a jiné jsou "Pevná".</span><span class="sxs-lookup"><span data-stu-id="22242-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="22242-113">Změna je *pevná* Pokud jsou v nové verzi úspěšně zpracovala všechny zprávy, které by byly zpracovány úspěšně v předchozí verzi.</span><span class="sxs-lookup"><span data-stu-id="22242-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="22242-114">Je každá změna, která splňuje toto kritérium *zásadní* změnit.</span><span class="sxs-lookup"><span data-stu-id="22242-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="22242-115">Orientaci na služby a správy verzí</span><span class="sxs-lookup"><span data-stu-id="22242-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="22242-116">Jedním z principů orientaci na služby je, že jsou služby a klienti autonomní (nebo nezávislé).</span><span class="sxs-lookup"><span data-stu-id="22242-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="22242-117">Mimo jiné to znamená, že vývojáři služeb nelze předpokládat, že ovládací prvek nebo dokonce vědět o všech klientech služby.</span><span class="sxs-lookup"><span data-stu-id="22242-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="22242-118">Tím se eliminuje možnost znovu sestavovat a nasazovat všichni klienti, když service změny verze.</span><span class="sxs-lookup"><span data-stu-id="22242-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="22242-119">Toto téma předpokládá služba používá tato zásada a proto musí být změněné nebo "verze" bez ohledu na jeho klienty.</span><span class="sxs-lookup"><span data-stu-id="22242-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="22242-120">V případech, kdy k zásadní změně neočekávaný a nejde se vyhnout může aplikace rozhodnout Ignorovat tento princip a vyžaduje, aby se klienti znovu sestavit a znovu nasadit novou verzi služby.</span><span class="sxs-lookup"><span data-stu-id="22242-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="22242-121">Správa verzí kontraktů</span><span class="sxs-lookup"><span data-stu-id="22242-121">Contract Versioning</span></span>  
 <span data-ttu-id="22242-122">Kontrakty používaný klientem nemusí být stejný jako kontrakt používá služba; potřebují pouze aby byly kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="22242-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="22242-123">Pro servisní smlouvy kompatibilita znamená, že nové operace vystavené služby je možné přidat, ale stávající operace nelze odebrat nebo změnit sémanticky.</span><span class="sxs-lookup"><span data-stu-id="22242-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="22242-124">Pro datové kontrakty kompatibilita znamená, že nový typ schématu, které je možné přidat definice, ale existující definice typů schématu nelze změnit selhání způsoby.</span><span class="sxs-lookup"><span data-stu-id="22242-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="22242-125">Rozbíjející změny mohou zahrnovat datové členy odstranění nebo změna datového typu konstrukce.</span><span class="sxs-lookup"><span data-stu-id="22242-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="22242-126">Tato funkce umožňuje službě některé šířky při změně verze smlouvy bez narušení klientů.</span><span class="sxs-lookup"><span data-stu-id="22242-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="22242-127">Pevná a blokuje změny, které lze provést k WCF data a služby v následujících dvou částech.</span><span class="sxs-lookup"><span data-stu-id="22242-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="22242-128">Správa verzí kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="22242-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="22242-129">Tato část se zabývá Správa verzí dat při použití <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.DataContractAttribute> třídy.</span><span class="sxs-lookup"><span data-stu-id="22242-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="22242-130">Striktní správy verzí</span><span class="sxs-lookup"><span data-stu-id="22242-130">Strict Versioning</span></span>  
 <span data-ttu-id="22242-131">V mnoha situacích při změně verze představuje problém, vývojářské služby nemá kontrolu nad klienty a proto nelze vytvářet předpoklady o tom, jak bude reagovat na změny ve zprávě, XML nebo schéma.</span><span class="sxs-lookup"><span data-stu-id="22242-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="22242-132">V těchto případech je nutné zaručit, že nové zprávy budou ověřovat proti staré schématu dvou důvodů:</span><span class="sxs-lookup"><span data-stu-id="22242-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="22242-133">Staré klienty byly vyvinuty s předpokladem, že nedojde ke změně schématu.</span><span class="sxs-lookup"><span data-stu-id="22242-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="22242-134">Nemusí se jim podařit zpracovávat zprávy, které nikdy byly navrženy pro.</span><span class="sxs-lookup"><span data-stu-id="22242-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="22242-135">Staré klienti mohou provádět ověřování skutečné schématu pro staré schématu před i pokusem o zpracování zpráv.</span><span class="sxs-lookup"><span data-stu-id="22242-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="22242-136">V takových scénářích doporučuje považovat za stávající smlouvy dat neměnné a vytvořit nové jedinečné XML kvalifikované názvy.</span><span class="sxs-lookup"><span data-stu-id="22242-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="22242-137">Vývojářem služeb by pak přidejte nové metody do existující kontrakt služby nebo vytvořit nové kontrakt služby s metodami, které používají nové smlouvy data.</span><span class="sxs-lookup"><span data-stu-id="22242-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="22242-138">Často se bude v případě, kterou je potřeba napsat spustí nějakou obchodní logiku, která se má spustit ve všech verzích kontraktu dat a business specifické pro verzi kódu pro jednotlivé verze kontraktu dat pro vývojáře služby.</span><span class="sxs-lookup"><span data-stu-id="22242-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="22242-139">Dodatku na konci tohoto tématu vysvětluje, jak lze pomocí rozhraní splnění tohoto požadavku.</span><span class="sxs-lookup"><span data-stu-id="22242-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="22242-140">Lax správy verzí</span><span class="sxs-lookup"><span data-stu-id="22242-140">Lax Versioning</span></span>  
 <span data-ttu-id="22242-141">V mnoha jiných scénářích může být vývojářem služeb za předpokladu, že přidání nového člena volitelné kontraktu dat nebudou porušovat existující klienty.</span><span class="sxs-lookup"><span data-stu-id="22242-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="22242-142">To vyžaduje, aby služba pro vývojáře prozkoumat, jestli nejsou existující klienti provádí ověřování schématu a ignorují Neznámý datové členy.</span><span class="sxs-lookup"><span data-stu-id="22242-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="22242-143">V těchto scénářích je možné využít výhod funkcí kontraktu dat pro přidání nové členy pevné způsobem.</span><span class="sxs-lookup"><span data-stu-id="22242-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="22242-144">Vývojářské služby můžete provést tento předpoklad bez obav, pokud funkce kontraktu dat pro správu verzí, již byly použity pro první verzi této služby.</span><span class="sxs-lookup"><span data-stu-id="22242-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="22242-145">WCF, webových služeb ASP.NET a mnoho dalších webových služeb podpory zásobníky *lax správy verzí*: to znamená, že nevyvolají výjimky pro nové členy Neznámý datový v přijatá data.</span><span class="sxs-lookup"><span data-stu-id="22242-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="22242-146">Je snadné se omylem domnívat, že přidáte nového člena nebudou porušovat existující klienty.</span><span class="sxs-lookup"><span data-stu-id="22242-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="22242-147">Pokud si nejste jistí, že všichni klienti zvládne lax správy verzí, doporučuje se postupujte podle pokynů striktní správy verzí a zpracovávat data smlouvy jako neměnné.</span><span class="sxs-lookup"><span data-stu-id="22242-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="22242-148">Podrobné pokyny pro lax a striktní Správa verzí kontraktů dat, naleznete v tématu [osvědčených postupů: Správa verzí kontraktů dat](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="22242-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="22242-149">Rozlišování mezi typy rozhraní .NET a kontrakt dat</span><span class="sxs-lookup"><span data-stu-id="22242-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="22242-150">.NET třídy nebo struktury je možné promítnout jako smlouvy dat použitím <xref:System.Runtime.Serialization.DataContractAttribute> atribut třídy.</span><span class="sxs-lookup"><span data-stu-id="22242-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="22242-151">Typ formátu .NET a jeho projekce kontraktu dat jsou dvě různé důležité.</span><span class="sxs-lookup"><span data-stu-id="22242-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="22242-152">Je možné mít více typů .NET s stejný kontrakt projekce data.</span><span class="sxs-lookup"><span data-stu-id="22242-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="22242-153">Tento rozdíl je zvláště užitečná v umožňuje změnit typ formátu .NET při zachování kontraktu předpokládané dat, a tím zachování kompatibility se stávající klienty i v tom smyslu striktní slova.</span><span class="sxs-lookup"><span data-stu-id="22242-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="22242-154">Existují dvě věci, které byste měli dělat vždy zachovat tento rozdíl mezi .NET typu a data smlouvy:</span><span class="sxs-lookup"><span data-stu-id="22242-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="22242-155">Zadejte <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> a <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="22242-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="22242-156">By měl vždycky zadat název a obor názvů váš kontraktu dat. aby typ formátu .NET název a obor názvů z vystaven kontrakt.</span><span class="sxs-lookup"><span data-stu-id="22242-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="22242-157">Tímto způsobem, pokud se později rozhodnete změnit obor názvů .NET nebo zadejte název, kontrakt dat zůstává stejná.</span><span class="sxs-lookup"><span data-stu-id="22242-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="22242-158">Zadejte <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="22242-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="22242-159">By měl vždy zadejte název vaší datové členy zabránit vystaven kontrakt jména člena rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="22242-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="22242-160">Tímto způsobem, pokud se později rozhodnete, chcete-li změnit .NET název členu, váš kontraktu dat zůstává stejná.</span><span class="sxs-lookup"><span data-stu-id="22242-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="22242-161">Změna nebo odebrání členů</span><span class="sxs-lookup"><span data-stu-id="22242-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="22242-162">Změna názvu nebo data typu člena nebo odebrání datových členů je k zásadní změně i v případě, že lax správy verzí je povolen.</span><span class="sxs-lookup"><span data-stu-id="22242-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="22242-163">Pokud je to nutné, vytvořte nové smlouvy data.</span><span class="sxs-lookup"><span data-stu-id="22242-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="22242-164">Pokud kompatibility služby je důležitý, může být vezměte v úvahu ignoruje nepoužívaná data členů ve vašem kódu a nechat na místě.</span><span class="sxs-lookup"><span data-stu-id="22242-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="22242-165">Pokud jsou rozdělení datový člen do více členů, můžete zvážit, že byste museli opustit existujícího člena v místě jako vlastnost, která můžete provést požadované rozdělení a opakované agregace pro klienty nižší úrovně (klientů, které nejsou upgradováni na nejnovější verzi).</span><span class="sxs-lookup"><span data-stu-id="22242-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="22242-166">Podobně změny název nebo obor názvů kontraktu dat jsou rozbíjející změny.</span><span class="sxs-lookup"><span data-stu-id="22242-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="22242-167">Opakované Neznámá Data</span><span class="sxs-lookup"><span data-stu-id="22242-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="22242-168">V některých případech je třeba "round-trip" Neznámý dat, který přichází od členů přidá nová verze.</span><span class="sxs-lookup"><span data-stu-id="22242-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="22242-169">Například "versionNew" služba odesílá data s některými nově přidané členy klientovi "versionOld".</span><span class="sxs-lookup"><span data-stu-id="22242-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="22242-170">Klient ignoruje nově přidaní členové při zpracování zprávy, ale opětovně odešle ke stejným datům, včetně nově přidaných členů zpět ke službě versionNew.</span><span class="sxs-lookup"><span data-stu-id="22242-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="22242-171">Typický scénář pro toto je aktualizace dat, ve kterém se data načte ze služby, změnit a vrátí.</span><span class="sxs-lookup"><span data-stu-id="22242-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="22242-172">Pokud chcete povolit verzemi pro určitý typ, musí implementovat typ <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="22242-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="22242-173">Rozhraní obsahuje jednu vlastnost <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> , která vrací <xref:System.Runtime.Serialization.ExtensionDataObject> typu.</span><span class="sxs-lookup"><span data-stu-id="22242-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="22242-174">Vlastnost se používá k ukládání dat v budoucích verzích kontraktu dat, který neznámý pro aktuální verzi.</span><span class="sxs-lookup"><span data-stu-id="22242-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="22242-175">Tato data jsou neprůhledné klientovi, ale pokud je serializována instance, obsah <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> vlastnost byl napsán s zbývající členů kontraktu dat data.</span><span class="sxs-lookup"><span data-stu-id="22242-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="22242-176">Doporučuje se, že všechny typy implementovat toto rozhraní tak, aby vyhovovaly nové a neznámé budoucích členů.</span><span class="sxs-lookup"><span data-stu-id="22242-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="22242-177">Knihovny kontraktu dat</span><span class="sxs-lookup"><span data-stu-id="22242-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="22242-178">Můžou existovat knihovny kontraktů dat kontrakt publikovaná v centrálním úložišti, kde služby a typ implementátory implementovat a vystavit kontraktů dat z tohoto úložiště.</span><span class="sxs-lookup"><span data-stu-id="22242-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="22242-179">Když publikujete kontraktu dat do úložiště, v takovém případě máte žádnou kontrolu nad tím, kdo vytváří typy, které je implementují.</span><span class="sxs-lookup"><span data-stu-id="22242-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="22242-180">Proto nemůžete upravovat kontrakt publikovaný produkt, vykreslování efektivně neměnné.</span><span class="sxs-lookup"><span data-stu-id="22242-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="22242-181">Při používání třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="22242-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="22242-182">Správa verzí stejné zásady platí i při použití <xref:System.Xml.Serialization.XmlSerializer> třídy.</span><span class="sxs-lookup"><span data-stu-id="22242-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="22242-183">Když se vyžaduje striktní správy verzí, považovat za kontraktů dat neměnné a vytvořit nové kontrakty dat s jedinečný a kvalifikované názvy pro nové verze.</span><span class="sxs-lookup"><span data-stu-id="22242-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="22242-184">Když jste si jisti, že lax správy verzí je možné, nejde přidat nové serializovatelné členy v nových verzích ale změnit nebo odebrat existující členy.</span><span class="sxs-lookup"><span data-stu-id="22242-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22242-185"><xref:System.Xml.Serialization.XmlSerializer> Používá <xref:System.Xml.Serialization.XmlAnyElementAttribute> a <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> atributy pro podporu dopad na dobu odezvy neznámá data.</span><span class="sxs-lookup"><span data-stu-id="22242-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="22242-186">Správa verzí kontraktů zpráv</span><span class="sxs-lookup"><span data-stu-id="22242-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="22242-187">Pokyny pro Správa verzí kontraktů zpráv jsou velmi podobné kontraktů dat správy verzí.</span><span class="sxs-lookup"><span data-stu-id="22242-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="22242-188">Pokud se vyžaduje striktní správy verzí, by měl nezměníte vaše zprávy, ale místo vytvoření nové zprávy kontraktu s jedinečný kvalifikovaný název.</span><span class="sxs-lookup"><span data-stu-id="22242-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="22242-189">Pokud víte, které můžete použít lax správy verzí, nejde přidat nové části textu zprávy, ale změnit nebo odebrat existující aplikace.</span><span class="sxs-lookup"><span data-stu-id="22242-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="22242-190">Tento návod se vztahuje i na úplné a zabalené kontraktů zpráv.</span><span class="sxs-lookup"><span data-stu-id="22242-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="22242-191">Záhlaví zprávy mohou být přidány vždy, i v případě, že striktní správy verzí je používána.</span><span class="sxs-lookup"><span data-stu-id="22242-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="22242-192">Příznak MustUnderstand může mít vliv na správu verzí.</span><span class="sxs-lookup"><span data-stu-id="22242-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="22242-193">Model správy verzí pro záhlaví ve službě WCF je obecně platí, jak je popsáno ve specifikaci protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="22242-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="22242-194">Správa verzí kontraktů služby</span><span class="sxs-lookup"><span data-stu-id="22242-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="22242-195">Podobně jako správa verzí kontraktů dat, Správa verzí kontraktů služby také zahrnuje přidání, změně a odebrání operace.</span><span class="sxs-lookup"><span data-stu-id="22242-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="22242-196">Zadáním názvu, Namespace a akce</span><span class="sxs-lookup"><span data-stu-id="22242-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="22242-197">Název kontraktu služby ve výchozím nastavení, je název rozhraní.</span><span class="sxs-lookup"><span data-stu-id="22242-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="22242-198">Výchozí obor názvů je "http://tempuri.org", a akce pro každou operaci "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="22242-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="22242-199">Doporučuje se explicitně zadat název a obor názvů kontraktu služby a akce pro každou operaci, abyste se vyhnuli použití "http://tempuri.org" a zabránit názvy rozhraní a metoda vystaven v kontraktu služby.</span><span class="sxs-lookup"><span data-stu-id="22242-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="22242-200">Přidání operace a parametry</span><span class="sxs-lookup"><span data-stu-id="22242-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="22242-201">Přidání operace služby, vystavený službou je méně zásadních změn, protože existující klienti nemusí mít obavy o těchto nových operací.</span><span class="sxs-lookup"><span data-stu-id="22242-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22242-202">Přidání operací do duplexního zpětného volání kontraktu je zásadní změnu.</span><span class="sxs-lookup"><span data-stu-id="22242-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="22242-203">Změna parametrů operace nebo návratové typy</span><span class="sxs-lookup"><span data-stu-id="22242-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="22242-204">Změna parametrů nebo návratových typů obecně je rozbíjející změny, pokud nový typ implementuje stejné kontraktu dat pomocí starého typu implementovat.</span><span class="sxs-lookup"><span data-stu-id="22242-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="22242-205">Chcete-li tuto změnu, přidat nové operace pro kontrakt služby nebo definujte nové kontrakt služby.</span><span class="sxs-lookup"><span data-stu-id="22242-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="22242-206">Odebírá se operace</span><span class="sxs-lookup"><span data-stu-id="22242-206">Removing Operations</span></span>  
 <span data-ttu-id="22242-207">Odebrání operace je také k narušující změně.</span><span class="sxs-lookup"><span data-stu-id="22242-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="22242-208">Chcete-li tuto změnu, definujte nové kontrakt služby a zveřejníte ho na nový koncový bod.</span><span class="sxs-lookup"><span data-stu-id="22242-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="22242-209">Kontrakty selhání</span><span class="sxs-lookup"><span data-stu-id="22242-209">Fault Contracts</span></span>  
 <span data-ttu-id="22242-210"><xref:System.ServiceModel.FaultContractAttribute> Atribut umožňuje vývojář smlouvy k zadání informací o chybách, které mohou být vráceny z operace kontraktu.</span><span class="sxs-lookup"><span data-stu-id="22242-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="22242-211">Seznam chyb je popsáno v kontraktu služby se nepovažuje za vyčerpávající.</span><span class="sxs-lookup"><span data-stu-id="22242-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="22242-212">V každém okamžiku může vrátit operace chyb, které nebyly popsány v její smlouvy.</span><span class="sxs-lookup"><span data-stu-id="22242-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="22242-213">Proto změna sady chyb je popsáno v kontraktu není považováno za rozbíjející.</span><span class="sxs-lookup"><span data-stu-id="22242-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="22242-214">Například přidáním nové chyby pomocí kontraktu <xref:System.ServiceModel.FaultContractAttribute> nebo odebrání existující chybu ze smlouvy.</span><span class="sxs-lookup"><span data-stu-id="22242-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="22242-215">Knihovny kontrakt služby</span><span class="sxs-lookup"><span data-stu-id="22242-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="22242-216">Organizace mohou mít knihovny kontraktů kde kontrakt publikovaná v centrálním úložišti a implementátoři služby implementace kontraktů z tohoto úložiště.</span><span class="sxs-lookup"><span data-stu-id="22242-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="22242-217">Když publikujete kontraktu služby do úložiště v tomto případě máte žádnou kontrolu nad tím, kdo vytváří služby, které je implementují.</span><span class="sxs-lookup"><span data-stu-id="22242-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="22242-218">Proto nelze upravit smlouvu, jakmile ji publikujete, vykreslování efektivně neměnné.</span><span class="sxs-lookup"><span data-stu-id="22242-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="22242-219">WCF podporuje Dědičnost kontraktů, který slouží k vytvoření nové smlouvy, která rozšiřuje stávající smlouvy.</span><span class="sxs-lookup"><span data-stu-id="22242-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="22242-220">Pokud chcete používat tuto funkci, definujte nové rozhraní kontraktu služby, která dědí ze staré rozhraní kontraktu služby a pak přidejte metody na nové rozhraní.</span><span class="sxs-lookup"><span data-stu-id="22242-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="22242-221">Potom změňte službu, která implementuje starého kontraktu implementovat nové smlouvy a změnit definice koncového bodu "versionOld" používat nové smlouvy.</span><span class="sxs-lookup"><span data-stu-id="22242-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="22242-222">Klientům "versionOld" budou se nadále zobrazovat jako zpřístupňuje "versionOld" smlouvy; koncový bod klientům "versionNew" zobrazí se na koncový bod ke zveřejnění kontraktu "versionNew".</span><span class="sxs-lookup"><span data-stu-id="22242-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="22242-223">Adresy a vazby správy verzí</span><span class="sxs-lookup"><span data-stu-id="22242-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="22242-224">Změny adresa koncového bodu a vazby jsou rozbíjející změny, pokud klienti nejsou schopné dynamicky zjišťování na novou adresu koncového bodu nebo vazby.</span><span class="sxs-lookup"><span data-stu-id="22242-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="22242-225">Jeden mechanismus pro implementaci této funkce je pomocí registru univerzální popis zjišťování a integrace (UDDI) a vzor vyvolání UDDI, kde klient se pokouší navázat komunikaci s koncovým bodem a, nebude úspěšná, dotazuje dobře známé UDDI registr pro aktuální koncový bod metadat.</span><span class="sxs-lookup"><span data-stu-id="22242-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="22242-226">Klient potom použije adresu a vazbu z těchto metadat ke komunikaci s koncovým bodem.</span><span class="sxs-lookup"><span data-stu-id="22242-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="22242-227">Pokud je tato komunikace úspěšná, klient ukládá do mezipaměti informace o adrese a vazbu pro budoucí použití.</span><span class="sxs-lookup"><span data-stu-id="22242-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="22242-228">Služba Směrování a správa verzí</span><span class="sxs-lookup"><span data-stu-id="22242-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="22242-229">Pokud změny do služby jsou zásadní změny a musí mít minimálně dva různé verze služby spuštěné současně můžete směrovací služba WCF pro směrování zpráv do instance příslušnou službu.</span><span class="sxs-lookup"><span data-stu-id="22242-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="22242-230">Směrovací služba WCF používá směrování na základě obsahu, jinými slovy, používá informace v něm k určení, kam chcete směrovat zprávy.</span><span class="sxs-lookup"><span data-stu-id="22242-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="22242-231">Další informace o směrování služby WCF najdete v tématu [směrovací služba](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="22242-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="22242-232">Příklad použití směrovací služba WCF pro správu verzí služby najdete v části [How To: Správa verzí služby](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="22242-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="22242-233">Příloha</span><span class="sxs-lookup"><span data-stu-id="22242-233">Appendix</span></span>  
 <span data-ttu-id="22242-234">Pokyny správy verzí kontraktu obecná data v případě potřeby striktní správy verzí je považovat za neměnné kontraktech dat a vytvářet nové, když nejsou nutné nějaké změny.</span><span class="sxs-lookup"><span data-stu-id="22242-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="22242-235">Nová třída je potřeba vytvořit pro každou novou kontraktu dat, takže mechanismus je potřeba, abyste nemuseli vzít existující kód, který byl napsán z hlediska stará data smlouvy třídy a přepsat jde o novou třídu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="22242-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="22242-236">Jedním z takových mechanismů je pomocí rozhraní definují členy jednotlivých kontraktu dat a okamžitý zápis vnitřní implementace kódu z hlediska rozhraní spíše než třídy kontraktu dat, které implementují rozhraní.</span><span class="sxs-lookup"><span data-stu-id="22242-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="22242-237">Následující kód pro verzi 1 služby ukazuje `IPurchaseOrderV1` rozhraní a `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="22242-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="22242-238">Během operace kontraktu služby by byla zapsána z hlediska `PurchaseOrderV1`, skutečné obchodní logika by být z hlediska `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="22242-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="22242-239">Potom ve verzi 2, bude nový `IPurchaseOrderV2` rozhraní a nový `PurchaseOrderV2` třídy, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="22242-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="22242-240">Kontrakt služby bude aktualizováno, aby zahrnovalo nové operace, které jsou napsány z hlediska `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="22242-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="22242-241">Stávající obchodní logiky zapisovat z hlediska `IPurchaseOrderV1` by pokračovat v práci pro `PurchaseOrderV2` a nové obchodní logiky, které potřebuje `OrderDate` vlastnost by byla zapsána z hlediska `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="22242-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="22242-242">Viz také:</span><span class="sxs-lookup"><span data-stu-id="22242-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="22242-243">Ekvivalence kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="22242-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="22242-244">Zpětná volání serializace tolerantní k verzím</span><span class="sxs-lookup"><span data-stu-id="22242-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
