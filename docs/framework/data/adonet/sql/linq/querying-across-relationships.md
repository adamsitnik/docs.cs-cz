---
title: Dotazování napříč relacemi
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 297878d0-685b-4c01-b2e0-9d731b7322bc
ms.openlocfilehash: be0aea66f0923b8b353f42cecc9360731efc7bb9
ms.sourcegitcommit: d2e1dfa7ef2d4e9ffae3d431cf6a4ffd9c8d378f
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/07/2019
ms.locfileid: "70792844"
---
# <a name="querying-across-relationships"></a><span data-ttu-id="d882f-102">Dotazování napříč relacemi</span><span class="sxs-lookup"><span data-stu-id="d882f-102">Querying Across Relationships</span></span>
<span data-ttu-id="d882f-103">Odkazy na jiné objekty nebo kolekce jiných objektů v definicích vaší třídy přímo odpovídají vztahům cizího klíče v databázi.</span><span class="sxs-lookup"><span data-stu-id="d882f-103">References to other objects or collections of other objects in your class definitions directly correspond to foreign-key relationships in the database.</span></span> <span data-ttu-id="d882f-104">Tyto relace můžete použít při dotazování pomocí zápisu teček pro přístup k vlastnostem vztahu a přechodu z jednoho objektu na jiný.</span><span class="sxs-lookup"><span data-stu-id="d882f-104">You can use these relationships when you query by using dot notation to access the relationship properties and navigate from one object to another.</span></span> <span data-ttu-id="d882f-105">Tyto operace přístupu se převádějí na složitější spojení nebo korelační poddotazy v ekvivalentním SQL.</span><span class="sxs-lookup"><span data-stu-id="d882f-105">These access operations translate to more complex joins or correlated subqueries in the equivalent SQL.</span></span>  
  
 <span data-ttu-id="d882f-106">Například následující dotaz přechází z objednávek na zákazníky jako způsob, jak omezit výsledky jenom na objednávky pro zákazníky, kteří se nacházejí v Londýně.</span><span class="sxs-lookup"><span data-stu-id="d882f-106">For example, the following query navigates from orders to customers as a way to restrict the results to only those orders for customers located in London.</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#3](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#3)]
 [!code-vb[DLinqQueryConcepts#3](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#3)]  
  
 <span data-ttu-id="d882f-107">Pokud vlastnosti vztahu neexistují, musíte je napsat ručně jako *spojení*, stejně jako v dotazu SQL, jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="d882f-107">If relationship properties did not exist you would have to write them manually as *joins*, just as you would do in a SQL query, as in the following code:</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#4](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#4)]
 [!code-vb[DLinqQueryConcepts#4](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#4)]  
  
 <span data-ttu-id="d882f-108">Můžete použít vlastnost *Relationship* k definování tohoto konkrétního vztahu v jednom okamžiku.</span><span class="sxs-lookup"><span data-stu-id="d882f-108">You can use the *relationship* property to define this particular relationship one time.</span></span> <span data-ttu-id="d882f-109">Pak můžete použít pohodlnější syntaxi teček.</span><span class="sxs-lookup"><span data-stu-id="d882f-109">You can then use the more convenient dot syntax.</span></span> <span data-ttu-id="d882f-110">Ale vlastnosti vztahu existují důležitější, protože objektové modely specifické pro doménu jsou obvykle definovány jako hierarchie nebo grafy.</span><span class="sxs-lookup"><span data-stu-id="d882f-110">But relationship properties exist more importantly because domain-specific object models are typically defined as hierarchies or graphs.</span></span> <span data-ttu-id="d882f-111">Objekty, které program mají, mají odkazy na jiné objekty.</span><span class="sxs-lookup"><span data-stu-id="d882f-111">The objects that you program against have references to other objects.</span></span> <span data-ttu-id="d882f-112">Je to jenom šťastný výskyt, který vztahy mezi objekty a objekty odpovídají vztahům na základě vztahu cizího klíče v databázích.</span><span class="sxs-lookup"><span data-stu-id="d882f-112">It is only a happy coincidence that object-to-object relationships correspond to foreign-key-styled relationships in databases.</span></span> <span data-ttu-id="d882f-113">Přístup k vlastnostem pak poskytuje pohodlný způsob, jak psát spojení.</span><span class="sxs-lookup"><span data-stu-id="d882f-113">Property access then provides a convenient way to write joins.</span></span>  
  
 <span data-ttu-id="d882f-114">Z toho vyplývá, že vlastnosti vztahu jsou důležitější než na straně výsledků dotazu, než jako součást dotazu samotného.</span><span class="sxs-lookup"><span data-stu-id="d882f-114">With regard to this, relationship properties are more important on the results side of a query than as part of the query itself.</span></span> <span data-ttu-id="d882f-115">Poté, co dotaz načte data o konkrétním zákazníkovi, definice třídy označuje, že zákazníci mají objednávky.</span><span class="sxs-lookup"><span data-stu-id="d882f-115">After the query has retrieved data about a particular customer, the class definition indicates that customers have orders.</span></span> <span data-ttu-id="d882f-116">Jinými slovy, očekáváte `Orders` , že vlastnost určitého zákazníka bude kolekce, která je vyplněna všemi objednávkami tohoto zákazníka.</span><span class="sxs-lookup"><span data-stu-id="d882f-116">In other words, you expect the `Orders` property of a particular customer to be a collection that is populated with all the orders from that customer.</span></span> <span data-ttu-id="d882f-117">To je ve skutečnosti kontrakt, který jste deklarovali definováním tříd tímto způsobem.</span><span class="sxs-lookup"><span data-stu-id="d882f-117">That is in fact the contract you declared by defining the classes in this manner.</span></span> <span data-ttu-id="d882f-118">Očekává se, že se zobrazí objednávky i v případě, že dotaz nepožadoval objednávky.</span><span class="sxs-lookup"><span data-stu-id="d882f-118">You expect to see the orders there even if the query did not request orders.</span></span> <span data-ttu-id="d882f-119">Očekáváte, že objektový model udržuje iluzi, že se jedná o příponu v paměti databáze se souvisejícími objekty hned dostupnými.</span><span class="sxs-lookup"><span data-stu-id="d882f-119">You expect your object model to maintain an illusion that it is an in-memory extension of the database with related objects immediately available.</span></span>  
  
 <span data-ttu-id="d882f-120">Teď, když máte relace, můžete napsat dotazy odkazem na vlastnosti vztahu definované ve vašich třídách.</span><span class="sxs-lookup"><span data-stu-id="d882f-120">Now that you have relationships, you can write queries by referring to the relationship properties defined in your classes.</span></span> <span data-ttu-id="d882f-121">Tyto odkazy na relace odpovídají vztahům cizího klíče v databázi.</span><span class="sxs-lookup"><span data-stu-id="d882f-121">These relationship references correspond to foreign-key relationships in the database.</span></span> <span data-ttu-id="d882f-122">Operace, které tyto relace používají, se převádějí do složitějších spojení v ekvivalentním kódu SQL.</span><span class="sxs-lookup"><span data-stu-id="d882f-122">Operations that use these relationships translate to more complex joins in the equivalent SQL.</span></span> <span data-ttu-id="d882f-123">Pokud jste definovali relaci (pomocí <xref:System.Data.Linq.Mapping.AssociationAttribute> atributu), nemusíte kód explicitní [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]spojení nakódovat.</span><span class="sxs-lookup"><span data-stu-id="d882f-123">As long as you have defined a relationship (using the <xref:System.Data.Linq.Mapping.AssociationAttribute> attribute), you do not have to code an explicit join in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>  
  
 <span data-ttu-id="d882f-124">Pro usnadnění zachování tohoto iluze [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] implementuje techniku s názvem *odložené načítání*.</span><span class="sxs-lookup"><span data-stu-id="d882f-124">To help maintain this illusion, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] implements a technique called *deferred loading*.</span></span> <span data-ttu-id="d882f-125">Další informace najdete v tématu [odložené porovnání a okamžité načítání](deferred-versus-immediate-loading.md).</span><span class="sxs-lookup"><span data-stu-id="d882f-125">For more information, see [Deferred versus Immediate Loading](deferred-versus-immediate-loading.md).</span></span>  
  
 <span data-ttu-id="d882f-126">Vezměte v úvahu následující dotaz SQL pro projektování seznamu `CustomerID` - `OrderID` párů:</span><span class="sxs-lookup"><span data-stu-id="d882f-126">Consider the following SQL query to project a list of `CustomerID`-`OrderID` pairs:</span></span>  
  
```  
SELECT t0.CustomerID, t1.OrderID  
FROM   Customers AS t0 INNER JOIN  
          Orders AS t1 ON t0.CustomerID = t1.CustomerID  
WHERE  (t0.City = @p0)  
```  
  
 <span data-ttu-id="d882f-127">Chcete-li získat stejné výsledky pomocí [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], použijte `Customer` odkaz na `Orders` vlastnost již existující ve třídě.</span><span class="sxs-lookup"><span data-stu-id="d882f-127">To obtain the same results by using [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], you use the `Orders` property reference already existing in the `Customer` class.</span></span> <span data-ttu-id="d882f-128">Odkaz poskytuje potřebné informace pro spuštění dotazu - a `OrderID` `CustomerID` projekt párů, jak je uvedeno v následujícím kódu: `Orders`</span><span class="sxs-lookup"><span data-stu-id="d882f-128">The `Orders` reference provides the necessary information to execute the query and project the `CustomerID`-`OrderID` pairs, as in the following code:</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#5](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#5)]
 [!code-vb[DLinqQueryConcepts#5](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#5)]  
  
 <span data-ttu-id="d882f-129">Můžete také provést zpětný chod.</span><span class="sxs-lookup"><span data-stu-id="d882f-129">You can also do the reverse.</span></span> <span data-ttu-id="d882f-130">To znamená, že se můžete `Orders` dotazovat a `Customer` použít svůj odkaz na relaci pro přístup k `Customer` informacím o přidruženém objektu.</span><span class="sxs-lookup"><span data-stu-id="d882f-130">That is, you can query `Orders` and use its `Customer` relationship reference to access information about the associated `Customer` object.</span></span> <span data-ttu-id="d882f-131">Následující kód projektuje `CustomerID` stejné - `OrderID` páry jako `Orders` předtím, `Customers`ale tentokrát se dotazuje namísto.</span><span class="sxs-lookup"><span data-stu-id="d882f-131">The following code projects the same `CustomerID`-`OrderID` pairs as before, but this time by querying `Orders` instead of `Customers`.</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#6](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#6)]
 [!code-vb[DLinqQueryConcepts#6](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#6)]  
  
## <a name="see-also"></a><span data-ttu-id="d882f-132">Viz také:</span><span class="sxs-lookup"><span data-stu-id="d882f-132">See also</span></span>

- [<span data-ttu-id="d882f-133">Koncepty dotazů</span><span class="sxs-lookup"><span data-stu-id="d882f-133">Query Concepts</span></span>](query-concepts.md)
