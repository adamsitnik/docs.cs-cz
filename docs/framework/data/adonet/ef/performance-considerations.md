---
title: Důležité informace o výkonu (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: ec7f3571f60dc7f10816cad90911e50d271a9ce1
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/09/2019
ms.locfileid: "59324042"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="98a6a-102">Důležité informace o výkonu (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="98a6a-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="98a6a-103">Toto téma popisuje charakteristiky výkonu technologie ADO.NET Entity Framework a obsahuje některé aspekty, které pomůžou zlepšit výkon aplikací využívajících rozhraní Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="98a6a-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="98a6a-104">Fáze spuštění dotazu</span><span class="sxs-lookup"><span data-stu-id="98a6a-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="98a6a-105">Chcete-li lépe pochopit výkon dotazů v Entity Framework, je dobré znát operace, které nastaly, když dotaz provede pro koncepční model a vrátí dat jako objektů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="98a6a-106">Následující tabulka popisuje tato posloupnost operací.</span><span class="sxs-lookup"><span data-stu-id="98a6a-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="98a6a-107">Operace</span><span class="sxs-lookup"><span data-stu-id="98a6a-107">Operation</span></span>|<span data-ttu-id="98a6a-108">Relativní náklady</span><span class="sxs-lookup"><span data-stu-id="98a6a-108">Relative Cost</span></span>|<span data-ttu-id="98a6a-109">Frekvence</span><span class="sxs-lookup"><span data-stu-id="98a6a-109">Frequency</span></span>|<span data-ttu-id="98a6a-110">Komentáře</span><span class="sxs-lookup"><span data-stu-id="98a6a-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="98a6a-111">Načítání metadat</span><span class="sxs-lookup"><span data-stu-id="98a6a-111">Loading metadata</span></span>|<span data-ttu-id="98a6a-112">Střední</span><span class="sxs-lookup"><span data-stu-id="98a6a-112">Moderate</span></span>|<span data-ttu-id="98a6a-113">Jednou v každé doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="98a6a-113">Once in each application domain.</span></span>|<span data-ttu-id="98a6a-114">Metadata modelu a mapování používaná rozhraním Entity Framework je načten do <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="98a6a-115">Tato metadata je globálně do mezipaměti a je k dispozici pro ostatní instance <xref:System.Data.Objects.ObjectContext> ve stejné doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="98a6a-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="98a6a-116">Otevření připojení k databázi</span><span class="sxs-lookup"><span data-stu-id="98a6a-116">Opening the database connection</span></span>|<span data-ttu-id="98a6a-117">Střední<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="98a6a-118">Podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="98a6a-118">As needed.</span></span>|<span data-ttu-id="98a6a-119">Protože otevřeného připojení k databázi spotřebovává cenné prostředků [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] otevře a uzavře připojení k databázi podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="98a6a-119">Because an open connection to the database consumes a valuable resource, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] opens and closes the database connection only as needed.</span></span> <span data-ttu-id="98a6a-120">Můžete také explicitně otevřít připojení.</span><span class="sxs-lookup"><span data-stu-id="98a6a-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="98a6a-121">Další informace najdete v tématu [Správa připojení a transakce](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="98a6a-122">Generování zobrazení</span><span class="sxs-lookup"><span data-stu-id="98a6a-122">Generating views</span></span>|<span data-ttu-id="98a6a-123">Vysoká</span><span class="sxs-lookup"><span data-stu-id="98a6a-123">High</span></span>|<span data-ttu-id="98a6a-124">Jednou v každé doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="98a6a-124">Once in each application domain.</span></span> <span data-ttu-id="98a6a-125">(Může být předem generovaného.)</span><span class="sxs-lookup"><span data-stu-id="98a6a-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="98a6a-126">Entity Framework mohli spustit dotaz pro koncepční model nebo uložit změny do zdroje dat, musíte vygenerovat sadu zobrazení místní dotazu pro přístup k databázi.</span><span class="sxs-lookup"><span data-stu-id="98a6a-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="98a6a-127">Z důvodu vysoké náklady na generování těchto zobrazení můžete předem vygenerovat zobrazení a přidat je do projektu v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="98a6a-128">Další informace najdete v tématu [jak: Předběžně generovat zobrazení pro zlepšení výkonu dotazů](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="98a6a-129">Příprava dotazu</span><span class="sxs-lookup"><span data-stu-id="98a6a-129">Preparing the query</span></span>|<span data-ttu-id="98a6a-130">Střední<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="98a6a-131">Jednou pro každý dotaz jedinečný.</span><span class="sxs-lookup"><span data-stu-id="98a6a-131">Once for each unique query.</span></span>|<span data-ttu-id="98a6a-132">Zahrnují náklady na vytvoření příkazu dotazu, generovat stromu příkazů na základě modelu a mapování metadata a definovat tvar vrácená data.</span><span class="sxs-lookup"><span data-stu-id="98a6a-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="98a6a-133">Protože teď Entity SQL dotazu příkazů a dotazů LINQ jsou ukládány do mezipaměti, vyšší počet spuštění stejného dotazu trvat kratší dobu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="98a6a-134">Stále vám pomůže kompilované dotazy LINQ v pozdější spuštění tyto náklady snížit a kompilované dotazy může být efektivnější než LINQ dotazy, které se automaticky uloží do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="98a6a-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="98a6a-135">Další informace najdete v tématu [zkompilován dotazy (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="98a6a-135">For more information, see [Compiled Queries  (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="98a6a-136">Obecné informace o provádění dotazů LINQ, naleznete v tématu [technologii LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="98a6a-136">For general information about LINQ query execution, see [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="98a6a-137">**Poznámka:**  Dotazech LINQ to Entities, které se vztahují `Enumerable.Contains` nejsou v operátoru na kolekce v paměti automaticky uložené v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="98a6a-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="98a6a-138">Také Parametrizace kolekce v paměti v kompilované dotazy LINQ není povoleno.</span><span class="sxs-lookup"><span data-stu-id="98a6a-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="98a6a-139">Provádění dotazu</span><span class="sxs-lookup"><span data-stu-id="98a6a-139">Executing the query</span></span>|<span data-ttu-id="98a6a-140">Nízká<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-140">Low<sup>2</sup></span></span>|<span data-ttu-id="98a6a-141">Jednou pro každý dotaz.</span><span class="sxs-lookup"><span data-stu-id="98a6a-141">Once for each query.</span></span>|<span data-ttu-id="98a6a-142">Náklady na provedení příkazu na zdroji dat pomocí zprostředkovatele dat ADO.NET.</span><span class="sxs-lookup"><span data-stu-id="98a6a-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="98a6a-143">Protože většina zdrojů dat do mezipaměti plány dotazů, novější spuštění stejný dotaz může trvat i méně času.</span><span class="sxs-lookup"><span data-stu-id="98a6a-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="98a6a-144">Načítání a ověření typů</span><span class="sxs-lookup"><span data-stu-id="98a6a-144">Loading and validating types</span></span>|<span data-ttu-id="98a6a-145">Nízká<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-145">Low<sup>3</sup></span></span>|<span data-ttu-id="98a6a-146">Jednou pro každé <xref:System.Data.Objects.ObjectContext> instance.</span><span class="sxs-lookup"><span data-stu-id="98a6a-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="98a6a-147">Typy jsou načten a ověřen typy, které definuje konceptuálního modelu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="98a6a-148">Sledování</span><span class="sxs-lookup"><span data-stu-id="98a6a-148">Tracking</span></span>|<span data-ttu-id="98a6a-149">Nízká<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-149">Low<sup>3</sup></span></span>|<span data-ttu-id="98a6a-150">Jednou pro každý objekt, který dotaz vrátí.</span><span class="sxs-lookup"><span data-stu-id="98a6a-150">Once for each object that a query returns.</span></span> <sup><span data-ttu-id="98a6a-151">4</span><span class="sxs-lookup"><span data-stu-id="98a6a-151">4</span></span></sup>|<span data-ttu-id="98a6a-152">Pokud se používá dotaz <xref:System.Data.Objects.MergeOption.NoTracking> možnost sloučení, tuto fázi nemá vliv na výkon.</span><span class="sxs-lookup"><span data-stu-id="98a6a-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="98a6a-153">Pokud dotaz používá <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, nebo <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge – možnost, výsledky jsou sledovány v dotazu <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="98a6a-154"><xref:System.Data.EntityKey> Je vygenerována pro každý dotaz vrací a je sledované objekt použitý k vytvoření <xref:System.Data.Objects.ObjectStateEntry> v <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="98a6a-155">Existující <xref:System.Data.Objects.ObjectStateEntry> nebyla nalezena <xref:System.Data.EntityKey>, stávající objekt je vrácen.</span><span class="sxs-lookup"><span data-stu-id="98a6a-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="98a6a-156">Pokud <xref:System.Data.Objects.MergeOption.PreserveChanges>, nebo <xref:System.Data.Objects.MergeOption.OverwriteChanges> možnost se používá, je objekt aktualizován před vrácením.</span><span class="sxs-lookup"><span data-stu-id="98a6a-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="98a6a-157">Další informace najdete v tématu [rozlišení Identity, správy stavu a Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="98a6a-158">Materializaci objekty</span><span class="sxs-lookup"><span data-stu-id="98a6a-158">Materializing the objects</span></span>|<span data-ttu-id="98a6a-159">Střední<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="98a6a-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="98a6a-160">Jednou pro každý objekt, který dotaz vrátí.</span><span class="sxs-lookup"><span data-stu-id="98a6a-160">Once for each object that a query returns.</span></span> <sup><span data-ttu-id="98a6a-161">4</span><span class="sxs-lookup"><span data-stu-id="98a6a-161">4</span></span></sup>|<span data-ttu-id="98a6a-162">Proces čtení vráceného <xref:System.Data.Common.DbDataReader> objektu a vytváření objektů a nastavení hodnoty vlastností, které jsou založené na hodnotách v každé instanci <xref:System.Data.Common.DbDataRecord> třídy.</span><span class="sxs-lookup"><span data-stu-id="98a6a-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="98a6a-163">Pokud objekt již existuje v <xref:System.Data.Objects.ObjectContext> a použije dotaz <xref:System.Data.Objects.MergeOption.AppendOnly> nebo <xref:System.Data.Objects.MergeOption.PreserveChanges> možností sloučení, tuto fázi nemá vliv na výkon.</span><span class="sxs-lookup"><span data-stu-id="98a6a-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="98a6a-164">Další informace najdete v tématu [rozlišení Identity, správy stavu a Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="98a6a-165"><sup>1</sup> při Zprostředkovatel zdroje dat implementuje sdružování připojení, náklady na otevření připojení se distribuuje do fondu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="98a6a-166">Zprostředkovatel rozhraní .NET pro SQL Server podporuje sdružování připojení.</span><span class="sxs-lookup"><span data-stu-id="98a6a-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="98a6a-167"><sup>2</sup> náklady se zvyšuje s dotazu zvýšení složitosti.</span><span class="sxs-lookup"><span data-stu-id="98a6a-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="98a6a-168"><sup>3</sup> zvýšení celkové náklady na úměrný počtu objektů vrácených dotazem.</span><span class="sxs-lookup"><span data-stu-id="98a6a-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="98a6a-169"><sup>4</sup> tato režie se nevyžaduje, pro zprostředkovatel EntityClient dotazuje, protože zprostředkovatel EntityClient dotazuje vrátit <xref:System.Data.EntityClient.EntityDataReader> místo objekty.</span><span class="sxs-lookup"><span data-stu-id="98a6a-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="98a6a-170">Další informace najdete v tématu [zprostředkovatel EntityClient pro Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="98a6a-170">For more information, see [EntityClient Provider for the Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="98a6a-171">Další informace</span><span class="sxs-lookup"><span data-stu-id="98a6a-171">Additional Considerations</span></span>  
 <span data-ttu-id="98a6a-172">Tady jsou další důležité informace, které mohou ovlivňovat výkon aplikace Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="98a6a-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="98a6a-173">Provádění dotazů</span><span class="sxs-lookup"><span data-stu-id="98a6a-173">Query Execution</span></span>  
 <span data-ttu-id="98a6a-174">Vzhledem k tomu, že dotazy může být náročné, zvažte, na kterém bodě v kódu a na jaké počítače je dotaz proveden.</span><span class="sxs-lookup"><span data-stu-id="98a6a-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="98a6a-175">Odložené versus okamžité spuštění</span><span class="sxs-lookup"><span data-stu-id="98a6a-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="98a6a-176">Při vytváření <xref:System.Data.Objects.ObjectQuery%601> nebo dotazu LINQ dotaz nemusí být provedena okamžitě.</span><span class="sxs-lookup"><span data-stu-id="98a6a-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="98a6a-177">Provádění dotazu je odloženo, dokud jsou potřebné výsledky, jako například během `foreach` (C#) nebo `For Each` výčtu (Visual Basic) nebo když je přiřazený k vyplnění <xref:System.Collections.Generic.List%601> kolekce.</span><span class="sxs-lookup"><span data-stu-id="98a6a-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="98a6a-178">Provádění dotazů začne okamžitě při volání <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> metodu <xref:System.Data.Objects.ObjectQuery%601> nebo při volání metody LINQ vrátí dotazů s jediným prvkem, jako například <xref:System.Linq.Enumerable.First%2A> nebo <xref:System.Linq.Enumerable.Any%2A>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="98a6a-179">Další informace najdete v tématu [dotazy objektu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) a [provádění dotazů (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="98a6a-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="98a6a-180">Na straně klienta provádění dotazů LINQ</span><span class="sxs-lookup"><span data-stu-id="98a6a-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="98a6a-181">I když dojde k provádění dotazů LINQ v počítači, který je hostitelem zdroje dat, může být vyhodnocen některé části dotazu LINQ na klientském počítači.</span><span class="sxs-lookup"><span data-stu-id="98a6a-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="98a6a-182">Další informace najdete v části spuštění Store v [provádění dotazů (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="98a6a-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="98a6a-183">Dotaz a mapování složitost</span><span class="sxs-lookup"><span data-stu-id="98a6a-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="98a6a-184">Složitost jednotlivých dotazů a mapování v modelu entity budou mít významný vliv na výkon dotazů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="98a6a-185">Mapování složitost</span><span class="sxs-lookup"><span data-stu-id="98a6a-185">Mapping complexity</span></span>  
 <span data-ttu-id="98a6a-186">Modely, které jsou složitější než jednoduché mapování 1: 1 mezi entitami v konceptuálním modelu a tabulky v modelu úložiště vygenerovat složitější příkazy než modely, které mají mapování 1: 1.</span><span class="sxs-lookup"><span data-stu-id="98a6a-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="98a6a-187">Složitosti dotazu</span><span class="sxs-lookup"><span data-stu-id="98a6a-187">Query complexity</span></span>  
 <span data-ttu-id="98a6a-188">Dotazy, které vyžadují velký počet spojení v příkazech, které jsou spouštěny na zdroji dat nebo, které vracejí velké množství dat může ovlivnit výkon následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="98a6a-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
-   <span data-ttu-id="98a6a-189">Dotazy na konceptuální model, které vypadá to, že jednoduchá může vést k provádění na zdroji dat složitější dotazy.</span><span class="sxs-lookup"><span data-stu-id="98a6a-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="98a6a-190">Tato situace může nastat, protože rozhraní Entity Framework překládá na ekvivalentní dotazu na zdroji dat dotazu na koncepční model.</span><span class="sxs-lookup"><span data-stu-id="98a6a-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="98a6a-191">Při nastavení jedné entity v konceptuálním modelu mapuje na více než jedné tabulky ve zdroji dat nebo když relace mezi entitami se mapuje na tabulku spojení, příkaz dotazu pro dotaz na zdroj dat může vyžadovat jeden nebo více spojení.</span><span class="sxs-lookup"><span data-stu-id="98a6a-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="98a6a-192">Použití <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metodu <xref:System.Data.Objects.ObjectQuery%601> nebo <xref:System.Data.EntityClient.EntityCommand> třídy zobrazit příkazy, které jsou prováděny nad zdrojem dat pro daný dotaz.</span><span class="sxs-lookup"><span data-stu-id="98a6a-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="98a6a-193">Další informace najdete v tématu [jak: Zobrazit příkazy Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
-   <span data-ttu-id="98a6a-194">Vnořené dotazy na Entity SQL na serveru může vytvořit spojení a může vrátit velký počet řádků.</span><span class="sxs-lookup"><span data-stu-id="98a6a-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="98a6a-195">Následuje příklad vnořeného dotazu v klauzuli projekce:</span><span class="sxs-lookup"><span data-stu-id="98a6a-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="98a6a-196">Kromě toho takové dotazy způsobit kanálu dotazu ke generování jednoho dotazu s duplicitních objektů ve vnořené dotazy.</span><span class="sxs-lookup"><span data-stu-id="98a6a-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="98a6a-197">Z toho důvodu může jeden sloupec duplicitní více než jednou.</span><span class="sxs-lookup"><span data-stu-id="98a6a-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="98a6a-198">V některých databázích, včetně SQL serveru to může způsobit tabulku v databázi TempDB rozrůstá velmi velké, což může snížit výkon serveru.</span><span class="sxs-lookup"><span data-stu-id="98a6a-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="98a6a-199">Při spouštění dotazů vnořené měli věnovat pozornost.</span><span class="sxs-lookup"><span data-stu-id="98a6a-199">Care should be taken when you execute nested queries.</span></span>  
  
-   <span data-ttu-id="98a6a-200">Všechny dotazy, které vracejí velké množství dat může způsobit snížení výkonu, pokud klient provádí operace, které spotřebovávají prostředky způsobem, který je přímo úměrná velikosti sady výsledků dotazu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="98a6a-201">V takovém případě zvažte omezení množství dat vrácených dotazem.</span><span class="sxs-lookup"><span data-stu-id="98a6a-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="98a6a-202">Další informace najdete v tématu [jak: Výsledky stránky pomocí dotazu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="98a6a-203">Všechny příkazy automaticky vygenerovaným rozhraním Entity Framework, může být složitější než podobné příkazy napsané explicitně vývojář databáze.</span><span class="sxs-lookup"><span data-stu-id="98a6a-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="98a6a-204">Pokud je nutné explicitní kontrolu nad na příkazy provedené na zdroj dat, vezměte v úvahu definování mapování funkce vracející tabulku nebo uložené procedury.</span><span class="sxs-lookup"><span data-stu-id="98a6a-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="98a6a-205">Relace</span><span class="sxs-lookup"><span data-stu-id="98a6a-205">Relationships</span></span>  
 <span data-ttu-id="98a6a-206">Pro optimální výkon dotazů je nutné definovat vztahy mezi entitami jako přidružení v modelu entity i logické vztahy ve zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="98a6a-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="98a6a-207">Dotaz cesty</span><span class="sxs-lookup"><span data-stu-id="98a6a-207">Query Paths</span></span>  
 <span data-ttu-id="98a6a-208">Ve výchozím nastavení se při spouštění <xref:System.Data.Objects.ObjectQuery%601>, související objekty nebudou zobrazeny (i když jsou objekty, které představují samotné vztahy).</span><span class="sxs-lookup"><span data-stu-id="98a6a-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="98a6a-209">Můžete načíst související objekty v jednom ze tří způsobů:</span><span class="sxs-lookup"><span data-stu-id="98a6a-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="98a6a-210">Nastavte cestu dotazu před <xref:System.Data.Objects.ObjectQuery%601> provádí.</span><span class="sxs-lookup"><span data-stu-id="98a6a-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="98a6a-211">Volání `Load` metodu na navigační vlastnost, která zveřejňuje objektu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="98a6a-212">Nastavte <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> možnost <xref:System.Data.Objects.ObjectContext> k `true`.</span><span class="sxs-lookup"><span data-stu-id="98a6a-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="98a6a-213">Všimněte si, že to se provádí automaticky při generování kódu na objektové vrstvě pomocí [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="98a6a-214">Další informace najdete v části [vygeneruje kód přehled](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="98a6a-215">Pokud zvažujete možnost, mějte na paměti, že je kompromis mezi počet požadavků na databázi a množství dat vrácené v jediném dotazu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="98a6a-216">Další informace najdete v tématu [načítání související objekty](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="98a6a-217">Pomocí dotazu cest</span><span class="sxs-lookup"><span data-stu-id="98a6a-217">Using query paths</span></span>  
 <span data-ttu-id="98a6a-218">Cesty k dotazu definovat grafu objektů, které dotaz vrátí.</span><span class="sxs-lookup"><span data-stu-id="98a6a-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="98a6a-219">Při definování cestu dotazu pouze jeden požadavek na databázi je nutné pro navrácení všechny objekty, které definuje cestu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="98a6a-220">Pomocí dotazu cesty může způsobit komplexní příkazy prováděný zdroji dat z objektu zdánlivě jednoduché dotazů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="98a6a-221">K tomu dochází, protože jeden nebo více spojení jsou nutné k vrácení souvisejících objektů v jediném dotazu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="98a6a-222">Tato složitost je větší v dotazech pro model komplexní entity, jako je například entitu s dědičnosti nebo cestu, která obsahuje vztahy many-to-many.</span><span class="sxs-lookup"><span data-stu-id="98a6a-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98a6a-223">Použití <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metoda zobrazíte příkaz, který vygeneruje <xref:System.Data.Objects.ObjectQuery%601>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="98a6a-224">Další informace najdete v tématu [jak: Zobrazit příkazy Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="98a6a-225">Pokud cesta dotaz obsahuje příliš mnoho související objekty nebo objekty obsahují příliš mnoho řádků dat, může být zdroje dat nelze dokončit dotaz.</span><span class="sxs-lookup"><span data-stu-id="98a6a-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="98a6a-226">K tomu dochází, pokud dotaz vyžaduje zprostředkující dočasné úložiště, které překračují možnosti datového zdroje.</span><span class="sxs-lookup"><span data-stu-id="98a6a-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="98a6a-227">Pokud k tomu dojde, můžete snížit složitost dotazu na datový zdroj explicitně načítání souvisejících objektů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="98a6a-228">Načítají se explicitně související objekty</span><span class="sxs-lookup"><span data-stu-id="98a6a-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="98a6a-229">Můžete explicitně načíst související objekty voláním `Load` metodu na navigační vlastnost, která vrátí <xref:System.Data.Objects.DataClasses.EntityCollection%601> nebo <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span><span class="sxs-lookup"><span data-stu-id="98a6a-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="98a6a-230">Explicitně načítání objektů vyžaduje k databázi pokaždé, když `Load` je volána.</span><span class="sxs-lookup"><span data-stu-id="98a6a-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98a6a-231">Při volání `Load` při opakování ve smyčce přes kolekce vrácených objektů, jako je například při použití `foreach` – příkaz (`For Each` v jazyce Visual Basic), zprostředkovatele specifická pro zdroj dat musí podporovat více sad výsledků aktivní v rámci jednoho připojení.</span><span class="sxs-lookup"><span data-stu-id="98a6a-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="98a6a-232">Pro databáze SQL serveru, musíte zadat hodnotu `MultipleActiveResultSets = true` v připojovacím řetězci zprostředkovatele.</span><span class="sxs-lookup"><span data-stu-id="98a6a-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="98a6a-233">Můžete také použít <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metoda při žádné <xref:System.Data.Objects.DataClasses.EntityCollection%601> nebo <xref:System.Data.Objects.DataClasses.EntityReference%601> vlastnosti u entit.</span><span class="sxs-lookup"><span data-stu-id="98a6a-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="98a6a-234">To je užitečné, pokud používáte entity POCO.</span><span class="sxs-lookup"><span data-stu-id="98a6a-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="98a6a-235">I když explicitně načítání související objekty se sníží počet klauzulí JOIN a snížit objem redundantních dat `Load` vyžaduje opakované připojení k databázi, která může být nákladné při načítání explicitně velký počet objektů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="98a6a-236">Ukládají se změny</span><span class="sxs-lookup"><span data-stu-id="98a6a-236">Saving Changes</span></span>  
 <span data-ttu-id="98a6a-237">Při volání <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metoda <xref:System.Data.Objects.ObjectContext>, samostatné vytvoření, aktualizace nebo odstranění příkaz je vygenerována pro každý objekt přidaný, aktualizovaných nebo odstraněných v kontextu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="98a6a-238">Tyto příkazy jsou provedeny ve zdroji dat v rámci jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="98a6a-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="98a6a-239">Jak pomocí dotazů, výkon vytvořit, aktualizovat a odstraňovat operace závisí na složitosti mapování v konceptuálním modelu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="98a6a-240">Distribuované transakce</span><span class="sxs-lookup"><span data-stu-id="98a6a-240">Distributed Transactions</span></span>  
 <span data-ttu-id="98a6a-241">Operace v explicitní transakci, které vyžadují prostředky, které se spravují přes koordinátor distribuovaných transakcí (DTC) bude mnohem dražší než podobné operace, která nevyžaduje službu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="98a6a-242">Povýšení na DTC proběhnou v následujících situacích:</span><span class="sxs-lookup"><span data-stu-id="98a6a-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
-   <span data-ttu-id="98a6a-243">Explicitní transakce pomocí operace databáze systému SQL Server 2000 nebo jiný zdroj dat, která vždy zvýšit úroveň explicitní transakce na DTC.</span><span class="sxs-lookup"><span data-stu-id="98a6a-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
-   <span data-ttu-id="98a6a-244">Explicitní transakce pomocí operace SQL Server 2005 při připojení je spravován [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span><span class="sxs-lookup"><span data-stu-id="98a6a-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="98a6a-245">K tomu dochází, SQL Server 2005 povýší na DTC pokaždé, když je připojení zavřít a znovu otevřít v rámci jedné transakce, což je výchozí chování [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span><span class="sxs-lookup"><span data-stu-id="98a6a-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="98a6a-246">Tato propagační akce DTC nedojde při použití systému SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="98a6a-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="98a6a-247">Abyste předešli této propagační akce, při použití systému SQL Server 2005, musíte explicitně otevřít a ukončete připojení v rámci transakce.</span><span class="sxs-lookup"><span data-stu-id="98a6a-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="98a6a-248">Další informace najdete v tématu [Správa připojení a transakce](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="98a6a-249">Explicitní transakce se používá při spuštění jedné nebo více operací uvnitř <xref:System.Transactions> transakce.</span><span class="sxs-lookup"><span data-stu-id="98a6a-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="98a6a-250">Další informace najdete v tématu [Správa připojení a transakce](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="98a6a-251">Strategie pro zlepšení výkonu</span><span class="sxs-lookup"><span data-stu-id="98a6a-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="98a6a-252">Pomocí následujících strategií, lze vylepšit výkon dotazů v Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="98a6a-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="98a6a-253">Předem vygenerovat zobrazení</span><span class="sxs-lookup"><span data-stu-id="98a6a-253">Pre-generate views</span></span>  
 <span data-ttu-id="98a6a-254">Generování zobrazení založené na modelu entity je poprvé, že se aplikace spustí dotaz výrazně šetřit náklady.</span><span class="sxs-lookup"><span data-stu-id="98a6a-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="98a6a-255">Pomocí nástroje EdmGen.exe předem vygenerovat zobrazení jako soubor kódu jazyka Visual Basic nebo C#, který se dají přidat do projektu během návrhu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="98a6a-256">Toolkit transformace šablony textu můžete také použít ke generování předem kompilovaných zobrazení.</span><span class="sxs-lookup"><span data-stu-id="98a6a-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="98a6a-257">Předem vygenerovaných zobrazení se ověřují v době běhu k zajištění, že jsou v souladu s aktuální verzí zadané entity model.</span><span class="sxs-lookup"><span data-stu-id="98a6a-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="98a6a-258">Další informace najdete v tématu [jak: Předběžně generovat zobrazení pro zlepšení výkonu dotazů](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="98a6a-259">Při práci s velmi velkých modelů, platí následující úvahy:</span><span class="sxs-lookup"><span data-stu-id="98a6a-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="98a6a-260">Formát metadat .NET omezuje počet znaků řetězce uživatele v dané binárního souboru ke 16 777 215 (0xFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="98a6a-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="98a6a-261">Pokud jsou generování zobrazení modelu velmi velké a zobrazit soubor dosáhne tohoto limitu, zobrazí se "již není logické místo vytvoření dalších uživatelských řetězců."</span><span class="sxs-lookup"><span data-stu-id="98a6a-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="98a6a-262">Chyba kompilace.</span><span class="sxs-lookup"><span data-stu-id="98a6a-262">compile error.</span></span> <span data-ttu-id="98a6a-263">Tato velikost omezení se vztahuje na všechny spravované binární soubory.</span><span class="sxs-lookup"><span data-stu-id="98a6a-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="98a6a-264">Další informace najdete v článku [blogu](https://go.microsoft.com/fwlink/?LinkId=201476) , který ukazuje, jak se vyhnout chybu při práci s velkých a složitých modelů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-264">For more information see the [blog](https://go.microsoft.com/fwlink/?LinkId=201476) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="98a6a-265">Zvažte použití možností sloučení NoTracking pro dotazy</span><span class="sxs-lookup"><span data-stu-id="98a6a-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="98a6a-266">Je nutné ke sledování objektů vrácených v kontextu objektu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="98a6a-267">Detekce změn k objektům a zajištění, že více požadavků pro stejnou logická entita vrátí stejnou instanci objektu vyžaduje, aby objekty připojit k <xref:System.Data.Objects.ObjectContext> instance.</span><span class="sxs-lookup"><span data-stu-id="98a6a-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="98a6a-268">Pokud nemáte v plánu provést aktualizace nebo odstranění objektů a nevyžadují, aby Správa identit, zvažte použití <xref:System.Data.Objects.MergeOption.NoTracking> možnosti sloučení, při spouštění dotazů.</span><span class="sxs-lookup"><span data-stu-id="98a6a-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="98a6a-269">Vraťte správný objem dat</span><span class="sxs-lookup"><span data-stu-id="98a6a-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="98a6a-270">V některých scénářích zadání cesty dotazu pomocí <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda je mnohem rychlejší, protože vyžaduje menší počet zpátečních cest k databázi.</span><span class="sxs-lookup"><span data-stu-id="98a6a-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="98a6a-271">Ale v jiných scénářích další zpátečních cest k databázi se načíst související objekty může být rychlejší protože jednodušší dotazy s menším počtem spojení za následek méně redundance dat.</span><span class="sxs-lookup"><span data-stu-id="98a6a-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="98a6a-272">Z tohoto důvodu doporučujeme vám, že provedete test výkonu různých způsobů, jak načíst související objekty.</span><span class="sxs-lookup"><span data-stu-id="98a6a-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="98a6a-273">Další informace najdete v tématu [načítání související objekty](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="98a6a-274">Aby se zabránilo vrátil příliš mnoho dat v jediném dotazu, vezměte v úvahu stránkování výsledků dotazu do více zvládnutelných skupin.</span><span class="sxs-lookup"><span data-stu-id="98a6a-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="98a6a-275">Další informace najdete v tématu [jak: Výsledky stránky pomocí dotazu](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="98a6a-276">Omezit rozsah objektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="98a6a-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="98a6a-277">Ve většině případů byste měli vytvořit <xref:System.Data.Objects.ObjectContext> instance v rámci `using` – příkaz (`Using…End Using` v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="98a6a-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="98a6a-278">To může zvýšit výkon tím, že zajišťuje, že prostředky přidružené ke kontextu objektu jsou automaticky odstraněny při kód ukončení bloku příkazu.</span><span class="sxs-lookup"><span data-stu-id="98a6a-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="98a6a-279">Ale při vázání ovládacích prvků u objektů spravovaných kontextu objektu <xref:System.Data.Objects.ObjectContext> instance by se měl zachovat jako vazby je potřeba a odstraněny ručně.</span><span class="sxs-lookup"><span data-stu-id="98a6a-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="98a6a-280">Další informace najdete v tématu [Správa připojení a transakce](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="98a6a-281">Zvažte otevření připojení k databázi ručně</span><span class="sxs-lookup"><span data-stu-id="98a6a-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="98a6a-282">Když vaše aplikace spustí řadu dotazy objektu nebo často volá <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> zachovat vytvářet, aktualizovat a odstraňovat operace pro zdroj dat [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] musí neustále otevření a zavření připojení ke zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="98a6a-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="98a6a-283">V těchto situacích zvažte ručně otevření připojení při spuštění těchto operací a zavření nebo rušení připojení po dokončení operace.</span><span class="sxs-lookup"><span data-stu-id="98a6a-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="98a6a-284">Další informace najdete v tématu [Správa připojení a transakce](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="98a6a-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="98a6a-285">Údaje o výkonu</span><span class="sxs-lookup"><span data-stu-id="98a6a-285">Performance Data</span></span>  
 <span data-ttu-id="98a6a-286">Některá data o výkonu pro Entity Framework je publikováno v následujících příspěvcích [blog týmu ADO.NET](https://go.microsoft.com/fwlink/?LinkId=91905):</span><span class="sxs-lookup"><span data-stu-id="98a6a-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://go.microsoft.com/fwlink/?LinkId=91905):</span></span>  
  
-   [<span data-ttu-id="98a6a-287">Zkoumání výkonu technologie ADO.NET Entity Framework – část 1</span><span class="sxs-lookup"><span data-stu-id="98a6a-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://go.microsoft.com/fwlink/?LinkId=123907)  
  
-   [<span data-ttu-id="98a6a-288">Zkoumání výkonu technologie ADO.NET Entity Framework – část 2</span><span class="sxs-lookup"><span data-stu-id="98a6a-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://go.microsoft.com/fwlink/?LinkId=123909)  
  
-   [<span data-ttu-id="98a6a-289">ADO.NET Entity Framework Performance Comparison</span><span class="sxs-lookup"><span data-stu-id="98a6a-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://go.microsoft.com/fwlink/?LinkID=123913)  
  
## <a name="see-also"></a><span data-ttu-id="98a6a-290">Viz také:</span><span class="sxs-lookup"><span data-stu-id="98a6a-290">See also</span></span>

- [<span data-ttu-id="98a6a-291">Důležité informace o vývoji a nasazení</span><span class="sxs-lookup"><span data-stu-id="98a6a-291">Development and Deployment Considerations</span></span>](../../../../../docs/framework/data/adonet/ef/development-and-deployment-considerations.md)
