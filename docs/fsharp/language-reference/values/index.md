---
title: Hodnoty
description: Přečtěte si, F# jak hodnoty v jsou množství, které má konkrétní typ.
ms.date: 05/16/2016
ms.openlocfilehash: ed7a5b069a5a47aacf0cce4cfa754ded46f6e84a
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630795"
---
# <a name="values"></a><span data-ttu-id="41ff6-103">Hodnoty</span><span class="sxs-lookup"><span data-stu-id="41ff6-103">Values</span></span>

<span data-ttu-id="41ff6-104">Hodnoty v F# jsou množství, které má konkrétní typ; hodnoty mohou být integrální nebo plovoucí desetinné čárky, znaky nebo text, seznamy, sekvence, pole, řazené kolekce členů, rozlišené sjednocení, záznamy, typy tříd nebo hodnoty funkcí.</span><span class="sxs-lookup"><span data-stu-id="41ff6-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="41ff6-105">Vytvoření vazby hodnoty</span><span class="sxs-lookup"><span data-stu-id="41ff6-105">Binding a Value</span></span>

<span data-ttu-id="41ff6-106">Pojem *vazba* znamená přidružení názvu k definici.</span><span class="sxs-lookup"><span data-stu-id="41ff6-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="41ff6-107">`let` Klíčové slovo váže hodnotu, jak je uvedeno v následujících příkladech:</span><span class="sxs-lookup"><span data-stu-id="41ff6-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="41ff6-108">Typ hodnoty je odvozen z definice.</span><span class="sxs-lookup"><span data-stu-id="41ff6-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="41ff6-109">Pro primitivní typ, jako je číslo integrálního nebo plovoucího bodu, je typ určen z typu literálu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="41ff6-110">Proto kompilátor odvodí v předchozím příkladu `b` typ, který má být `unsigned int`, zatímco kompilátor `a` odvodí typ, který má být `int`.</span><span class="sxs-lookup"><span data-stu-id="41ff6-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="41ff6-111">Typ hodnoty funkce je určen z návratové hodnoty v těle funkce.</span><span class="sxs-lookup"><span data-stu-id="41ff6-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="41ff6-112">Další informace o typech hodnot funkcí naleznete v tématu [Functions](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="41ff6-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="41ff6-113">Další informace o typech literálů naleznete v [](../literals.md)tématu Literal.</span><span class="sxs-lookup"><span data-stu-id="41ff6-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="41ff6-114">Kompilátor ve výchozím nastavení nevydá diagnostiku o nepoužitých vazbách.</span><span class="sxs-lookup"><span data-stu-id="41ff6-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="41ff6-115">Chcete-li přijímat tyto zprávy, povolte upozornění 1182 v souboru projektu nebo při vyvolání kompilátoru (viz část `--warnon` [Možnosti kompilátoru](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="41ff6-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="41ff6-116">Proč neměnné?</span><span class="sxs-lookup"><span data-stu-id="41ff6-116">Why Immutable?</span></span>

<span data-ttu-id="41ff6-117">Neměnné hodnoty jsou hodnoty, které nelze změnit v průběhu provádění programu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="41ff6-118">Pokud používáte k jazykům C++, jako je Visual Basic, nebo C#, může to být překvapivé, které F# místo proměnných, které mohou být přiřazeny k novým hodnotám během provádění programu, přemístit Primacy na neměnné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="41ff6-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="41ff6-119">Neměnné data jsou důležitým prvkem funkčního programování.</span><span class="sxs-lookup"><span data-stu-id="41ff6-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="41ff6-120">V prostředí s více vlákny jsou sdílené proměnlivé proměnné, které lze změnit pomocí mnoha různých vláken, obtížné spravovat.</span><span class="sxs-lookup"><span data-stu-id="41ff6-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="41ff6-121">I s proměnlivými proměnnými může někdy být obtížné určit, zda může být proměnná změněna při předání jiné funkci.</span><span class="sxs-lookup"><span data-stu-id="41ff6-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="41ff6-122">V čistě funkčních jazycích nejsou k dispozici žádné proměnné a funkce se chovají výhradně jako matematické funkce.</span><span class="sxs-lookup"><span data-stu-id="41ff6-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="41ff6-123">Kde kód v procedurálním jazyce používá přiřazení proměnné pro změnu hodnoty, ekvivalentní kód v funkčním jazyku má neproměnlivou hodnotu, která je vstupem, neproměnlivá funkce a různé neměnné hodnoty jako výstup.</span><span class="sxs-lookup"><span data-stu-id="41ff6-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="41ff6-124">Tato Matematická striktní umožňuje důkladnější rozhodnutí o chování programu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="41ff6-125">Tímto užším důvodem je to, že kompilátorům umožňuje, aby se kód kontrolovalější a optimalizoval efektivněji a usnadnil vývojářům pochopení a psaní správného kódu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="41ff6-126">Funkční kód je proto pravděpodobně snazší ladit než běžný procedurální kód.</span><span class="sxs-lookup"><span data-stu-id="41ff6-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="41ff6-127">F#není čistě funkční jazyk, ale plně podporuje funkční programování.</span><span class="sxs-lookup"><span data-stu-id="41ff6-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="41ff6-128">Použití neměnných hodnot je dobrý postup, protože to umožňuje vašemu kódu těžit z důležitého aspektu funkčního programování.</span><span class="sxs-lookup"><span data-stu-id="41ff6-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="41ff6-129">Proměnlivé proměnné</span><span class="sxs-lookup"><span data-stu-id="41ff6-129">Mutable Variables</span></span>

<span data-ttu-id="41ff6-130">Klíčové slovo `mutable` lze použít k určení proměnné, kterou lze změnit.</span><span class="sxs-lookup"><span data-stu-id="41ff6-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="41ff6-131">Proměnlivé proměnné F# v by měly být obecně omezené oboru, buď jako pole typu, nebo jako místní hodnota.</span><span class="sxs-lookup"><span data-stu-id="41ff6-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="41ff6-132">Proměnlivé proměnné s omezeným rozsahem mají snadnější kontrolu a jsou méně pravděpodobně upravovány nesprávnými způsoby.</span><span class="sxs-lookup"><span data-stu-id="41ff6-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="41ff6-133">Můžete přiřadit počáteční hodnotu proměnlivé proměnné pomocí `let` klíčového slova stejným způsobem, jako byste definovali hodnotu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="41ff6-134">Rozdíl je však, že můžete následně přiřadit nové hodnoty proměnlivým proměnným pomocí `<-` operátoru, jak je uvedeno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="41ff6-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="41ff6-135">Hodnoty s `mutable` označením mohou být automaticky `'a ref` povýšeny na hodnotu, pokud je zachycena uzávěrkou, včetně formulářů, `seq` které vytvářejí uzávěry, jako jsou například tvůrci.</span><span class="sxs-lookup"><span data-stu-id="41ff6-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="41ff6-136">Pokud chcete být upozorněni v případě, že k tomu dojde, povolte upozornění 3180 v souboru projektu nebo při vyvolání kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="41ff6-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="41ff6-137">Související témata</span><span class="sxs-lookup"><span data-stu-id="41ff6-137">Related Topics</span></span>

|<span data-ttu-id="41ff6-138">Název</span><span class="sxs-lookup"><span data-stu-id="41ff6-138">Title</span></span>|<span data-ttu-id="41ff6-139">Popis</span><span class="sxs-lookup"><span data-stu-id="41ff6-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="41ff6-140">Vazby let</span><span class="sxs-lookup"><span data-stu-id="41ff6-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="41ff6-141">Poskytuje informace o použití `let` klíčového slova k vytvoření vazby názvů k hodnotám a funkcím.</span><span class="sxs-lookup"><span data-stu-id="41ff6-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="41ff6-142">Funkce</span><span class="sxs-lookup"><span data-stu-id="41ff6-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="41ff6-143">Poskytuje přehled funkcí v F#nástroji.</span><span class="sxs-lookup"><span data-stu-id="41ff6-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="41ff6-144">Viz také:</span><span class="sxs-lookup"><span data-stu-id="41ff6-144">See also</span></span>

- [<span data-ttu-id="41ff6-145">Hodnoty Null</span><span class="sxs-lookup"><span data-stu-id="41ff6-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="41ff6-146">Referenční dokumentace jazyka F#</span><span class="sxs-lookup"><span data-stu-id="41ff6-146">F# Language Reference</span></span>](../index.md)
