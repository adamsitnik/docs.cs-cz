---
title: Třídy
description: Zjistěte, F# jak třídy jsou typy reprezentující objekty, které mohou mít vlastnosti, metody a události.
ms.date: 05/16/2016
ms.openlocfilehash: 5c012d028bc1f89e3e9f5969b3461faab9aad3a0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630443"
---
# <a name="classes"></a><span data-ttu-id="1e87f-103">Třídy</span><span class="sxs-lookup"><span data-stu-id="1e87f-103">Classes</span></span>

<span data-ttu-id="1e87f-104">*Třídy* jsou typy, které představují objekty, které mohou mít vlastnosti, metody a události.</span><span class="sxs-lookup"><span data-stu-id="1e87f-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="1e87f-105">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="1e87f-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="1e87f-106">Poznámky</span><span class="sxs-lookup"><span data-stu-id="1e87f-106">Remarks</span></span>

<span data-ttu-id="1e87f-107">Třídy reprezentují základní popis typů objektů .NET. Třída je primární typ koncept, který podporuje objektově orientované programování v F#.</span><span class="sxs-lookup"><span data-stu-id="1e87f-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="1e87f-108">V předchozí syntaxi `type-name` je platný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="1e87f-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="1e87f-109">`type-params` Popisuje volitelné parametry obecného typu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="1e87f-110">Skládá se z názvů parametrů typu a omezení uzavřených do lomených závorek `>`(`<` a).</span><span class="sxs-lookup"><span data-stu-id="1e87f-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="1e87f-111">Další informace najdete v tématu [Obecné typy](./generics/index.md) a [omezení](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="1e87f-112">`parameter-list` Popisuje parametry konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="1e87f-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="1e87f-113">První modifikátor přístupu se vztahuje k typu; druhý se vztahuje k primárnímu konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="1e87f-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="1e87f-114">V obou případech je `public`výchozí hodnota.</span><span class="sxs-lookup"><span data-stu-id="1e87f-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="1e87f-115">Základní třídu pro třídu určíte pomocí `inherit` klíčového slova.</span><span class="sxs-lookup"><span data-stu-id="1e87f-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="1e87f-116">Pro konstruktor základní třídy je nutné dodat argumenty v závorkách.</span><span class="sxs-lookup"><span data-stu-id="1e87f-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="1e87f-117">Deklarujete pole nebo hodnoty funkcí, které jsou lokální pro třídu, pomocí `let` vazeb a musíte dodržovat obecná pravidla pro `let` vazby.</span><span class="sxs-lookup"><span data-stu-id="1e87f-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="1e87f-118">`do-bindings` Oddíl obsahuje kód, který má být proveden při vytváření objektu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="1e87f-119">`member-list` Obsahuje další konstruktory, instance a deklarace statických metod, deklarace rozhraní, abstraktní vazby a deklarace vlastností a událostí.</span><span class="sxs-lookup"><span data-stu-id="1e87f-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="1e87f-120">Ty jsou popsány v tématu [members](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="1e87f-121">Rozhraní `identifier` , které je použito s klíčovým slovem volitelné `as` , poskytuje název proměnné instance nebo identifikátor autotest, který lze použít v definici typu pro odkazování na instanci typu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="1e87f-122">Další informace najdete v části hlavní identifikátory níže v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="1e87f-123">Klíčová `class` slova `end` , která označují začátek a konec definice, jsou volitelná.</span><span class="sxs-lookup"><span data-stu-id="1e87f-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="1e87f-124">Vzájemně se rekurzivní typy, které odkazují na sebe navzájem, spolu s `and` klíčovým slovem spojí stejně jako vzájemně rekurzivní funkce.</span><span class="sxs-lookup"><span data-stu-id="1e87f-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="1e87f-125">Příklad naleznete v části vzájemně rekurzivní typy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="1e87f-126">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="1e87f-126">Constructors</span></span>

<span data-ttu-id="1e87f-127">Konstruktor je kód, který vytvoří instanci typu třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="1e87f-128">Konstruktory pro třídy fungují trochu jinak F# než v jiných jazycích .NET.</span><span class="sxs-lookup"><span data-stu-id="1e87f-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="1e87f-129">Ve F# třídě je vždy primární konstruktor, jehož argumenty jsou popsány v `parameter-list` , které následují za názvem typu a jejichž `let` tělo se skládá z vazeb (a `let rec`) na začátku deklarace třídy a `do` následující vazby.</span><span class="sxs-lookup"><span data-stu-id="1e87f-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="1e87f-130">Argumenty primárního konstruktoru jsou v oboru v rámci deklarace třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="1e87f-131">Můžete přidat další konstruktory pomocí `new` klíčového slova pro přidání člena následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="1e87f-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="1e87f-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="1e87f-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="1e87f-133">Tělo nového konstruktoru musí vyvolat primární konstruktor, který je určen v horní části deklarace třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="1e87f-134">Následující příklad znázorňuje tento koncept.</span><span class="sxs-lookup"><span data-stu-id="1e87f-134">The following example illustrates this concept.</span></span> <span data-ttu-id="1e87f-135">V následujícím kódu `MyClass` má dva konstruktory, primární konstruktor, který přebírá dva argumenty a jiný konstruktor, který nepřijímá žádné argumenty.</span><span class="sxs-lookup"><span data-stu-id="1e87f-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="1e87f-136">Vazby let a dělat</span><span class="sxs-lookup"><span data-stu-id="1e87f-136">let and do Bindings</span></span>

<span data-ttu-id="1e87f-137">Vazby `let` a`do` v definici třídy tvoří tělo konstruktoru primární třídy, a proto jsou spouštěny pokaždé, když je vytvořena instance třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="1e87f-138">Pokud je `let` vazba funkce, je zkompilována do členu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="1e87f-139">Pokud je `let` vazba hodnota, která není použita v žádné funkci nebo členu, je zkompilována do proměnné, která je místní pro konstruktor.</span><span class="sxs-lookup"><span data-stu-id="1e87f-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="1e87f-140">V opačném případě je zkompilována do pole třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="1e87f-141">`do` Výrazy, které následují, jsou zkompilovány do primárního konstruktoru a spouštějí inicializační kód pro každou instanci.</span><span class="sxs-lookup"><span data-stu-id="1e87f-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="1e87f-142">Vzhledem k tomu, že všechny další konstruktory vždy volají primární `let` konstruktor, `do` vazby a vazby se vždy spouštějí bez ohledu na to, který konstruktor je volán.</span><span class="sxs-lookup"><span data-stu-id="1e87f-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="1e87f-143">Pole, která jsou vytvořena `let` pomocí vazeb, mohou být k dispozici v rámci metod a vlastností třídy. nelze je však získat z statických metod, i když statické metody přebírají proměnnou instance jako parametr.</span><span class="sxs-lookup"><span data-stu-id="1e87f-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="1e87f-144">K nim nelze přistupovat pomocí automatického identifikátoru, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="1e87f-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="1e87f-145">Osobní identifikátory</span><span class="sxs-lookup"><span data-stu-id="1e87f-145">Self Identifiers</span></span>

<span data-ttu-id="1e87f-146">*Samotný identifikátor* je název, který představuje aktuální instanci.</span><span class="sxs-lookup"><span data-stu-id="1e87f-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="1e87f-147">`this` Identifikátory sebe připomínají klíčové slovo v C# nebo C++ nebo `Me` v Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1e87f-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="1e87f-148">Vlastní identifikátor můžete definovat dvěma různými způsoby, v závislosti na tom, zda chcete, aby byl vlastní identifikátor v rozsahu pro celou definici třídy nebo pouze pro jednotlivé metody.</span><span class="sxs-lookup"><span data-stu-id="1e87f-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="1e87f-149">Chcete-li definovat identifikátor osobníku pro celou třídu, použijte `as` klíčové slovo za pravou závorku seznamu parametrů konstruktoru a zadejte název identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="1e87f-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="1e87f-150">Chcete-li definovat identifikátor sebe samo pro jednu metodu, zadejte identifikátor samotné v deklaraci členu, těsně před názvem metody a tečkou (.) jako oddělovač.</span><span class="sxs-lookup"><span data-stu-id="1e87f-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="1e87f-151">Následující příklad kódu ukazuje dva způsoby, jak vytvořit identifikátor sebe.</span><span class="sxs-lookup"><span data-stu-id="1e87f-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="1e87f-152">Na prvním řádku `as` se klíčové slovo používá k definování identifikátoru sebe.</span><span class="sxs-lookup"><span data-stu-id="1e87f-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="1e87f-153">Na pátém řádku je identifikátor `this` použit k definování identifikátoru samočinného rozsahu, jehož rozsah je omezen na metodu. `PrintMessage`</span><span class="sxs-lookup"><span data-stu-id="1e87f-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="1e87f-154">Na rozdíl od jiných jazyků .NET můžete sami pojmenovat identifikátor, který chcete, ale. Nejste omezeni na názvy `self`, `Me`například, nebo `this`.</span><span class="sxs-lookup"><span data-stu-id="1e87f-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="1e87f-155">Identifikátor autotest, který je deklarován s `as` klíčovým slovem, není inicializován `let` až po provedení vazeb.</span><span class="sxs-lookup"><span data-stu-id="1e87f-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="1e87f-156">Proto jej nelze použít ve `let` vazbách.</span><span class="sxs-lookup"><span data-stu-id="1e87f-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="1e87f-157">V `do` části Bindings (vazby) můžete použít samotný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="1e87f-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="1e87f-158">Parametry obecného typu</span><span class="sxs-lookup"><span data-stu-id="1e87f-158">Generic Type Parameters</span></span>

<span data-ttu-id="1e87f-159">Parametry obecného typu jsou zadány v lomených`<` závorkách (a `>`) ve formě jednoduché uvozovky následované identifikátorem.</span><span class="sxs-lookup"><span data-stu-id="1e87f-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="1e87f-160">Více parametrů obecného typu je odděleno čárkami.</span><span class="sxs-lookup"><span data-stu-id="1e87f-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="1e87f-161">Parametr obecného typu je v oboru v celé deklaraci.</span><span class="sxs-lookup"><span data-stu-id="1e87f-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="1e87f-162">Následující příklad kódu ukazuje, jak určit parametry obecného typu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="1e87f-163">Argumenty typu jsou odvozeny při použití typu.</span><span class="sxs-lookup"><span data-stu-id="1e87f-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="1e87f-164">V následujícím kódu je odvozený typ sekvencí řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="1e87f-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="1e87f-165">Určení dědičnosti</span><span class="sxs-lookup"><span data-stu-id="1e87f-165">Specifying Inheritance</span></span>

<span data-ttu-id="1e87f-166">`inherit` Klauzule identifikuje přímou základní třídu, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="1e87f-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="1e87f-167">V F#nástroji je povolena pouze jedna přímá základní třída.</span><span class="sxs-lookup"><span data-stu-id="1e87f-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="1e87f-168">Rozhraní, která třída implementuje, nejsou považovány za základní třídy.</span><span class="sxs-lookup"><span data-stu-id="1e87f-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="1e87f-169">Rozhraní jsou popsána v tématu [rozhraní](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="1e87f-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="1e87f-170">K metodám a vlastnostem základní třídy můžete přistupovat z odvozené třídy pomocí klíčového slova `base` Language jako identifikátoru následovaného tečkou (.) a názvem člena.</span><span class="sxs-lookup"><span data-stu-id="1e87f-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="1e87f-171">Další informace najdete v tématu [Dědičnost](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="1e87f-172">Oddíl members</span><span class="sxs-lookup"><span data-stu-id="1e87f-172">Members Section</span></span>

<span data-ttu-id="1e87f-173">V této části můžete definovat statické nebo instanční metody, vlastnosti, implementace rozhraní, abstraktní členy, deklarace událostí a další konstruktory.</span><span class="sxs-lookup"><span data-stu-id="1e87f-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="1e87f-174">V této části se nemůžou objevit vazby let a do.</span><span class="sxs-lookup"><span data-stu-id="1e87f-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="1e87f-175">Vzhledem k tomu, že členy mohou být přidány F# do různých typů kromě tříd, jsou popsány v samostatném tématu, [členy](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="1e87f-176">Vzájemně rekurzivní typy</span><span class="sxs-lookup"><span data-stu-id="1e87f-176">Mutually Recursive Types</span></span>

<span data-ttu-id="1e87f-177">Při definování typů, které na sobě navzájem odkazují, se řetězcem spojí definice typu pomocí `and` klíčového slova.</span><span class="sxs-lookup"><span data-stu-id="1e87f-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="1e87f-178">`and` Klíčové slovo `type` nahrazuje klíčové slovo pro všechny kromě první definice, a to následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="1e87f-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="1e87f-179">Výstupem je seznam všech souborů v aktuálním adresáři.</span><span class="sxs-lookup"><span data-stu-id="1e87f-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="1e87f-180">Kdy použít třídy, sjednocení, záznamy a struktury</span><span class="sxs-lookup"><span data-stu-id="1e87f-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="1e87f-181">Vzhledem k nejrůznějším typům, ze kterých si můžete vybrat, je potřeba mít dobré znalosti o tom, k čemu je každý typ navržený, aby se dal vybrat vhodný typ pro konkrétní situaci.</span><span class="sxs-lookup"><span data-stu-id="1e87f-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="1e87f-182">Třídy jsou navrženy pro použití v objektově orientovaných kontextech programování.</span><span class="sxs-lookup"><span data-stu-id="1e87f-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="1e87f-183">Objektově orientované programování je dominantní paradigma používaný v aplikacích, které jsou zapsány pro .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1e87f-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="1e87f-184">Pokud váš F# kód musí úzce fungovat s .NET Framework nebo jinou knihovnou orientovanou na objekt, a zejména v případě, že je nutné roztáhnout z objektově orientovaného systému typů, jako je například knihovna uživatelského rozhraní, třídy jsou pravděpodobně vhodné.</span><span class="sxs-lookup"><span data-stu-id="1e87f-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="1e87f-185">Pokud nejste úzce spolupracujete s objektově orientovaným kódem, nebo pokud píšete kód, který je samostatný a je proto chráněn před častými interakcemi s objektově orientovaným kódem, měli byste zvážit použití záznamů a rozlišených sjednocení.</span><span class="sxs-lookup"><span data-stu-id="1e87f-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="1e87f-186">Jedno, dobře považované za rozlišené sjednocení spolu s odpovídajícím kódem odpovídajícím vzoru lze často použít jako jednodušší alternativu k hierarchii objektů.</span><span class="sxs-lookup"><span data-stu-id="1e87f-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="1e87f-187">Další informace o rozlišených sjednoceních naleznete v tématu [rozlišené sjednocení](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="1e87f-188">Záznamy mají výhodu, že je jednodušší než třídy, ale záznamy nejsou vhodné, pokud požadavky typu překračují, co je možné dosáhnout s jejich jednoduchostí.</span><span class="sxs-lookup"><span data-stu-id="1e87f-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="1e87f-189">Záznamy jsou v podstatě jednoduché agregace hodnot bez samostatných konstruktorů, které mohou provádět vlastní akce, bez skrytých polí a bez implementace dědičnosti nebo rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1e87f-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="1e87f-190">I když mohou být členy, jako jsou vlastnosti a metody, přidány do záznamů, aby jejich chování bylo složitější, pole uložená v záznamu jsou stále jednoduchou agregací hodnot.</span><span class="sxs-lookup"><span data-stu-id="1e87f-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="1e87f-191">Další informace o záznamech najdete v tématu [záznamy](records.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="1e87f-192">Struktury jsou také užitečné pro malé agregované údaje, ale liší se od tříd a záznamů v tom, že jsou typy hodnot .NET.</span><span class="sxs-lookup"><span data-stu-id="1e87f-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="1e87f-193">Třídy a záznamy jsou typy odkazů .NET.</span><span class="sxs-lookup"><span data-stu-id="1e87f-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="1e87f-194">Sémantika typů hodnot a odkazových typů se liší v tom, že typy hodnot jsou předány hodnotou.</span><span class="sxs-lookup"><span data-stu-id="1e87f-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="1e87f-195">To znamená, že se kopírují bit pro bitovou kopii, když jsou předány jako parametr nebo vráceny z funkce.</span><span class="sxs-lookup"><span data-stu-id="1e87f-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="1e87f-196">Jsou také uloženy v zásobníku nebo, jsou-li použity jako pole, vloženy do nadřazeného objektu místo uložení do jejich samostatného umístění v haldě.</span><span class="sxs-lookup"><span data-stu-id="1e87f-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="1e87f-197">Proto jsou struktury vhodné pro často používaná data v případě, že režie přístupu k haldě je problém.</span><span class="sxs-lookup"><span data-stu-id="1e87f-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="1e87f-198">Další informace o strukturách naleznete v tématu [struktury](structures.md).</span><span class="sxs-lookup"><span data-stu-id="1e87f-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1e87f-199">Viz také:</span><span class="sxs-lookup"><span data-stu-id="1e87f-199">See also</span></span>

- [<span data-ttu-id="1e87f-200">Referenční dokumentace jazyka F#</span><span class="sxs-lookup"><span data-stu-id="1e87f-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="1e87f-201">Členové</span><span class="sxs-lookup"><span data-stu-id="1e87f-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="1e87f-202">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="1e87f-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="1e87f-203">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="1e87f-203">Interfaces</span></span>](interfaces.md)
