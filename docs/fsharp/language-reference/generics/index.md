---
title: Obecné typy
description: Naučte se používat F# obecné funkce a typy, které umožňují psát kód, který pracuje s různými typy bez opakujícího se kódu.
ms.date: 05/16/2016
ms.openlocfilehash: 47eed0b8e074cfb591e6d8e2c382b9ea6a6e97f0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630614"
---
# <a name="generics"></a><span data-ttu-id="fb8ba-103">Obecné typy</span><span class="sxs-lookup"><span data-stu-id="fb8ba-103">Generics</span></span>

<span data-ttu-id="fb8ba-104">F#hodnoty funkcí, metody, vlastnosti a agregované typy, jako jsou třídy, záznamy a rozlišené sjednocení, mohou být *Obecné*.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="fb8ba-105">Obecné konstrukce obsahují alespoň jeden parametr typu, který je obvykle poskytován uživatelem obecné konstrukce.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="fb8ba-106">Obecné funkce a typy umožňují napsat kód, který pracuje s různými typy bez opakování kódu pro každý typ.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="fb8ba-107">Nastavení obecného kódu může být jednoduché v F#, protože často je váš kód implicitně odvozený, aby byl obecný pro odvození typu kompilátor a automatické generalizace.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="fb8ba-108">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="fb8ba-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="fb8ba-109">Poznámky</span><span class="sxs-lookup"><span data-stu-id="fb8ba-109">Remarks</span></span>

<span data-ttu-id="fb8ba-110">Deklarace explicitně generické funkce nebo typu je podobná jako u neobecné funkce nebo typu, s výjimkou specifikace (a použití) parametrů typu, v lomených závorkách za funkcí nebo názvem typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="fb8ba-111">Deklarace jsou často implicitně Obecné.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="fb8ba-112">Pokud nezadáte úplný typ každého parametru, který se používá k vytvoření funkce nebo typu, kompilátor se pokusí odvodit typ každého parametru, hodnoty a proměnné z kódu, který zapíšete.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="fb8ba-113">Další informace naleznete v tématu [odvození typu](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="fb8ba-114">Pokud kód pro váš typ nebo funkci neomezí jinak typy parametrů, funkce nebo typ je implicitně obecný.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="fb8ba-115">Tento proces se nazývá *Automatická generalizace*.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="fb8ba-116">Existují určitá omezení pro automatické generalizace.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="fb8ba-117">Například pokud F# kompilátor nemůže odvodit typy pro obecnou konstrukci, kompilátor ohlásí chybu, která odkazuje na omezení nazývané *omezení hodnoty*.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="fb8ba-118">V takovém případě může být nutné přidat některé anotace typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="fb8ba-119">Další informace o automatické generalizaci a omezení hodnoty a o tom, jak změnit kód pro vyřešení problému, najdete v tématu [Automatická generalizace](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="fb8ba-120">V předchozí syntaxi *typ – parametry* jsou čárkami oddělený seznam parametrů, které reprezentují neznámé typy, z nichž každá začíná jednoduchou uvozovkou, volitelně s klauzulí omezení, která ještě více omezuje typy, které mohou být použity pro daný typ. ukazatele.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="fb8ba-121">Syntaxi klauzulí omezení různých druhů a dalších informací o omezeních naleznete v tématu [omezení](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="fb8ba-122">*Definice typu* v syntaxi je stejná jako definice typu pro typ, který není obecný.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="fb8ba-123">Obsahuje parametry konstruktoru pro typ `as` třídy, volitelnou klauzuli, symbol rovnosti, pole záznamu `inherit` , klauzuli, volby pro rozlišené sjednocení `let` a `do` vazby, definice členů, a cokoli jiného povolený v definici bez obecného typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="fb8ba-124">Ostatní prvky syntaxe jsou stejné jako u neobecných funkcí a typů.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="fb8ba-125">Například *identifikátor objektu* je identifikátor, který představuje samotný nadřazený objekt.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="fb8ba-126">Vlastnosti, pole a konstruktory nemohou být obecnější než nadřazený typ.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="fb8ba-127">Hodnoty v modulu také nemohou být obecné.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="fb8ba-128">Implicitně obecné konstrukce</span><span class="sxs-lookup"><span data-stu-id="fb8ba-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="fb8ba-129">Když F# kompilátor odvodí typy ve vašem kódu, automaticky zpracuje všechny funkce, které mohou být obecné.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="fb8ba-130">Pokud zadáte typ explicitně, například typ parametru, zabráníte automatické generalizaci.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="fb8ba-131">V následujícím příkladu `makeList` kódu je obecný, a to i v případě, že ani jeho parametry nejsou explicitně deklarovány jako obecné.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="fb8ba-132">Podpis funkce je odvozený `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="fb8ba-133">Všimněte si `a` , `b` že a v tomto příkladu jsou odvozeny, aby měly stejný typ.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="fb8ba-134">Je to proto, že jsou zahrnuty v seznamu dohromady a všechny prvky seznamu musí být stejného typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="fb8ba-135">Můžete také vytvořit obecné funkce pomocí syntaxe jednoduchých uvozovek v anotaci typu k označení toho, že typ parametru je obecný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="fb8ba-136">V následujícím kódu je obecný `function1` , protože jeho parametry jsou deklarovány tímto způsobem, jako parametry typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="fb8ba-137">Explicitní obecné konstrukce</span><span class="sxs-lookup"><span data-stu-id="fb8ba-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="fb8ba-138">Můžete také vytvořit obecnou funkci tím, že explicitně deklarujete své parametry typu v lomených závorkách (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="fb8ba-139">Následující kód to znázorňuje.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="fb8ba-140">Použití obecných konstrukcí</span><span class="sxs-lookup"><span data-stu-id="fb8ba-140">Using Generic Constructs</span></span>

<span data-ttu-id="fb8ba-141">Při použití obecných funkcí nebo metod nemusí být nutné zadat argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="fb8ba-142">Kompilátor používá odvození typu pro odvození příslušných argumentů typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="fb8ba-143">Pokud je stále nejednoznačnost, můžete zadat argumenty typu v lomených závorkách a rozdělit více argumentů typu čárkami.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="fb8ba-144">Následující kód ukazuje použití funkcí, které jsou definovány v předchozích částech.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="fb8ba-145">Existují dva způsoby, jak odkazovat na obecný typ podle názvu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="fb8ba-146">Například `list<int>` a `int list` jsou dva způsoby, jak odkazovat na obecný typ `list` , který má jeden argument `int`typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="fb8ba-147">Druhá forma je použita v konvenci pouze s vestavěnými F# typy, jako jsou `list` a. `option`</span><span class="sxs-lookup"><span data-stu-id="fb8ba-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="fb8ba-148">Pokud existuje více argumentů typu, obvykle používáte syntaxi `Dictionary<int, string>` , ale můžete také použít syntaxi. `(int, string) Dictionary`</span><span class="sxs-lookup"><span data-stu-id="fb8ba-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="fb8ba-149">Zástupné znaky jako argumenty typu</span><span class="sxs-lookup"><span data-stu-id="fb8ba-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="fb8ba-150">Chcete-li určit, že by měl být argument typu odvozen kompilátorem, lze použít podtržítko nebo zástupný symbol (`_`) namísto pojmenovaného argumentu typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="fb8ba-151">Tento kód je zobrazen v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="fb8ba-152">Omezení v obecných typech a funkcích</span><span class="sxs-lookup"><span data-stu-id="fb8ba-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="fb8ba-153">V definici obecného typu nebo funkce můžete použít pouze ty konstrukce, které jsou známy k dispozici v parametru obecného typu.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="fb8ba-154">To je nutné k povolení ověřování volání funkcí a metod v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="fb8ba-155">Deklarujete-li parametry typu explicitně, můžete použít explicitní omezení na parametr obecného typu pro oznamování kompilátoru, že jsou k dispozici určité metody a funkce.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="fb8ba-156">Nicméně, pokud povolíte F# kompilátoru odvodit vaše obecné typy parametrů, určí příslušné omezení pro vás.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="fb8ba-157">Další informace najdete v tématu [omezení](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="fb8ba-158">Statisticky vyřešené parametry typu</span><span class="sxs-lookup"><span data-stu-id="fb8ba-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="fb8ba-159">Existují dva druhy parametrů typu, které lze použít v F# programech.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="fb8ba-160">První jsou parametry obecného typu pro typ popsaný v předchozích částech.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="fb8ba-161">Tento první druh parametru typu je ekvivalentní k parametrům obecného typu, které jsou používány v jazycích, jako je například C#Visual Basic a.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="fb8ba-162">Jiný typ parametru je specifický pro F# a je označován jako *staticky vyřešený parametr typu*.</span><span class="sxs-lookup"><span data-stu-id="fb8ba-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="fb8ba-163">Informace o těchto konstrukcích naleznete v tématu [staticky vyřešené parametry typu](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="fb8ba-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="fb8ba-164">Příklady</span><span class="sxs-lookup"><span data-stu-id="fb8ba-164">Examples</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="fb8ba-165">Viz také:</span><span class="sxs-lookup"><span data-stu-id="fb8ba-165">See also</span></span>

- [<span data-ttu-id="fb8ba-166">Referenční dokumentace jazyka</span><span class="sxs-lookup"><span data-stu-id="fb8ba-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="fb8ba-167">Typy</span><span class="sxs-lookup"><span data-stu-id="fb8ba-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="fb8ba-168">Statisticky vyřešené parametry typu</span><span class="sxs-lookup"><span data-stu-id="fb8ba-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="fb8ba-169">Obecné typy v .NET Framework</span><span class="sxs-lookup"><span data-stu-id="fb8ba-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="fb8ba-170">Automatická generalizace</span><span class="sxs-lookup"><span data-stu-id="fb8ba-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="fb8ba-171">Omezení</span><span class="sxs-lookup"><span data-stu-id="fb8ba-171">Constraints</span></span>](constraints.md)
