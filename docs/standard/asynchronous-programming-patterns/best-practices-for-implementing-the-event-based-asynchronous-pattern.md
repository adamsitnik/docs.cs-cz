---
title: Osvědčené postupy pro implementaci asynchronního vzoru založeného na událostech
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 26e1fd4231964be5448229a6b3c7d90c0ba64499
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/19/2019
ms.locfileid: "65882517"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="b6d0c-102">Osvědčené postupy pro implementaci asynchronního vzoru založeného na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>
<span data-ttu-id="b6d0c-103">Asynchronní vzor založený na událostech poskytuje účinný způsob, jak vystavit asynchronní chování v třídy pomocí známých události a delegovat sémantiku.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="b6d0c-104">K implementaci asynchronního vzoru založeného na událostech, budete muset postupovat podle některých zvláštní chování požadavky.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="b6d0c-105">Následující části popisují požadavky a pokyny, které byste měli zvážit při implementaci třídy, která používá asynchronní vzor založený na událostech.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="b6d0c-106">Přehled najdete v tématu [implementace asynchronního vzoru založeného na událostech](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="b6d0c-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="b6d0c-107">Požadované chování záruky</span><span class="sxs-lookup"><span data-stu-id="b6d0c-107">Required Behavioral Guarantees</span></span>  
 <span data-ttu-id="b6d0c-108">Pokud se rozhodnete implementovat asynchronní vzor založený na událostech, je nutné zadat číslo záruk zajistěte, aby vaše třída se bude chovat správně a na takové chování můžete spoléhat, klienti vaší třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="b6d0c-109">Dokončení</span><span class="sxs-lookup"><span data-stu-id="b6d0c-109">Completion</span></span>  
 <span data-ttu-id="b6d0c-110">Vždy vyvolá <em>MethodName</em>**dokončeno** obslužná rutina události, když máte úspěšné dokončení, chybě nebo zrušení.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="b6d0c-111">Aplikace by nikdy dojít k situaci, kdy jsou zůstat v nečinnosti a dokončení se nikdy neprovádí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="b6d0c-112">Jedinou výjimkou tohoto pravidla je, pokud asynchronní operace, samotného je navržený tak, aby nikdy nedokončí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="b6d0c-113">Událost dokončení a EventArgs</span><span class="sxs-lookup"><span data-stu-id="b6d0c-113">Completed Event and EventArgs</span></span>  
 <span data-ttu-id="b6d0c-114">Pro každou zvláštní <em>MethodName</em>**asynchronní** metody, platí následující požadavky na návrh:</span><span class="sxs-lookup"><span data-stu-id="b6d0c-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="b6d0c-115">Definování <em>MethodName</em>**dokončeno** události na stejné třídy jako metodu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="b6d0c-116">Definování <xref:System.EventArgs> třídy a doprovodných delegáta pro <em>MethodName</em>**dokončeno** událost, která je odvozena z <xref:System.ComponentModel.AsyncCompletedEventArgs> třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="b6d0c-117">Výchozí název třídy by měl být ve tvaru <em>MethodName</em>**CompletedEventArgs**.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="b6d0c-118">Ujistěte se, že <xref:System.EventArgs> třída je specifická pro vrácené hodnoty <em>MethodName</em> metody.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="b6d0c-119">Při použití <xref:System.EventArgs> třídy by nikdy vyžadujete vývojářům přetypujte výsledek.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="b6d0c-120">Následující příklad kódu ukazuje implementaci dobré a špatné tomuto požadavku návrhu v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)   
{   
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)   
{   
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="b6d0c-121">Nedefinujte <xref:System.EventArgs> třídy pro vrácení metody, které vracejí `void`.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="b6d0c-122">Místo toho použijte instanci <xref:System.ComponentModel.AsyncCompletedEventArgs> třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="b6d0c-123">Ujistěte se, že vždy zvýšit <em>MethodName</em>**dokončeno** událostí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="b6d0c-124">Při úspěšném dokončení, chybě nebo zrušení, by měla tato událost vyvolána.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="b6d0c-125">Aplikace by nikdy dojít k situaci, kdy jsou zůstat v nečinnosti a dokončení se nikdy neprovádí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="b6d0c-126">Ujistěte se, můžete zachytit žádné výjimky, které probíhá asynchronní operace a přiřaďte Zachycenou výjimku do <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="b6d0c-127">Došlo k chybě, dokončení úkolu, výsledky by neměl být přístupný.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="b6d0c-128">Když <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> vlastnost není `null`, zkontrolujte, že přístup k žádné vlastnosti v <xref:System.EventArgs> struktury vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="b6d0c-129">Použití <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> metody k provedení tohoto ověření.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="b6d0c-130">Model vypršení časového limitu za chybu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-130">Model a time out as an error.</span></span> <span data-ttu-id="b6d0c-131">Pokud dojde k vypršení časového limitu, zvýšit <em>MethodName</em>**dokončeno** událostí a přiřazení <xref:System.TimeoutException> k <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="b6d0c-132">Pokud vaše třída podporuje více souběžných volání, ujistěte se, že <em>MethodName</em>**dokončeno** událost obsahuje odpovídající `userSuppliedState` objektu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="b6d0c-133">Ujistěte se, <em>MethodName</em>**dokončeno** událost se vyvolá u příslušné vlákna a v příslušnou dobu v životního cyklu aplikací.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="b6d0c-134">Další informace naleznete v oddílu zřetězení a kontexty.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="b6d0c-135">Současně provádění operací</span><span class="sxs-lookup"><span data-stu-id="b6d0c-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="b6d0c-136">Pokud vaše třída podporuje více souběžných volání, umožňují vývojářům sledovat každé vyvolání samostatně tak, že definujete <em>MethodName</em>**asynchronní** přetížení přebírající stavu s hodnotou objektu parametr nebo ID úlohy, volá `userSuppliedState`.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="b6d0c-137">Tento parametr by měl vždy být posledním parametrem v <em>MethodName</em>**asynchronní** podpis metody.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="b6d0c-138">Pokud vaše třída definuje <em>MethodName</em>**asynchronní** přetížení přebírající parametr s hodnotou objektu stavu nebo ID úlohy, je potřeba sledovat dobu života operace s tímto ID úloh a nezapomeňte uvést zpět obslužné rutině dokončení.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="b6d0c-139">Nejsou k dispozici jako pomoc pomocné třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-139">There are helper classes available to assist.</span></span> <span data-ttu-id="b6d0c-140">Další informace o správě souběžnosti, naleznete v tématu [jak: Implementace komponenty, která podporuje asynchronní vzor založený na událostech](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="b6d0c-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="b6d0c-141">Pokud vaše třída definuje <em>MethodName</em>**asynchronní** metody bez parametru state a nepodporuje více souběžných volání, ujistěte se, že žádný pokus o vyvolání <em>MethodName</em>  **Asynchronní** před předchozího <em>MethodName</em>**asynchronní** vyvolání dokončení vyvolá <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="b6d0c-142">Obecně platí, není vyvolána výjimka, pokud <em>MethodName</em>**asynchronní** metody bez `userSuppliedState` parametr je vyvolána více než jednou, takže existují více zbývajících operací.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="b6d0c-143">Může vyvolat výjimku, pokud vaše třída explicitně nelze zpracovat takové situaci, ale předpokládá, že vývojáři dokáže zpracovat tyto více odlišitelné zpětná volání</span><span class="sxs-lookup"><span data-stu-id="b6d0c-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="b6d0c-144">Přístup k výsledky</span><span class="sxs-lookup"><span data-stu-id="b6d0c-144">Accessing Results</span></span>  
  
- <span data-ttu-id="b6d0c-145">Pokud došlo k chybě při provádění asynchronní operace, výsledky by neměl být přístupný.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="b6d0c-146">Zkontrolujte, že přístup k žádné vlastnosti v <xref:System.ComponentModel.AsyncCompletedEventArgs> při <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> není `null` vyvolá výjimku odkazuje <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="b6d0c-147"><xref:System.ComponentModel.AsyncCompletedEventArgs> Třída poskytuje <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> metodu pro tento účel.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="b6d0c-148">Ujistěte se, že žádný pokus o přístup k výsledku vyvolá <xref:System.InvalidOperationException> s informacemi o tom, že operace byla zrušena.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="b6d0c-149">Použití <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> metody k provedení tohoto ověření.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="b6d0c-150">Vykazování průběhu</span><span class="sxs-lookup"><span data-stu-id="b6d0c-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="b6d0c-151">Podporu vytváření sestav průběhu, pokud je to možné.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="b6d0c-152">To umožňuje vývojářům poskytují lepší výkon aplikací při použití vaší třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="b6d0c-153">Pokud se rozhodnete implementovat **ProgressChanged** nebo <em>MethodName</em>**ProgressChanged** událostí, ujistěte se, že neexistují žádné takové události vyvolané pro konkrétní asynchronní operace Po provedení této operace <em>MethodName</em>**dokončeno** byla vyvolána událost.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="b6d0c-154">Pokud standardní <xref:System.ComponentModel.ProgressChangedEventArgs> se zatím připravují, ujistěte se, že <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> může být interpretován vždy v procentech.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="b6d0c-155">Procento nemusí být přesné, ale to by měly představovat procenta.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="b6d0c-156">Pokud svůj postup vytváření sestav metriky musí být něco jiného než procento, odvoďte třídu z <xref:System.ComponentModel.ProgressChangedEventArgs> třídy a nechat <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> na 0.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="b6d0c-157">Vyhněte se použití sestav metriky než procenta.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="b6d0c-158">Ujistěte se, `ProgressChanged` událost se vyvolá u příslušné vlákna a v příslušnou dobu v životního cyklu aplikací.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="b6d0c-159">Další informace naleznete v oddílu zřetězení a kontexty.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="b6d0c-160">Implementace IsBusy</span><span class="sxs-lookup"><span data-stu-id="b6d0c-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="b6d0c-161">Nezveřejňujte `IsBusy` vlastnosti, pokud vaše třída podporuje více souběžných volání.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="b6d0c-162">Například proxy XML webové služby bez odkrytí `IsBusy` vlastnost vzhledem k tomu, které podporují více souběžných volání asynchronní metody.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="b6d0c-163">`IsBusy` Vlastnost by měla vrátit `true` po <em>MethodName</em>**asynchronní** byla volána metoda a před <em>MethodName</em>  **Dokončení** byla vyvolána událost.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="b6d0c-164">V opačném případě by měla vrátit `false`.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="b6d0c-165"><xref:System.ComponentModel.BackgroundWorker> a <xref:System.Net.WebClient> komponenty jsou příklady tříd, které zprostředkovávají `IsBusy` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="b6d0c-166">Zrušení</span><span class="sxs-lookup"><span data-stu-id="b6d0c-166">Cancellation</span></span>  
  
- <span data-ttu-id="b6d0c-167">Podporu zrušení, pokud je to možné.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-167">Support cancellation, if possible.</span></span> <span data-ttu-id="b6d0c-168">To umožňuje vývojářům poskytují lepší výkon aplikací při použití vaší třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="b6d0c-169">V případě zrušení, nastavte <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> příznak v <xref:System.ComponentModel.AsyncCompletedEventArgs> objektu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="b6d0c-170">Ujistěte se, že žádný pokus o přístup k výsledku vyvolá <xref:System.InvalidOperationException> s informacemi o tom, že operace byla zrušena.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="b6d0c-171">Použití <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> metody k provedení tohoto ověření.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="b6d0c-172">Zajistěte, aby vždy vrátí úspěšně volání metody zrušení a nikdy vyvolat výjimku.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="b6d0c-173">Obecně platí klient nezobrazí upozornění, že jde o tom, zda operace je skutečně možné zrušit v daném okamžiku a nezobrazí upozornění, že jde o tom, jestli byla úspěšná u dřív vydaných zrušení.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="b6d0c-174">Ale aplikace vždy dostanou oznámení při zrušení úspěšné, protože aplikace podílí na stav dokončení.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="b6d0c-175">Vyvolat <em>MethodName</em>**dokončeno** událost v případě, že operace se zrušila.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="b6d0c-176">Chyby a výjimky</span><span class="sxs-lookup"><span data-stu-id="b6d0c-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="b6d0c-177">Zachytit žádné výjimky, které probíhá asynchronní operace a nastavte hodnotu <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> vlastnosti pro tuto výjimku.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="b6d0c-178">Zřetězení a kontext</span><span class="sxs-lookup"><span data-stu-id="b6d0c-178">Threading and Contexts</span></span>  
 <span data-ttu-id="b6d0c-179">Pro správné fungování vaší třídy je velmi důležité, že obslužné rutiny událostí klienta jsou spuštěny na řádné vlákna nebo kontextu pro daný aplikační model, včetně aplikací ASP.NET a Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="b6d0c-180">Dvě důležité pomocné třídy jsou poskytovány k zajištění, že vaše asynchronní třída chová všechny aplikační model: <xref:System.ComponentModel.AsyncOperation> a <xref:System.ComponentModel.AsyncOperationManager>.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="b6d0c-181"><xref:System.ComponentModel.AsyncOperationManager> poskytuje jednu metodu <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, která vrátí <xref:System.ComponentModel.AsyncOperation>.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="b6d0c-182">Vaše <em>MethodName</em>**asynchronní** volání metody <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> a používá třídu vráceného <xref:System.ComponentModel.AsyncOperation> ke sledování doby života asynchronní úlohy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="b6d0c-183">K hlášení průběhu, přírůstkové výsledky a dokončování klientovi, zavolejte <xref:System.ComponentModel.AsyncOperation.Post%2A> a <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> metody <xref:System.ComponentModel.AsyncOperation>.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="b6d0c-184"><xref:System.ComponentModel.AsyncOperation> je zodpovědná za zařazování volání obslužné rutiny událostí klienta do správné vlákna nebo kontextu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b6d0c-185">Tato pravidla mohou obejít, pokud explicitně chcete se dostat na zásad aplikačního modelu, ale přesto využívat výhod další výhody plynoucí z použití asynchronního vzoru založeného na událostech.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="b6d0c-186">Můžete například, že třída provoz ve Windows Forms to bude zdarma vláken.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="b6d0c-187">Můžete vytvořit třídu volného vláken, za předpokladu, seznamte se s vývojáři implicitní omezením.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="b6d0c-188">Konzolové aplikace nesynchronizovat provádění <xref:System.ComponentModel.AsyncOperation.Post%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="b6d0c-189">To může způsobit `ProgressChanged` události, které mají být vyvolána mimo pořadí.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="b6d0c-190">Pokud chcete mít serializovat provádění <xref:System.ComponentModel.AsyncOperation.Post%2A> volání, implementovat a nainstalujte <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="b6d0c-191">Další informace o používání <xref:System.ComponentModel.AsyncOperation> a <xref:System.ComponentModel.AsyncOperationManager> Povolit asynchronní operace, naleznete v tématu [jak: Implementace komponenty, která podporuje asynchronní vzor založený na událostech](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="b6d0c-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="b6d0c-192">Pokyny</span><span class="sxs-lookup"><span data-stu-id="b6d0c-192">Guidelines</span></span>  
  
- <span data-ttu-id="b6d0c-193">V ideálním případě by měl být každé volání metody nezávisle na ostatních.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="b6d0c-194">Měli byste se vyhnout, párování volání se sdílenými prostředky.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="b6d0c-195">Pokud prostředky jsou sdílena mezi vyvoláními, musíte poskytnout správný synchronizační mechanismus v implementaci.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="b6d0c-196">Návrhy, které vyžadují klienta tak, aby implementace synchronizace se nedoporučuje.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="b6d0c-197">Můžete mít například asynchronní metodu, která bude přijímat globální statický objekt jako parametr; více souběžných volání této metody by mohlo způsobit poškození dat nebo zablokování.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="b6d0c-198">Pokud se rozhodnete implementovat metodu s více volání přetížení (`userState` v podpisu), bude nutné spravovat kolekce stavů uživatele nebo ID úlohy a jejich odpovídající čekajících operací vaší třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="b6d0c-199">Tato kolekce se dají chránit pomocí `lock` oblastí, protože různé volání přidávat a odebírat `userState` objektů v kolekci.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="b6d0c-200">Vezměte v úvahu opětovné použití `CompletedEventArgs` třídy tam, kde a proveditelné.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="b6d0c-201">V takovém případě není konzistentní s názvem metody pojmenování protože dané delegáta a <xref:System.EventArgs> typu nejsou vázané na jedinou metodu.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="b6d0c-202">Ale vynucení vývojářům přetypujte hodnotu na načten z vlastnosti <xref:System.EventArgs> není nikdy přijatelné.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="b6d0c-203">Vytváříte-li třídu, která je odvozena z <xref:System.ComponentModel.Component>neměňte implementovat a nainstalujte vlastní <xref:System.Threading.SynchronizationContext> třídy.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="b6d0c-204">Modely aplikace, není součástí, ovládací prvek <xref:System.Threading.SynchronizationContext> , který se používá.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="b6d0c-205">Pokud používáte multithreading jakéhokoli druhu, potenciálně zpřístupníte sami velmi závažných a složitých chyb.</span><span class="sxs-lookup"><span data-stu-id="b6d0c-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="b6d0c-206">Před implementací jakéhokoli řešení, které používá multithreadingu naleznete v tématu [spravovaných vláken osvědčené postupy](../../../docs/standard/threading/managed-threading-best-practices.md).</span><span class="sxs-lookup"><span data-stu-id="b6d0c-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b6d0c-207">Viz také:</span><span class="sxs-lookup"><span data-stu-id="b6d0c-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="b6d0c-208">Implementace asynchronního vzoru založeného na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-208">Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="b6d0c-209">Asynchronní vzor založený na událostech (EAP)</span><span class="sxs-lookup"><span data-stu-id="b6d0c-209">Event-based Asynchronous Pattern (EAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="b6d0c-210">Rozhodování, kdy implementovat asynchronní vzor založený na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="b6d0c-211">Osvědčené postupy pro implementaci asynchronního vzoru založeného na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="b6d0c-212">Postupy: Použití komponent, které podporují asynchronní vzor založený na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="b6d0c-213">Postupy: Implementace komponenty, která podporuje asynchronní vzor založený na událostech</span><span class="sxs-lookup"><span data-stu-id="b6d0c-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)
