---
title: Výzvy a řešení správy distribuovaných dat
description: Zjistěte, jaké jsou problémy a řešení správy distribuovaných dat ve světě mikroslužeb.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 3e683044ea6a31116f1e7da6d690fc32ad87bd76
ms.sourcegitcommit: 438919211260bb415fc8f96ca3eabc33cf2d681d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/16/2019
ms.locfileid: "59613695"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="cd2e5-103">Výzvy a řešení správy distribuovaných dat</span><span class="sxs-lookup"><span data-stu-id="cd2e5-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="cd2e5-104">Výzvy \#1: Definování hranice jednotlivých mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="cd2e5-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="cd2e5-105">Definování hranic mikroslužby je pravděpodobně první výzvy, které všem uživatelům, zaznamená.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="cd2e5-106">Každá mikroslužba musí být část vaší aplikace a každá mikroslužba by měla být autonomní s všechny výhody i výzvy, které se přenáší.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="cd2e5-107">Ale jak máte identifikovat tyto hranice?</span><span class="sxs-lookup"><span data-stu-id="cd2e5-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="cd2e5-108">Nejprve budete muset zaměřit na logické doménových modelů a související data aplikace.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="cd2e5-109">Pokuste se identifikovat oddělující ostrovy data a různých kontextech v rámci stejné aplikace.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="cd2e5-110">Každý kontext může mít různé obchodní jazyk (různé obchodní podmínky).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="cd2e5-111">Kontexty by měl definovány a spravovat nezávisle.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="cd2e5-112">Podmínky a entity, které se používají v těchto různých kontextech může zní podobně, ale může zjistit, že v konkrétním kontextu, obchodní konceptu s jedním používá pro jiný účel v jiném kontextu a dokonce může mít jiný název.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="cd2e5-113">Uživatel například může odkazovat jako uživatel v rámci identity nebo členství zákazníky v rámci CRM jako odběratel v pořadí kontextu a tak dále.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="cd2e5-114">Způsob identifikace hranic mezi několika kontextech aplikaci s jinou doménu pro každý kontext je přesně, jak můžete identifikovat hranice pro každou obchodní mikroslužeb a související doménový model a data.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="cd2e5-115">Vždy snaží minimalizovat párování mezi těmito mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="cd2e5-116">Tato příručka obsahuje další podrobnosti o tento návrh modelu identifikace a domény v části [identifikace hranic mezi modelem a doménou u jednotlivých mikroslužeb](identify-microservice-domain-model-boundaries.md) později.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="cd2e5-117">Výzvy \#2: Jak vytvořit dotazy, které načítají data z několika mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="cd2e5-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="cd2e5-118">Druhá výzva je implementace dotazů, které načítají data z několika mikroslužeb, při obcházení košatá komunikace na mikroslužby od aplikace vzdáleného klienta.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="cd2e5-119">Příkladem může být na jedné obrazovce z mobilní aplikace, které se musí zobrazovat informace o uživateli, který je vlastněn nákupní košík, katalogu a uživatele identit mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="cd2e5-120">Dalším příkladem může být složité sestavy zahrnující mnoho tabulek v několika mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="cd2e5-121">Má to pravé řešení závisí na složitosti dotazů.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="cd2e5-122">Ale v každém případě budete potřebovat způsob, jak souhrnné informace, pokud chcete zvýšit efektivitu v rámci komunikace vašeho systému.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="cd2e5-123">Nejoblíbenější řešení jsou uvedeny níže.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="cd2e5-124">**Brána rozhraní API.**</span><span class="sxs-lookup"><span data-stu-id="cd2e5-124">**API Gateway.**</span></span> <span data-ttu-id="cd2e5-125">Doporučený postup pro jednoduchou datovou agregaci z několika mikroslužeb, která vlastníte různých databázích, je agregaci mikroslužeb označovány jako bránu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="cd2e5-126">Musíte ale buďte opatrní při implementaci tohoto modelu, protože bod potlačení může být ve vašem systému a jeho porušovat zásady autonomie mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="cd2e5-127">Ke zmírnění tuto možnost, můžete mít více bran rozhraní API pokutu grained každý jeden zaměření na svislé "řez" nebo obchodní oblast systému.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="cd2e5-128">Vzor brány rozhraní API je vysvětleno podrobněji [Brána rozhraní API části](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) později.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="cd2e5-129">**CQRS s tabulkami dotazování nebo čtení.**</span><span class="sxs-lookup"><span data-stu-id="cd2e5-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="cd2e5-130">Druhým řešením pro agregaci dat z několika mikroslužeb je [modelu Materializovaného zobrazení](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="cd2e5-131">V takovém případě můžete vygenerovat, předem (předtím, než skutečný dotazy stát, Příprava Nenormalizovaná data), jen pro čtení tabulky s daty, který je vlastněn více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="cd2e5-132">Tabulka obsahuje formátu podle potřeb klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="cd2e5-133">Vezměte v úvahu něco jako na obrazovce pro mobilní aplikace.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="cd2e5-134">Pokud máte jednu databázi, může být společně načítal data pro tuto obrazovku pomocí dotazu SQL, která provádí komplexní spojením zahrnujícím více tabulek.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="cd2e5-135">Ale pokud máte více databází a každá databáze není ve vlastnictví různých mikroslužeb, nelze dotazovat tyto databáze a vytvořit připojení k SQL.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="cd2e5-136">Komplexní dotaz stává náročné.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="cd2e5-137">Vyřešíte požadavek použití přístupu CQRS – vytvořit tabulku Nenormalizovaná v jiné databázi, který se používá jenom pro dotazy.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="cd2e5-138">V tabulce můžete určený speciálně pro data, která budete potřebovat pro komplexní dotaz s relací 1: 1 mezi poli vyžadované vaší aplikace obrazovky a sloupce v tabulce dotazu.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="cd2e5-139">Současně může sloužit ke generování sestav.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="cd2e5-140">Tento přístup nejen řeší původní problém (jak dotazu a spojení mezi mikroslužeb), ale také zlepšuje výkon výrazně ve srovnání s komplexní spojení, protože už máte data, která aplikace potřebuje v tabulce dotazu.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="cd2e5-141">Samozřejmě pomocí dotazů/čtení tabulek zodpovědnosti příkazů a dotazů oddělení (CQRS) znamená, že další vývojové práce a budete muset zapojte konečnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="cd2e5-142">Nicméně požadavky na výkon a vysokou škálovatelnost v [spolupráci scénáře](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (nebo konkurenční scénáře, v závislosti na pohledu) jsou, kde byste měli použít modelu CQRS s více databází.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="cd2e5-143">**"Studených dat" v centrální databáze.**</span><span class="sxs-lookup"><span data-stu-id="cd2e5-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="cd2e5-144">Pro složitější sestavy a dotazy, které nemusí potřebovat data v reálném čase, běžným přístupem je exportovat vaší "horkými data" (transakční data z mikroslužeb) jako "studených"dat do velké databáze, které se používají pouze pro vytváření sestav.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="cd2e5-145">Může být centrální databázový systém na systém založený na velké objemy dat, jako jsou Hadoop, datového skladu, jako je na Azure SQL Data Warehouse, nebo dokonce izolované databáze SQL, který se používá jen pro sestavy (Pokud je velikost nesmí být problém).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="cd2e5-146">Uvědomte si, že tento centralizované databázi se použije pouze pro dotazy a sestavy, které nepotřebují dat v reálném čase.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="cd2e5-147">Původní aktualizace a transakcí, jako zdroj pravdivých informací, musí být ve vašich datech mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="cd2e5-148">Způsob, jakým by synchronizovat data by pomocí komunikace založená na událostech (popsané v další části) nebo pomocí jiných nástrojů infrastruktury import/export databáze.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="cd2e5-149">Pokud používáte komunikace založená na událostech, tento proces integrace by podobným způsobem, jak je popsáno výše u tabulek dotaz modelu CQRS se šířit data.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="cd2e5-150">Ale pokud návrhu aplikace zahrnuje neustále agregování informací z několika mikroslužeb pro složité dotazy, může být příznakem chybný návrhu – mikroslužba by měla být izolaci jako z jiných mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="cd2e5-151">(Nezahrnuje sestav a analýzu, která vždy používejte studeného data centrální databáze.) Často potíže pravděpodobně z důvodu sloučit mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="cd2e5-152">Je potřeba vyrovnávat autonomie vývoj a nasazení jednotlivých mikroslužeb s silné závislosti, soudržnosti a agregace dat.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="cd2e5-153">Výzvy \#3: Jak dosáhnout konzistence napříč různými mikroslužbami</span><span class="sxs-lookup"><span data-stu-id="cd2e5-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="cd2e5-154">Jak bylo uvedeno dříve, data vlastníkem jednotlivých mikroslužeb je privátní pro tento mikroslužeb a je přístupný pouze pomocí jeho mikroslužeb rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="cd2e5-155">Jak implementovat začátku do konce obchodních procesů při zachování konzistence napříč několika mikroslužeb je proto zobrazí výzvu.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="cd2e5-156">Pokud chcete tento problém analyzovat, Podívejme se na příklad z [aplikaci eShopOnContainers odkazovat aplikace](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="cd2e5-157">Mikroslužby katalogu uchovává informace o všech produktů, včetně cena produktu.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="cd2e5-158">Nákupní košík mikroslužeb spravuje o položky produktu, kteří uživatelé budou přidávat do své nákupní košíky, dočasná data, která zahrnuje cena položky v době, kdy byly přidány do košíku.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="cd2e5-159">Při aktualizaci ceny produktu v katalogu Tato cena by měl aktualizované taky v aktivní koše, které obsahují stejné produktu a systém by měl pravděpodobně upozornit uživatele, informacemi o tom, že cenou určité položky změnila jejich přidání do nákupního košíku.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="cd2e5-160">Hypotetický monolitické verze této aplikace: Pokud cenových změn v tabulce produkty subsystému katalogu jednoduše použít transakci ACID aktualizovat aktuální ceny v tabulce Nákupní košík.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="cd2e5-161">Však v aplikacích založených na mikroslužbách tabulek Product a nákupním košíku jsou vlastněny jejich odpovídajících mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="cd2e5-162">Žádné mikroslužeb by měl obsahovat dříve vlastněn jinou mikroslužeb v jeho vlastní transakce, dokonce ani v přímých dotazů, tabulek a ukládání, jak ukazuje obrázek 4 – 9.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![Mikroslužby nemá přímý přístup k tabulce v jiném mikroslužeb, musí být konečné konzistence používá k synchronizaci dat.](./media/image9.png)

<span data-ttu-id="cd2e5-164">**Obrázek 4 – 9**.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-164">**Figure 4-9**.</span></span> <span data-ttu-id="cd2e5-165">Mikroslužby nemá přímý přístup k tabulce v jiném mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="cd2e5-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="cd2e5-166">Mikroslužeb katalogu by neměla aktualizovat tabulku nákupní košík přímo, protože tabulce Nákupní košík je vlastněná mikroslužeb nákupní košík.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="cd2e5-167">Mikroslužby katalogu provést malou úpravu mikroslužeb nákupní košík, měli by používat konečné konzistence pravděpodobně podle asynchronní komunikace, jako je například integrace událostí (zpráv a komunikaci na bázi události).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="cd2e5-168">Toto je způsob, jakým [aplikaci eShopOnContainers](https://aka.ms/eshoponcontainers) referenční aplikace provádí tento typ konzistence napříč mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="cd2e5-169">Jak je uvedeno ve [věty](https://en.wikipedia.org/wiki/CAP_theorem), je nutné zvolit mezi dostupností a odpovídající zásadám ACID silnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="cd2e5-170">Většina scénářů založených na mikroslužbách poptávky, dostupnosti a vysokou škálovatelnost na rozdíl od silné konzistence.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="cd2e5-171">Důležité podnikové aplikace musí zůstat nahoru a běží a vývojáři můžete alternativně vyřešit silná konzistence pomocí techniky pro práci s slabá nebo konečné konzistence.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="cd2e5-172">Jedná se o postup provedenou většina architektur založených na mikroslužbách.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="cd2e5-173">Kromě toho kyseliny – vizuální styl nebo dvoufázového potvrzení transakce, je právě proti principů mikroslužeb; Většina databází NoSQL (např. služby Azure Cosmos DB, MongoDB atd.) nepodporují dvoufázového potvrzení transakce, typické v situacích distribuovaných databází.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="cd2e5-174">Zachovat data konzistence napříč službami a databáze je však nezbytné.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="cd2e5-175">Tento problém souvisí na otázku, jak při určitých dat musí být redundantní šíří změny mezi různými mikroslužbami – například když potřebujete mít název nebo popis v katalogu mikroslužeb a košíku produktu mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="cd2e5-176">Dobrým řešením tohoto problému je použít konečnou konzistenci mezi mikroslužbami kloubové prostřednictvím komunikace založená na událostech a systémem publikování a odběr.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="cd2e5-177">Tato témata jsou popsané v části [asynchronní komunikace založená na událostech](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) dále v tomto průvodci.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="cd2e5-178">Výzvy \#4: Postup návrhu komunikace mezi hranic mikroslužby</span><span class="sxs-lookup"><span data-stu-id="cd2e5-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="cd2e5-179">Komunikace v rámci mikroslužeb je hranice skutečnou výzvou.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="cd2e5-180">V tomto kontextu komunikace neodkazuje na co je protokol by měl používat (HTTP a REST, AMQP, zasílání zpráv a tak dále).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="cd2e5-181">Místo toho adresy byste měli použít styl komunikace a způsob propojených mikroslužby by se měly používat.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="cd2e5-182">V závislosti na úrovni párování když dojde k chybě, dopad tohoto selhání v systému bude výrazně lišit.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="cd2e5-183">V distribuovaném systému jako aplikace založená na mikroslužbách, s tolika artefakty přesouvat a službami distribuované napříč mnoha servery nebo hostitele bude nakonec selže komponenty.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="cd2e5-184">Částečného selhání a ještě větší výpadků a se vyskytnou v případě, je potřeba navrhnout mikroslužby a komunikace mezi nimi zvážení běžné rizik u tohoto typu distribuovaného systému.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="cd2e5-185">Oblíbené přístup je k implementaci mikroslužeb založených na protokolu HTTP REST, z důvodu jejich jednoduchost.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="cd2e5-186">Přístup založený na protokolu HTTP, je zcela přijatelné; Tady problém se týká jak je používáte.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="cd2e5-187">Pokud použijete jenom k interakci s klientskými aplikacemi nebo z brány rozhraní API mikroslužby požadavky a odpovědi HTTP, který je v pořádku.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="cd2e5-188">Pokud však vytvoříte dlouhé řetězce o synchronních voláních HTTP přes mikroslužeb, komunikaci přes jejich hranice, jako kdyby byly objekty monolitické aplikace mikroslužeb aplikace bude nakonec potížím.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="cd2e5-189">Představte si například, že klientská aplikace provede volání rozhraní API HTTP jednotlivá mikroslužba jako jsou mikroslužby řazení.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="cd2e5-190">Pokud řazení mikroslužeb volá další cyklus mikroslužeb pomocí protokolu HTTP v rámci stejné žádostí a odpovědí, vytváříte řetěz volání HTTP.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="cd2e5-191">To může být zvukové přiměřené původně.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-191">It might sound reasonable initially.</span></span> <span data-ttu-id="cd2e5-192">Existují však důležité body ke zvážení při směrem dolů tuto cestu:</span><span class="sxs-lookup"><span data-stu-id="cd2e5-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="cd2e5-193">Blokování a nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-193">Blocking and low performance.</span></span> <span data-ttu-id="cd2e5-194">Kvůli synchronní povaze HTTP nebude původní požadavek získat odpověď, dokud se nedokončí všechny vnitřní volání HTTP.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="cd2e5-195">Představte si, pokud počet těchto volání výrazně zvyšuje a ve stejnou dobu jeden zprostředkující HTTP volání pro mikroslužby je blokován.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="cd2e5-196">Výsledkem je, že je dopad na výkon a celkovou škálovatelnost exponenciálně ovlivní jako další zvýšení požadavků HTTP.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="cd2e5-197">Mikroslužby párování s protokolem HTTP.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="cd2e5-198">Mikroslužby firmy by neměl být vázány na jiné firmy mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="cd2e5-199">V ideálním případě by neměla "ví" o existenci další mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="cd2e5-200">Pokud vaše aplikace závisí na párování mikroslužeb jako v příkladu, bude autonomie jednotlivých mikroslužbách dosáhnout téměř nemožné.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="cd2e5-201">Selhání v jakékoli jednu mikroslužbu.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-201">Failure in any one microservice.</span></span> <span data-ttu-id="cd2e5-202">Pokud jste implementovali řetěz mikroslužeb propojené volání HTTP, pokud některý z mikroslužeb selže (a nakonec se nezdaří) celý řetězec mikroslužeb se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="cd2e5-203">Chcete-li pokračovat v práci a také možné během částečné selhání by se měly navrhovat systému založených na mikroslužbách.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="cd2e5-204">I v případě, že budete implementovat logiku klienta, která používá opakování s exponenciální regresí nebo mechanismy jistič, další volání řetězy komplexní HTTP jsou, tím složitější je k implementaci strategie selhání založené na protokolu HTTP.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="cd2e5-205">Ve skutečnosti pokud interní mikroslužby jsou komunikaci tak, že vytvoříte řetězy požadavků protokolu HTTP, jak je popsáno, může být uvedl, že máte u monolitické aplikace, ale jeden založené na protokolu HTTP mezi procesy místo uvnitř procesu komunikačních mechanizmů.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="cd2e5-206">Pokud chcete vynutit autonomie mikroslužeb a mít lepší odolnost proti chybám, proto byste minimalizovat použití řetězy komunikace požadavku nebo odpovědi napříč mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="cd2e5-207">Doporučujeme používat pouze asynchronní interakce pro komunikaci mezi virtuálními sítěmi mikroslužeb pomocí asynchronních zpráv a události – komunikace na základě nebo s použitím (asynchronního) dotazování HTTP bez ohledu na jejich původní požadavek protokolu HTTP / cyklus odpovědi.</span><span class="sxs-lookup"><span data-stu-id="cd2e5-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="cd2e5-208">Použití asynchronní komunikace je vysvětlen později v tomto průvodci v části Další podrobnosti o [integrace asynchronní mikroslužeb vynucuje pro mikroslužby autonomie](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) a [asynchronní komunikace založená na zprávách](asynchronous-message-based-communication.md).</span><span class="sxs-lookup"><span data-stu-id="cd2e5-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="cd2e5-209">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="cd2e5-209">Additional resources</span></span>

- <span data-ttu-id="cd2e5-210">**Věty** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-210">**CAP theorem** \\</span></span>
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="cd2e5-211">**Konzistence typu případné** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-211">**Eventual consistency** \\</span></span>
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="cd2e5-212">**Úvod do konzistence dat** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-212">**Data Consistency Primer** \\</span></span>
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="cd2e5-213">**Martina Fowlera. CQRS (Command and Query Responsibility Segregation)** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** \\</span></span>
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="cd2e5-214">**Materializované zobrazení** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-214">**Materialized View** \\</span></span>
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="cd2e5-215">**Charles řádek. Odpovídající zásadám ACID vs. ZÁKLADNÍ: PH Shifting zpracování transakcí databáze** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** \\</span></span>
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="cd2e5-216">**Kompenzační transakce** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-216">**Compensating Transaction** \\</span></span>
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="cd2e5-217">**Udi Dahan. Služba orientovaný složení** \\</span><span class="sxs-lookup"><span data-stu-id="cd2e5-217">**Udi Dahan. Service Oriented Composition** \\</span></span>
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="cd2e5-218">[Předchozí](logical-versus-physical-architecture.md)
>[další](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="cd2e5-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
