---
title: Použití zjednodušených vzorů CQRS a DDD v mikroslužbě
description: Architektura Mikroslužeb .NET pro Kontejnerizované aplikace .NET | Seznamte se s celkový vztah mezi vzorů CQRS a DDD.
ms.date: 10/08/2018
ms.openlocfilehash: a5df8ce495b308df63af47ef1ec2ed26be2b5e37
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/19/2019
ms.locfileid: "65875892"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="56825-103">Použít zjednodušený vzorů CQRS a DDD v mikroslužbě</span><span class="sxs-lookup"><span data-stu-id="56825-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="56825-104">CQRS je schéma architektury, který odděluje modely pro čtení a zápis dat.</span><span class="sxs-lookup"><span data-stu-id="56825-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="56825-105">Související výraz [příkaz dotazu oddělení (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) bylo původně určené Bertrand Meyer ve své knize *objekt orientované konstrukce softwaru*.</span><span class="sxs-lookup"><span data-stu-id="56825-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="56825-106">Základní myšlenka je, že můžete rozdělit operací systému do dvou kategorií prudce oddělených:</span><span class="sxs-lookup"><span data-stu-id="56825-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="56825-107">Dotazy.</span><span class="sxs-lookup"><span data-stu-id="56825-107">Queries.</span></span> <span data-ttu-id="56825-108">Tyto vrácení výsledku a nemění stav systému, a jsou bez vedlejších účinků.</span><span class="sxs-lookup"><span data-stu-id="56825-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="56825-109">Příkazy.</span><span class="sxs-lookup"><span data-stu-id="56825-109">Commands.</span></span> <span data-ttu-id="56825-110">Tato změna stavu systému.</span><span class="sxs-lookup"><span data-stu-id="56825-110">These change the state of a system.</span></span>

<span data-ttu-id="56825-111">CQS je jednoduchý koncept – jde o metod v rámci stejného objektu dotazy nebo příkazy.</span><span class="sxs-lookup"><span data-stu-id="56825-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="56825-112">Každá metoda vrátí stav nebo mění stav, ale ne obojí.</span><span class="sxs-lookup"><span data-stu-id="56825-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="56825-113">Můžete dokonce objekt vzor jednoho úložiště v souladu s CQS.</span><span class="sxs-lookup"><span data-stu-id="56825-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="56825-114">CQS lze považovat za základní princip pro modelu CQRS.</span><span class="sxs-lookup"><span data-stu-id="56825-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="56825-115">[Příkaz a model dělení zodpovědnosti dotazů (CQRS)](https://martinfowler.com/bliki/CQRS.html) byla zavedená Grega Younga a důrazně přesunuty Udi Dahan a další.</span><span class="sxs-lookup"><span data-stu-id="56825-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="56825-116">Je založen na principu CQS, i když je podrobnější.</span><span class="sxs-lookup"><span data-stu-id="56825-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="56825-117">To lze považovat za vzor založený na příkazy a události a volitelně v asynchronních zpráv.</span><span class="sxs-lookup"><span data-stu-id="56825-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="56825-118">V mnoha případech se týká modelu CQRS pokročilejší scénáře, jako byste měli různé fyzické databáze pro čtení (dotazy), než pro zápis (aktualizace).</span><span class="sxs-lookup"><span data-stu-id="56825-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="56825-119">Kromě toho může implementovat více evolved systému CQRS [modelu Event Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) aktualizace databáze, proto byste měli pouze ukládat události v doménovém modelu místo ukládání dat aktuální stav.</span><span class="sxs-lookup"><span data-stu-id="56825-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="56825-120">Ale to není použitý v tomto průvodci; přístup Používáme nejjednodušší přístup modelu CQRS, který se skládá z právě oddělení dotazů z příkazů.</span><span class="sxs-lookup"><span data-stu-id="56825-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="56825-121">Oddělení aspektů modelu CQRS se dosahuje prostřednictvím seskupování operace dotazů v jedné vrstvě a příkazy v jiné vrstvě.</span><span class="sxs-lookup"><span data-stu-id="56825-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="56825-122">Každá vrstva má svůj vlastní datový model (Všimněte si, že říkáme model, ne tedy nutně jinou databázi) a je vytvořená pomocí svou vlastní kombinaci vzorů a technologie.</span><span class="sxs-lookup"><span data-stu-id="56825-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="56825-123">Důležitější je může být dvě vrstvy v rámci stejné vrstvy nebo mikroslužeb, jako v příkladu (řazení mikroslužeb) použít pro tohoto průvodce.</span><span class="sxs-lookup"><span data-stu-id="56825-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="56825-124">Nebo na jiný mikroslužby nebo procesy jejich možná implementace v tak může být optimalizováno a škálovat samostatně bez ovlivnění mezi sebou.</span><span class="sxs-lookup"><span data-stu-id="56825-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="56825-125">CQRS znamená, že s dva objekty pro operace čtení a zápis, kde v jiném kontextu existuje.</span><span class="sxs-lookup"><span data-stu-id="56825-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="56825-126">Je důvodů, proč jste Nenormalizovaná čte databázi, která se dozvíte v pokročilejší CQRS dokumentace.</span><span class="sxs-lookup"><span data-stu-id="56825-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="56825-127">Ale nepoužíváme tento přístup zde, kde je k dispozici větší flexibilitu v dotazech místo omezení dotazů s omezeními ze vzorů DDD, jako jsou agregace.</span><span class="sxs-lookup"><span data-stu-id="56825-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="56825-128">Příklad tohoto druhu služby je řazení mikroslužeb v aplikaci eShopOnContainers referenční aplikace.</span><span class="sxs-lookup"><span data-stu-id="56825-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="56825-129">Tato služba implementuje mikroslužeb podle zjednodušený přístup modelu CQRS.</span><span class="sxs-lookup"><span data-stu-id="56825-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="56825-130">Použije jeden zdroj dat nebo databáze, ale dvě logické modely a vzorů DDD transakční domény, jak je znázorněno v obrázku 7-2.</span><span class="sxs-lookup"><span data-stu-id="56825-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![Logické řazení mikroslužeb zahrnuje řazení databázi, která může být nebo není ve stejném Docker hostovat.](./media/image2.png)

<span data-ttu-id="56825-133">**Obrázek 7-2**.</span><span class="sxs-lookup"><span data-stu-id="56825-133">**Figure 7-2**.</span></span> <span data-ttu-id="56825-134">Zjednodušená založené na modelu CQRS a DDD mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="56825-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="56825-135">Samotné webové rozhraní API může být aplikační vrstvu.</span><span class="sxs-lookup"><span data-stu-id="56825-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="56825-136">Tady aspekt návrhu důležité je, že mikroslužbách rozdělil dotazy a modely ViewModel (zejména pro klientské aplikace vytvořit modely dat) z příkazů, doménový model a transakce po model CQRS.</span><span class="sxs-lookup"><span data-stu-id="56825-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="56825-137">Tento přístup zajišťuje dotazy nezávisle na omezení a omezení pocházejí z vzorů DDD, které smysl jenom pro transakce a aktualizací, jak je popsáno v předchozích částech.</span><span class="sxs-lookup"><span data-stu-id="56825-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="56825-138">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="56825-138">Additional resources</span></span>

 - <span data-ttu-id="56825-139">**Grega Younga:. Správa verzí v systému zdrojem událostí** (přečíst online e kniha zdarma) \\</span><span class="sxs-lookup"><span data-stu-id="56825-139">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) \\</span></span>
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="56825-140">[Předchozí](index.md)
>[další](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="56825-140">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
