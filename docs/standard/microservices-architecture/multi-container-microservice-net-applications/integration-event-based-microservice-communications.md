---
title: Implementace komunikace mezi mikroslužbami (události integrace) na základě událostí
description: Architektura Mikroslužeb .NET pro Kontejnerizované aplikace .NET | Principy integrace událostí k implementaci založený na událostech komunikace mezi mikroslužbami.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/02/2018
ms.openlocfilehash: cf1757531fc9eceee17f1faec66668945b9c2758
ms.sourcegitcommit: 40364ded04fa6cdcb2b6beca7f68412e2e12f633
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/28/2019
ms.locfileid: "56967968"
---
# <a name="implementing-event-based-communication-between-microservices-integration-events"></a><span data-ttu-id="cc0ee-103">Implementace komunikace mezi mikroslužbami (události integrace) na základě událostí</span><span class="sxs-lookup"><span data-stu-id="cc0ee-103">Implementing event-based communication between microservices (integration events)</span></span>

<span data-ttu-id="cc0ee-104">Jak je popsáno výše, při použití komunikace na základě událostí, mikroslužby publikuje událost v případě určité významné události, jako je například při aktualizaci obchodní entitě.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-104">As described earlier, when you use event-based communication, a microservice publishes an event when something notable happens, such as when it updates a business entity.</span></span> <span data-ttu-id="cc0ee-105">Další mikroslužeb přihlášení k odběru těchto událostí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-105">Other microservices subscribe to those events.</span></span> <span data-ttu-id="cc0ee-106">Událost přijetí mikroslužba je aktualizovat své vlastní obchodní entity, které by mohly vést k další události publikování.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-106">When a microservice receives an event, it can update its own business entities, which might lead to more events being published.</span></span> <span data-ttu-id="cc0ee-107">Je podstata konceptu konečné konzistence.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-107">This is the essence of the eventual consistency concept.</span></span> <span data-ttu-id="cc0ee-108">Tento systém publikování/odběr se obvykle provádí pomocí implementace sběrnice událostí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-108">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="cc0ee-109">Service bus události lze navrhnout jako rozhraní s rozhraním API, třeba pro předplatné a odhlášení odběru událostí a k publikování událostí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-109">The event bus can be designed as an interface with the API needed to subscribe and unsubscribe to events and to publish events.</span></span> <span data-ttu-id="cc0ee-110">Také může mít jeden nebo více implementací podle jakékoli mezi procesy nebo zasílání zpráv komunikace, jako jsou fronty zasílání zpráv nebo Azure service bus, která podporuje asynchronní komunikace a modelu publikování a přihlášení k odběru.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-110">It can also have one or more implementations based on any inter-process or messaging communication, such as a messaging queue or a service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="cc0ee-111">Můžete použít události k implementaci obchodních transakcí, které zahrnují více služeb, poskytující konečnou konzistenci mezi těmito službami.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-111">You can use events to implement business transactions that span multiple services, which gives you eventual consistency between those services.</span></span> <span data-ttu-id="cc0ee-112">Konečnou konzistenci transakcí se skládá z řady distribuovaných akcí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-112">An eventually consistent transaction consists of a series of distributed actions.</span></span> <span data-ttu-id="cc0ee-113">Na každou akci mikroslužeb aktualizuje obchodní entity a publikuje událost, která aktivuje další akci.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-113">At each action, the microservice updates a business entity and publishes an event that triggers the next action.</span></span>

![Katalog mikroslužeb, pomocí řízené událostmi komunikace prostřednictvím Service bus událostí k dosažení konečnou konzistenci s nákupní košík a další mikroslužeb.](./media/image19.png)

<span data-ttu-id="cc0ee-115">**Obrázek 6 – 18**.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-115">**Figure 6-18**.</span></span> <span data-ttu-id="cc0ee-116">Komunikace založená na událostech podle sběrnice událostí</span><span class="sxs-lookup"><span data-stu-id="cc0ee-116">Event-driven communication based on an event bus</span></span>

<span data-ttu-id="cc0ee-117">Tato část popisuje, jak můžete implementovat tento typ komunikace s .NET pomocí rozhraní Service bus Obecná událost, jak je znázorněno v obrázek 6 – 18.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-117">This section describes how you can implement this type of communication with .NET by using a generic event bus interface, as shown in Figure 6-18.</span></span> <span data-ttu-id="cc0ee-118">Existuje několik potenciálních implementací, každý pomocí různých technologií nebo infrastruktury, jako je například RabbitMQ, Azure Service Bus nebo jakékoli jiné třetích stran open source nebo komerční služby Service bus.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-118">There are multiple potential implementations, each using a different technology or infrastructure such as RabbitMQ, Azure Service Bus, or any other third-party open-source or commercial service bus.</span></span>

## <a name="using-message-brokers-and-services-buses-for-production-systems"></a><span data-ttu-id="cc0ee-119">Pomocí sběrnice zpráv zprostředkovatele a služby pro produkční systémy.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-119">Using message brokers and services buses for production systems</span></span>

<span data-ttu-id="cc0ee-120">Jak je uvedeno v části architektury, můžete vybrat z různými technologiemi zasílání zpráv pro implementace sběrnice vaše abstraktní událost.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-120">As noted in the architecture section, you can choose from multiple messaging technologies for implementing your abstract event bus.</span></span> <span data-ttu-id="cc0ee-121">Ale tyto technologie jsou na různých úrovních.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-121">But these technologies are at different levels.</span></span> <span data-ttu-id="cc0ee-122">Například RabbitMQ, zasílání zpráv Service broker přenos, je na nižší úrovni než komerční produkty, jako je Azure Service Bus, NServiceBus, MassTransit nebo Brighter.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-122">For instance, RabbitMQ, a messaging broker transport, is at a lower level than commercial products like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span> <span data-ttu-id="cc0ee-123">Většina těchto produktů může pracovat nad RabbitMQ nebo Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-123">Most of these products can work on top of either RabbitMQ or Azure Service Bus.</span></span> <span data-ttu-id="cc0ee-124">Podle vašeho výběru produktů závisí na tom, kolik funkce a kolik out-of-the-box škálovatelnost potřebujete pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-124">Your choice of product depends on how many features and how much out-of-the-box scalability you need for your application.</span></span>

<span data-ttu-id="cc0ee-125">Pro implementaci pouze události Service bus testování konceptu jako vývojové prostředí, stejně jako v ukázkové aplikaci eShopOnContainers mohou být jednoduché implementace nad RabbitMQ běžícího jako kontejner dostatečné.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-125">For implementing just an event bus proof-of-concept for your development environment, as in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running as a container might be enough.</span></span> <span data-ttu-id="cc0ee-126">Ale pro nepostradatelné a produkční systémy, které potřebují vysokou škálovatelnost, můžete k vyhodnocení a používat Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-126">But for mission-critical and production systems that need high scalability, you might want to evaluate and use Azure Service Bus.</span></span>

<span data-ttu-id="cc0ee-127">Pokud potřebujete vyšší úrovni abstrakce a bohatší funkce, jako jsou [Ság](https://docs.particular.net/nservicebus/sagas/) pro dlouho běžící procesy, které usnadňují distribuovaných vývojových jednodušší a další obchodní a open source služby sběrnice jako NServiceBus MassTransit, a Jasnější stojí za vaše rozhodnutí vyzkoušet.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-127">If you require high-level abstractions and richer features like [Sagas](https://docs.particular.net/nservicebus/sagas/) for long-running processes that make distributed development easier, other commercial and open-source service buses like NServiceBus, MassTransit, and Brighter are worth evaluating.</span></span> <span data-ttu-id="cc0ee-128">V takovém případě abstrakce a rozhraní API pro použití by obvykle neměl přímo ta poskytuje tyto základní služby sběrnice místo vlastní abstrakce (podobně jako [abstrakce jednoduché události Service bus k dispozici v aplikaci eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span><span class="sxs-lookup"><span data-stu-id="cc0ee-128">In this case, the abstractions and API to use would usually be directly the ones provided by those high-level service buses instead of your own abstractions (like the [simple event bus abstractions provided at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span></span> <span data-ttu-id="cc0ee-129">K tomuto účelu můžete prozkoumat [Rozvětvená aplikaci eShopOnContainers pomocí NServiceBus](https://go.particular.net/eShopOnContainers) (další vzorek odvozené implementované určitého softwaru)</span><span class="sxs-lookup"><span data-stu-id="cc0ee-129">For that matter, you can research the [forked eShopOnContainers using NServiceBus](https://go.particular.net/eShopOnContainers) (additional derived sample implemented by Particular Software)</span></span>

<span data-ttu-id="cc0ee-130">Samozřejmě může vždy sestavovat vlastní funkce služby Service bus na nižší úrovni technologie jako RabbitMQ a Docker, ale práce potřebné k "nesnažil" může být moc nákladný pro vlastní podnikové aplikace.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-130">Of course, you could always build your own service bus features on top of lower-level technologies like RabbitMQ and Docker, but the work needed to “reinvent the wheel” might be too costly for a custom enterprise application.</span></span>

<span data-ttu-id="cc0ee-131">Zdůrazňujeme: Ukázka událostí Service bus abstrakce a implementace, které vystavíte v ukázkové aplikaci eShopOnContainers jsou určena pro použití pouze jako testování konceptu.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-131">To reiterate: the sample event bus abstractions and implementation showcased in the eShopOnContainers sample are intended to be used only as a proof of concept.</span></span> <span data-ttu-id="cc0ee-132">Až si ověříte, že chcete mít komunikace asynchronní a založený na událostech, jak je popsáno v části aktuální, měli byste zvolit produkt služby Service bus, která nejlépe vyhovuje vašim potřebám pro produkční prostředí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-132">Once you have decided that you want to have asynchronous and event-driven communication, as explained in the current section, you should choose the service bus product that best fits your needs for production.</span></span>

## <a name="integration-events"></a><span data-ttu-id="cc0ee-133">Integrace událostí</span><span class="sxs-lookup"><span data-stu-id="cc0ee-133">Integration events</span></span>

<span data-ttu-id="cc0ee-134">Integrace události se používají pro přenesení stavu domény synchronizované napříč několika mikroslužbami nebo externí systémy.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-134">Integration events are used for bringing domain state in sync across multiple microservices or external systems.</span></span> <span data-ttu-id="cc0ee-135">To se provádí publikování události integrace mimo mikroslužbách.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-135">This is done by publishing integration events outside the microservice.</span></span> <span data-ttu-id="cc0ee-136">Při publikování události do několika mikroslužeb příjemce (na tolik mikroslužby jako přihlášeni k této události integrace), zpracuje obslužná rutina odpovídající události v jednotlivých mikroslužeb příjemce událost.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-136">When an event is published to multiple receiver microservices (to as many microservices as are subscribed to the integration event), the appropriate event handler in each receiver microservice handles the event.</span></span>

<span data-ttu-id="cc0ee-137">Integrace událost je v podstatě třída dat podniku, jako v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="cc0ee-137">An integration event is basically a data-holding class, as in the following example:</span></span>

```csharp
public class ProductPriceChangedIntegrationEvent : IntegrationEvent
{
    public int ProductId { get; private set; }
    public decimal NewPrice { get; private set; }
    public decimal OldPrice { get; private set; }

    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice,
        decimal oldPrice)
    {
        ProductId = productId;
        NewPrice = newPrice;
        OldPrice = oldPrice;
    }
}
```

<span data-ttu-id="cc0ee-138">Události integrace lze definovat na úrovni aplikace jednotlivých mikroslužeb, takže jsou oddělené od dalších mikroslužeb, způsobem, který je srovnatelná s hodnotou jak modely ViewModels jsou definované na serveru a klienta.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-138">The integration events can be defined at the application level of each microservice, so they are decoupled from other microservices, in a way comparable to how ViewModels are defined in the server and client.</span></span> <span data-ttu-id="cc0ee-139">Co se nedoporučuje sdílí společné knihovny integrace událostí mezi různými mikroslužbami; To provedete by být párování těchto mikroslužeb s knihovnou jednu událost definice data.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-139">What is not recommended is sharing a common integration events library across multiple microservices; doing that would be coupling those microservices with a single event definition data library.</span></span> <span data-ttu-id="cc0ee-140">Nechcete provést ze stejného důvodu, že nechcete sdílet společný model domény napříč různými mikroslužbami: musí být zcela autonomní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-140">You do not want to do that for the same reasons that you do not want to share a common domain model across multiple microservices: microservices must be completely autonomous.</span></span>

<span data-ttu-id="cc0ee-141">Existují jenom pár typy knihoven, které by měly sdílet napříč mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-141">There are only a few kinds of libraries you should share across microservices.</span></span> <span data-ttu-id="cc0ee-142">Jeden je knihovny, které jsou bloky konečné aplikace, jako je třeba [sběrnice událostí klientského rozhraní API](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), jako v aplikaci eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-142">One is libraries that are final application blocks, like the [Event Bus client API](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), as in eShopOnContainers.</span></span> <span data-ttu-id="cc0ee-143">Další knihovny, které tvoří nástroje, které by se dají sdílet taky jako NuGet komponenty, jako je JSON serializátory je.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-143">Another is libraries that constitute tools that could also be shared as NuGet components, like JSON serializers.</span></span>

## <a name="the-event-bus"></a><span data-ttu-id="cc0ee-144">Události Service bus</span><span class="sxs-lookup"><span data-stu-id="cc0ee-144">The event bus</span></span>

<span data-ttu-id="cc0ee-145">Sběrnice událostí umožňuje publikování/přihlášení odběru – vizuální styl komunikace mezi mikroslužbami, aniž by komponent je potřeba explicitně vědět, jak je znázorněno v obrázek 6 – 19.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-145">An event bus allows publish/subscribe-style communication between microservices without requiring the components to explicitly be aware of each other, as shown in Figure 6-19.</span></span>

![Základní pub/sub vzoru, Mikroslužby A publikuje do sběrnice událostí, který distribuuje na mikroslužby susbcribing B a C, aniž by museli znát susbcribers vydavatele.](./media/image20.png)

<span data-ttu-id="cc0ee-147">**Obrázek 6-19**.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-147">**Figure 6-19**.</span></span> <span data-ttu-id="cc0ee-148">Publikování/odběr základy s sběrnice událostí</span><span class="sxs-lookup"><span data-stu-id="cc0ee-148">Publish/subscribe basics with an event bus</span></span>

<span data-ttu-id="cc0ee-149">Service bus události týkající se vzor pozorovatel a publikovat – vzorec odběru.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-149">The event bus is related to the Observer pattern and the publish-subscribe pattern.</span></span>

### <a name="observer-pattern"></a><span data-ttu-id="cc0ee-150">Vzor pozorovatel</span><span class="sxs-lookup"><span data-stu-id="cc0ee-150">Observer pattern</span></span>

<span data-ttu-id="cc0ee-151">V [vzor pozorovatel](https://en.wikipedia.org/wiki/Observer_pattern), váš primární objekt (označuje se jako pozorovat) upozorní další zúčastněné objekty (označuje se jako pozorovatelů) s příslušnými informacemi (události).</span><span class="sxs-lookup"><span data-stu-id="cc0ee-151">In the [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern), your primary object (known as the Observable) notifies other interested objects (known as Observers) with relevant information (events).</span></span>

### <a name="publishsubscribe-pubsub-pattern"></a><span data-ttu-id="cc0ee-152">Vzor publikování/přihlášení k odběru (publikování a odběr)</span><span class="sxs-lookup"><span data-stu-id="cc0ee-152">Publish/Subscribe (Pub/Sub) pattern</span></span> 

<span data-ttu-id="cc0ee-153">Účelem [vzor publikování/přihlášení k odběru](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) je stejný jako vzor pozorovatel: Chcete upozornit jiné služby, probíhají určité události.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-153">The purpose of the [Publish/Subscribe pattern](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) is the same as the Observer pattern: you want to notify other services when certain events take place.</span></span> <span data-ttu-id="cc0ee-154">Existuje ale podstatným rozdílem mezi pozorovatel a Pub/Sub vzory.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-154">But there is an important difference between the Observer and Pub/Sub patterns.</span></span> <span data-ttu-id="cc0ee-155">Ve vzoru pozorovatel vysílání je provádět přímo pozorovat k pozorovatelé, tak jejich "know" mezi sebou.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-155">In the observer pattern, the broadcast is performed directly from the observable to the observers, so they “know” each other.</span></span> <span data-ttu-id="cc0ee-156">Ale při použití modelu Pub/Sub, je třetí součást, která volá zprostředkovatele nebo zprávy Service broker nebo událostí Service bus, která se označuje vydavatele a odběratele.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-156">But when using a Pub/Sub pattern, there is a third component, called broker or message broker or event bus, which is known by both the publisher and subscriber.</span></span> <span data-ttu-id="cc0ee-157">Proto při použití modelu Pub/Sub vydavatele a odběratele se přesně odděleném díky uvedené události Service bus nebo zprávy zprostředkovatele.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-157">Therefore, when using the Pub/Sub pattern the publisher and the subscribers are precisely decoupled thanks to the mentioned event bus or message broker.</span></span>

### <a name="the-middleman-or-event-bus"></a><span data-ttu-id="cc0ee-158">Prostředník nebo událostí Service bus</span><span class="sxs-lookup"><span data-stu-id="cc0ee-158">The middleman or event bus</span></span> 

<span data-ttu-id="cc0ee-159">Jak dosáhnete anonymity mezi vydavatele a odběratele</span><span class="sxs-lookup"><span data-stu-id="cc0ee-159">How do you achieve anonymity between publisher and subscriber?</span></span> <span data-ttu-id="cc0ee-160">Snadný způsob, je nechat prostředník postará o veškerá komunikace.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-160">An easy way is let a middleman take care of all the communication.</span></span> <span data-ttu-id="cc0ee-161">Sběrnice událostí je jeden takový prostředník.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-161">An event bus is one such middleman.</span></span>

<span data-ttu-id="cc0ee-162">Sběrnice událostí se obvykle skládá ze dvou částí:</span><span class="sxs-lookup"><span data-stu-id="cc0ee-162">An event bus is typically composed of two parts:</span></span>

-   <span data-ttu-id="cc0ee-163">Abstraktní nebo rozhraní.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-163">The abstraction or interface.</span></span>

-   <span data-ttu-id="cc0ee-164">Jeden nebo více implementací.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-164">One or more implementations.</span></span>

<span data-ttu-id="cc0ee-165">Obrázek 6-19 uvidíte, jak z aplikace hlediska, sběrnice událostí není nic jiného než Pub/Sub kanálu.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-165">In Figure 6-19 you can see how, from an application point of view, the event bus is nothing more than a Pub/Sub channel.</span></span> <span data-ttu-id="cc0ee-166">Způsob implementace této asynchronní komunikace se může lišit.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-166">The way you implement this asynchronous communication can vary.</span></span> <span data-ttu-id="cc0ee-167">Může mít několik implementací tak, aby můžete přepínat mezi nimi, v závislosti na požadavcích prostředí (například produkčního prostředí a vývojová prostředí).</span><span class="sxs-lookup"><span data-stu-id="cc0ee-167">It can have multiple implementations so that you can swap between them, depending on the environment requirements (for example, production versus development environments).</span></span>

<span data-ttu-id="cc0ee-168">Obrázek 6 – 20 uvidíte abstrakce sběrnice událostí s více implementací na základě infrastruktury zasílání zpráv technologie, jako je RabbitMQ, Azure Service Bus nebo jiného zprostředkovatele událostí/zpráv.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-168">In Figure 6-20 you can see an abstraction of an event bus with multiple implementations based on infrastructure messaging technologies like RabbitMQ, Azure Service Bus, or another event/message broker.</span></span>

![Je dobré si co sběrnice událostí definován pomocí rozhraní, takže je možné implementovat pomocí několika tecnologies, jako je RabbitMQ Azure Service bus nebo jiných.](./media/image21.png)

<span data-ttu-id="cc0ee-170">**Obrázek 6 – 20.**</span><span class="sxs-lookup"><span data-stu-id="cc0ee-170">**Figure 6- 20.**</span></span> <span data-ttu-id="cc0ee-171">Více implementací sběrnice událostí</span><span class="sxs-lookup"><span data-stu-id="cc0ee-171">Multiple implementations of an event bus</span></span>

<span data-ttu-id="cc0ee-172">Ale a jak bylo zmíněno dříve pomocí vlastní abstrakce (rozhraní události Service bus) je vhodné, pouze pokud je potřeba základní událost funkce Service bus podporuje vaše abstrakce.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-172">However, and as mentioned previously, using your own abstractions (the event bus interface) is good only if you need basic event bus features supported by your abstractions.</span></span> <span data-ttu-id="cc0ee-173">Pokud potřebujete širší funkce služby Service bus, je vhodné použít rozhraní API a abstrakce poskytované vaší preferované komerční služby Service bus místo vlastních odběrů.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-173">If you need richer service bus features, you should probably use the API and abstractions provided by your preferred commercial service bus instead of your own abstractions.</span></span>

### <a name="defining-an-event-bus-interface"></a><span data-ttu-id="cc0ee-174">Definování rozhraní událostí Service bus</span><span class="sxs-lookup"><span data-stu-id="cc0ee-174">Defining an event bus interface</span></span>

<span data-ttu-id="cc0ee-175">Začněme možná implementace pro účely zkoumání a implementace kódu pro rozhraní události Service bus.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-175">Let’s start with some implementation code for the event bus interface and possible implementations for exploration purposes.</span></span> <span data-ttu-id="cc0ee-176">Rozhraní musí být obecný a jasné, stejně jako v následujícím rozhraní.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-176">The interface should be generic and straightforward, as in the following interface.</span></span>

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent @event);

    void Subscribe<T, TH>()
        where T : IntegrationEvent
        where TH : IIntegrationEventHandler<T>;

    void SubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void UnsubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void Unsubscribe<T, TH>()
        where TH : IIntegrationEventHandler<T>
        where T : IntegrationEvent;
}
```

<span data-ttu-id="cc0ee-177">`Publish` Metoda je jednoduchá.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-177">The `Publish` method is straightforward.</span></span> <span data-ttu-id="cc0ee-178">Sběrnice událostí bude vysílat události integrace do něho předaný všechny mikroslužby nebo dokonce i externí aplikaci, na tuto událost odběru.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-178">The event bus will broadcast the integration event passed to it to any microservice, or even an external application, subscribed to that event.</span></span> <span data-ttu-id="cc0ee-179">Tato metoda používá mikroslužeb, která publikuje události.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-179">This method is used by the microservice that is publishing the event.</span></span>

<span data-ttu-id="cc0ee-180">`Subscribe` Metod (může mít několik implementací v závislosti na argumenty) jsou používány mikroslužeb, která chcete přijímat události.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-180">The `Subscribe` methods (you can have several implementations depending on the arguments) are used by the microservices that want to receive events.</span></span> <span data-ttu-id="cc0ee-181">Tato metoda má dva argumenty.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-181">This method has two arguments.</span></span> <span data-ttu-id="cc0ee-182">První možností je integrace událostí přihlášení k odběru (`IntegrationEvent`).</span><span class="sxs-lookup"><span data-stu-id="cc0ee-182">The first is the integration event to subscribe to (`IntegrationEvent`).</span></span> <span data-ttu-id="cc0ee-183">Druhý argument je integrace událostí obslužnou rutinu (nebo metoda zpětného volání), s názvem `IIntegrationEventHandler<T>`, který se spustí při získá mikroslužeb příjemce této zprávy integrace událostí.</span><span class="sxs-lookup"><span data-stu-id="cc0ee-183">The second argument is the integration event handler (or callback method), named `IIntegrationEventHandler<T>`, to be executed when the receiver microservice gets that integration event message.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="cc0ee-184">[Předchozí](database-server-container.md)
>[další](rabbitmq-event-bus-development-test-environment.md)</span><span class="sxs-lookup"><span data-stu-id="cc0ee-184">[Previous](database-server-container.md)
[Next](rabbitmq-event-bus-development-test-environment.md)</span></span>