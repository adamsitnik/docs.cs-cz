---
title: Podrobnosti k chování regulárních výrazů
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bc4d8fdc39153f227e8344ea1da52a0dba2688d0
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/23/2019
ms.locfileid: "61955956"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="645a6-102">Podrobnosti k chování regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="645a6-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="645a6-103">Modul regulárních výrazů rozhraní .NET Framework je navracení předávaný regulární výraz, který zahrnuje modul tradiční Nedeterministická Finite Automaton (NFA) jako, který používá Perl, Python, (emacs) a Tcl je.</span><span class="sxs-lookup"><span data-stu-id="645a6-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="645a6-104">To která ho odlišuje od rychleji, ale moduly Deterministické omezené Automaton (DFA) omezenější, čistý regulární výraz například výstrahám nacházejícím se v awk, egrep nebo lex.</span><span class="sxs-lookup"><span data-stu-id="645a6-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="645a6-105">To také která ho odlišuje od standardizované, ale pomalejší, k zařízení NFAs POSIX.</span><span class="sxs-lookup"><span data-stu-id="645a6-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="645a6-106">Následující část popisuje tři typy strojů regulárních výrazů a vysvětluje, proč jsou regulární výrazy v rozhraní .NET Framework implementovat pomocí tradičních modulem NFA.</span><span class="sxs-lookup"><span data-stu-id="645a6-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="645a6-107">Výhody modulem NFA</span><span class="sxs-lookup"><span data-stu-id="645a6-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="645a6-108">Když DFA moduly provádění porovnávání vzorů, jejich pořadí zpracování stanovených ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="645a6-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="645a6-109">Modul začne na začátku vstupního řetězce a postupně pokračuje k určení, zda další znak odpovídá vzoru regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="645a6-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="645a6-110">Se může zaručit tak, aby odpovídaly nejdelší řetězec je to možné.</span><span class="sxs-lookup"><span data-stu-id="645a6-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="645a6-111">Vzhledem k tomu, že nikdy otestovat ve stejném dvakrát, DFA moduly nepodporuje používání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="645a6-112">Ale protože DFA modul obsahuje pouze omezené stavu, nelze porovnání vzoru se zpětnými odkazy a protože ji nelze vytvořit explicitní rozšíření, nelze zachytit dílčích výrazů.</span><span class="sxs-lookup"><span data-stu-id="645a6-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="645a6-113">Na rozdíl od DFA modulů když tradiční NFA moduly provádění porovnávání vzorů, jejich pořadí zpracování doprovází vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="645a6-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="645a6-114">Při zpracování elementu konkrétní jazyk, používá modul odpovídajícím metodou greedy; To znamená odpovídá co nejvíce vstupní řetězec jako to pravděpodobně možné.</span><span class="sxs-lookup"><span data-stu-id="645a6-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="645a6-115">Můžete ale také ukládá svůj stav po úspěšně odpovídající dílčí výraz.</span><span class="sxs-lookup"><span data-stu-id="645a6-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="645a6-116">Pokud odpovídající nakonec dojde k chybě, modul vrátit k uloženému stavu proto ji můžete vyzkoušet další shody.</span><span class="sxs-lookup"><span data-stu-id="645a6-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="645a6-117">Tento proces zrušení shodu úspěšně dílčí výraz tak, aby novější prvky jazyka v regulárním výrazu můžete také hledat shody se označuje jako *používání mechanismu zpětného navracení*.</span><span class="sxs-lookup"><span data-stu-id="645a6-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="645a6-118">NFA modulů pomocí mechanismu zpětného navracení k testování všech možných rozšíření regulárního výrazu v určitém pořadí a přijímat první shoda.</span><span class="sxs-lookup"><span data-stu-id="645a6-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="645a6-119">Protože tradiční modulem NFA vytvoří konkrétní rozšíření regulární výraz pro porovnání, můžete zachytit, dílčí výraz odpovídá a odpovídající zpětnými odkazy.</span><span class="sxs-lookup"><span data-stu-id="645a6-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="645a6-120">Ale protože tradiční NFA provided, ji můžou navštívit stejného stavu více než jednou Pokud dorazí stav prostřednictvím různých cest.</span><span class="sxs-lookup"><span data-stu-id="645a6-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="645a6-121">V důsledku toho může probíhat exponenciálně pomalu v nejhorším případě.</span><span class="sxs-lookup"><span data-stu-id="645a6-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="645a6-122">Protože tradiční modulem NFA přijímá první odpovídat ho najde, můžete také ponechat další (možná delší) odpovídá nezjištěné.</span><span class="sxs-lookup"><span data-stu-id="645a6-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="645a6-123">POSIX NFA moduly jsou podobné tradiční NFA modulů, s tím rozdílem, že nadále navracení, dokud se může zaručit, že se našel nejdelší shoda je to možné.</span><span class="sxs-lookup"><span data-stu-id="645a6-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="645a6-124">V důsledku toho je pomalejší než tradiční modulem NFA modulem POSIX NFA a při použití modulem POSIX NFA kratší shoda nelze upřednostnil před delší jeden změnou pořadí hledání navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="645a6-125">Tradiční NFA moduly jsou podporuje programátory, protože nabízí větší kontrolu nad shody než DFA nebo POSIX NFA motorů řetězců.</span><span class="sxs-lookup"><span data-stu-id="645a6-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="645a6-126">I když v nejhorším případě, že lze spustit pomalu, můžete řídit, je pro vyhledání shody v čase lineární nebo polynomické pomocí vzorce, které snížit nejednoznačnosti a omezit používání mechanismu navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="645a6-127">Jinými slovy i když NFA moduly obchodu výkonu pro výkon, flexibilitu a ve většině případů, které nabízejí dobrý přijatelný výkon, pokud je kvalitně napsané regulárního výrazu a přitom vylučuje případy, kdy používání mechanismu zpětného navracení snižuje výkon exponenciálně zvyšuje.</span><span class="sxs-lookup"><span data-stu-id="645a6-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="645a6-128">Informace o snížení výkonu způsobené nadměrného používání mechanismu navracení a způsoby, jak si poradit regulární výraz je obejít, najdete v tématu [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="645a6-129">Možnosti modulu rozhraní .NET framework</span><span class="sxs-lookup"><span data-stu-id="645a6-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="645a6-130">Abyste mohli využívat výhody tradičního modulem NFA, modul regulárních výrazů rozhraní .NET Framework zahrnuje kompletní sadu konstrukty, které umožňují programátorům řídit modul navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="645a6-131">Tato konstrukce je možné, abyste rychleji odhalili shody nebo konkrétní rozšíření upřednostnil před ostatními.</span><span class="sxs-lookup"><span data-stu-id="645a6-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="645a6-132">Další funkce modulu regulárních výrazů rozhraní .NET Framework patří:</span><span class="sxs-lookup"><span data-stu-id="645a6-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="645a6-133">Líné kvantifikátory: `??`, `*?`, `+?`, `{` *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="645a6-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="645a6-134">Tyto konstrukce řekněte modul navracení k vyhledání nejprve minimální počet opakování.</span><span class="sxs-lookup"><span data-stu-id="645a6-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="645a6-135">Běžnou metodou greedy kvantifikátory naproti tomu pokusí nejprve srovnat maximální počet opakování.</span><span class="sxs-lookup"><span data-stu-id="645a6-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="645a6-136">Následující příklad ukazuje rozdíl mezi nimi.</span><span class="sxs-lookup"><span data-stu-id="645a6-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="645a6-137">Regulární výraz odpovídá věty, které končí na číslo a zachytávající skupina slouží k extrakci tohoto čísla.</span><span class="sxs-lookup"><span data-stu-id="645a6-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="645a6-138">Regulární výraz `.+(\d+)\.` zahrnuje kvantifikátor greedy `.+`, což způsobí, že modul regulárních výrazů k zachycení pouze poslední číslice čísla.</span><span class="sxs-lookup"><span data-stu-id="645a6-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="645a6-139">Naproti tomu regulárního výrazu `.+?(\d+)\.` zahrnuje opožděným kvantifikátorem `.+?`, což způsobí, že modul regulárních výrazů k zachycení celé číslo.</span><span class="sxs-lookup"><span data-stu-id="645a6-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="645a6-140">Jsou definovány greedy a opožděné verze tohoto regulárního výrazu, jak je znázorněno v následující tabulce. "</span><span class="sxs-lookup"><span data-stu-id="645a6-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="645a6-141">Vzor</span><span class="sxs-lookup"><span data-stu-id="645a6-141">Pattern</span></span>|<span data-ttu-id="645a6-142">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="645a6-143">`.+` (greedy kvantifikátor)</span><span class="sxs-lookup"><span data-stu-id="645a6-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="645a6-144">Porovná jeden výskyt libovolného znaku.</span><span class="sxs-lookup"><span data-stu-id="645a6-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="645a6-145">To způsobí, že modul regulárních výrazů tak, aby odpovídaly celý řetězec a pak navracení jako potřeby tak, aby odpovídala zůstatek vzor.</span><span class="sxs-lookup"><span data-stu-id="645a6-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="645a6-146">`.+?` (opožděným kvantifikátorem)</span><span class="sxs-lookup"><span data-stu-id="645a6-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="645a6-147">Odpovídá alespoň jeden výskyt jakéhokoliv znaku, ale odpovídá co nejméně.</span><span class="sxs-lookup"><span data-stu-id="645a6-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="645a6-148">Odpovídá alespoň jednu číslici a přiřaďte ho k první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="645a6-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="645a6-149">Porovná tečku.</span><span class="sxs-lookup"><span data-stu-id="645a6-149">Match a period.</span></span>|  
  
     <span data-ttu-id="645a6-150">Další informace o líné kvantifikátory, naleznete v tématu [kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-151">Pozitivního dopředného vyhledávání: `(?=` *dílčí výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="645a6-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="645a6-152">Tato funkce umožňuje vrátit na stejné místo v textu po odpovídající dílčí výraz modulu navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="645a6-153">To je užitečné pro vyhledávání v rámci text tak, že ověříte více vzorům, které začínají na stejné pozici.</span><span class="sxs-lookup"><span data-stu-id="645a6-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="645a6-154">Umožňuje také modulu ověřte, zda je dílčí řetězec existuje na konci porovnávání bez zahrnutí podřetězec v odpovídající text.</span><span class="sxs-lookup"><span data-stu-id="645a6-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="645a6-155">Následující příklad používá k extrakci slova ve větě, která nejsou následovány interpunkčních znamének pozitivního dopředného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="645a6-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="645a6-156">Regulární výraz `\b[A-Z]+\b(?=\P{P})` je definován, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="645a6-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="645a6-157">Vzor</span><span class="sxs-lookup"><span data-stu-id="645a6-157">Pattern</span></span>|<span data-ttu-id="645a6-158">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="645a6-159">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="645a6-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="645a6-160">Porovná libovolný znak abecedy jednou nebo vícekrát.</span><span class="sxs-lookup"><span data-stu-id="645a6-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="645a6-161">Protože <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možnost, při porovnávání se velká a malá písmena.</span><span class="sxs-lookup"><span data-stu-id="645a6-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="645a6-162">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="645a6-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="645a6-163">Dívejte se k určení, zda je další znak interpunkčním znaménkem.</span><span class="sxs-lookup"><span data-stu-id="645a6-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="645a6-164">Pokud není, bude úspěšná shoda.</span><span class="sxs-lookup"><span data-stu-id="645a6-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="645a6-165">Další informace o kontrolní výrazy pozitivního dopředného vyhledávání najdete v tématu [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-166">Negativního dopředného vyhledávání s: `(?!` *dílčí výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="645a6-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="645a6-167">Tato funkce přidává možnost tak, aby odpovídaly výraz pouze v případě, že dílčí výraz selže při porovnávání.</span><span class="sxs-lookup"><span data-stu-id="645a6-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="645a6-168">To je zvláště efektivní při vyřazování vyhledávání, protože často je jednodušší zajistit výrazu pro případ, který by měly být odstraněny než výrazu pro případy, které musí být zahrnut.</span><span class="sxs-lookup"><span data-stu-id="645a6-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="645a6-169">Například je obtížné je napsat výraz slova, která nezačínají "jiné".</span><span class="sxs-lookup"><span data-stu-id="645a6-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="645a6-170">Následující příklad používá negativního dopředného vyhledávání s vyloučit.</span><span class="sxs-lookup"><span data-stu-id="645a6-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="645a6-171">Vzor regulárního výrazu `\b(?!non)\w+\b` je definován, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="645a6-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="645a6-172">Vzor</span><span class="sxs-lookup"><span data-stu-id="645a6-172">Pattern</span></span>|<span data-ttu-id="645a6-173">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="645a6-174">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="645a6-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="645a6-175">Dívejte se a zkontrolujte, že aktuální řetězec nezačíná řetězcem "jiné".</span><span class="sxs-lookup"><span data-stu-id="645a6-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="645a6-176">Pokud tomu tak, shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="645a6-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="645a6-177">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="645a6-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="645a6-178">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="645a6-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="645a6-179">Další informace o kontrolní výrazy dopředného vyhledávání záporný, naleznete v tématu [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-180">Vyhodnocení podmíněného: `(?(` *výraz*`)`*Ano*`|`*žádné* `)` a `(?(` *název*`)`*Ano*`|`*žádné*`)`, kde *výraz* je dílčí výraz tak, aby odpovídaly, *název* je název zachytávající skupiny *Ano* je řetězec, který se shodují, pokud *výraz* je nalezena shoda nebo *název* je platný, zachycené skupiny není prázdná, a *žádné* je dílčí výraz pro porovnání, pokud *výraz* neodpovídá nebo *název* není platné, prázdný zachycené skupině.</span><span class="sxs-lookup"><span data-stu-id="645a6-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="645a6-181">Tato funkce umožňuje modulu pro vyhledávání s použitím více než jeden alternativní vzorek, v závislosti na výsledek předchozí dílčí výraz porovnání nebo výsledek kontrolní výraz nulové šířky.</span><span class="sxs-lookup"><span data-stu-id="645a6-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="645a6-182">Díky tomu zvyšují efektivitu formu zpětný odkaz, který umožňuje například odpovídající dílčí výraz na základě na, jestli byl předchozí dílčí výraz odpovídá.</span><span class="sxs-lookup"><span data-stu-id="645a6-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="645a6-183">Regulární výraz v následujícím příkladu odpovídá odstavců, které jsou určeny k použití veřejné a vnitřní.</span><span class="sxs-lookup"><span data-stu-id="645a6-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="645a6-184">Začínat odstavců určené pouze pro interní použití `<PRIVATE>` značky.</span><span class="sxs-lookup"><span data-stu-id="645a6-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="645a6-185">Vzor regulárního výrazu `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` používá vyhodnocení podmíněného přiřadit obsah odstavců určených pro veřejnost a pro interní použití k oddělení zachytávajících skupinách.</span><span class="sxs-lookup"><span data-stu-id="645a6-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="645a6-186">Těchto odstavcích můžete pak zpracovány jinak.</span><span class="sxs-lookup"><span data-stu-id="645a6-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="645a6-187">Vzor regulárního výrazu je definován, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="645a6-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="645a6-188">Vzor</span><span class="sxs-lookup"><span data-stu-id="645a6-188">Pattern</span></span>|<span data-ttu-id="645a6-189">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="645a6-190">Zahájí porovnávání na začátku řádku.</span><span class="sxs-lookup"><span data-stu-id="645a6-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="645a6-191">Porovná žádný nebo jeden výskyt řetězce `<PRIVATE>` následované prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="645a6-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="645a6-192">Přiřadit ke shodě zachytávající skupina s názvem `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="645a6-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="645a6-193">Pokud `Pvt` zachycující skupina existuje, porovná jeden nebo více výskytů jednoho nebo více znaků slova, následované žádnou nebo jednu oddělovač interpunkční znaménka, následované prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="645a6-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="645a6-194">Přiřadíte podřetězec první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="645a6-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))<code>|<span data-ttu-id="645a6-195">Pokud `Pvt` zachycující skupina neexistuje, odpovídat jedné nebo více výskytů jednoho nebo více znaků slova, následované žádnou nebo jednu oddělovač interpunkční znaménka, následované prázdným znakem.</span><span class="sxs-lookup"><span data-stu-id="645a6-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="645a6-196">Podřetězec přiřadíte třetí zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="645a6-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="645a6-197">Porovná konec řádku nebo konec řetězce.</span><span class="sxs-lookup"><span data-stu-id="645a6-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="645a6-198">Další informace o vyhodnocení podmíněného najdete v tématu [alternace](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-199">Definice skupiny vyrovnávání: `(?<` *name1*`-`*name2* `>` *dílčí výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="645a6-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="645a6-200">Tato funkce umožňuje modulu regulárních výrazů ke sledování vnořené konstrukce, jako je například závorky nebo levé a pravé hranaté závorky.</span><span class="sxs-lookup"><span data-stu-id="645a6-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="645a6-201">Příklad najdete v tématu [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-202">Podvýrazy bez mechanismu navracení (označovaný také jako greedy podvýrazy): `(?>` *dílčí výraz*`)`.</span><span class="sxs-lookup"><span data-stu-id="645a6-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="645a6-203">Tato funkce umožňuje zajistit, že dílčí výraz odpovídá pouze první shoda pro tento dílčí výraz se nenašly jako kdyby byly spuštěné výraz nezávisle na jeho obsahujícího výrazu modulu navracení.</span><span class="sxs-lookup"><span data-stu-id="645a6-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="645a6-204">Pokud nepoužijete tento konstruktor, navracení vyhledávání z rozsáhlejšího výrazu můžete změnit chování podvýrazu.</span><span class="sxs-lookup"><span data-stu-id="645a6-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="645a6-205">Například regulární výraz `(a+)\w` odpovídá jedné nebo více znaků "a, spolu s znaku slova, která odpovídá sekvenci znaků"a"a přiřadí pořadí znaků"a"první zachytávající skupina, ale" pokud poslední znak vstupní řetězec je také "a", it, který odpovídá `\w` prvek jazyka a není součástí zachycenou skupinou.</span><span class="sxs-lookup"><span data-stu-id="645a6-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="645a6-206">Regulární výraz `((?>a+))\w` brání toto chování.</span><span class="sxs-lookup"><span data-stu-id="645a6-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="645a6-207">Protože všechny po sobě jdoucích znaků "a" jsou porovnány bez mechanismu navracení, první zachytávající skupina obsahuje všechny po sobě jdoucích znaků "a".</span><span class="sxs-lookup"><span data-stu-id="645a6-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="645a6-208">Pokud se alespoň jeden další znak jiný než "a" nejsou následovány znaky "a", shoda se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="645a6-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="645a6-209">Další informace o podvýrazy bez mechanismu navracení najdete v tématu [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="645a6-210">Doleva porovnávání, který je zadán zadáním <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> umožňuje <xref:System.Text.RegularExpressions.Regex> konstruktoru třídy nebo statické odpovídající metodu instance.</span><span class="sxs-lookup"><span data-stu-id="645a6-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="645a6-211">Tato funkce je užitečná při vyhledávání zprava doleva namísto zleva doprava, nebo v případech, kdy je efektivnější zahájit porovnávání na pravou část vzoru místo vlevo.</span><span class="sxs-lookup"><span data-stu-id="645a6-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="645a6-212">Jak ukazuje následující příklad pomocí odpovídající zprava doleva můžete změnit chování greedy kvantifikátory.</span><span class="sxs-lookup"><span data-stu-id="645a6-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="645a6-213">Příklad provádí dvě vyhledá věty, které končí na číslo.</span><span class="sxs-lookup"><span data-stu-id="645a6-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="645a6-214">Hledání zleva doprava, který používá greedy kvantifikátor `+` shoduje s jedním z šesti číslic ve větě, že hledání zprava doleva odpovídá všech šesti číslic.</span><span class="sxs-lookup"><span data-stu-id="645a6-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="645a6-215">Popis vzor regulárního výrazu prohlédněte si příklad znázorňuje líné kvantifikátory uvedené v této části.</span><span class="sxs-lookup"><span data-stu-id="645a6-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="645a6-216">Další informace o odpovídajících zprava doleva, naleznete v tématu [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="645a6-217">Kladné a záporné zpětného vyhledávání: `(?<=` *dílčí výraz* `)` pro pozitivního zpětného vyhledávání, a `(?<!` *dílčí výraz* `)` pro negativního zpětného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="645a6-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="645a6-218">Tato funkce je podobný s dopředným vyhledáváním, která je popsána výše v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="645a6-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="645a6-219">Protože modul regulárních výrazů umožňuje kompletní odpovídající zprava doleva, regulární výrazy umožňují kontrolu neomezený dozadu.</span><span class="sxs-lookup"><span data-stu-id="645a6-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="645a6-220">Kladné a záporné zpětného vyhledávání také umožňuje vyhnout se vnoření kvantifikátory při vnořené dílčí výraz je nadstavbou jazyka vnější výraz.</span><span class="sxs-lookup"><span data-stu-id="645a6-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="645a6-221">Regulární výrazy pouze za těchto vnořených kvantifikátorů často nabízejí nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="645a6-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="645a6-222">Například následující příklad ověří, že řetězec začíná a končí u alfanumerickým znakem a že jakýkoli jiný znak v řetězci je jedním z větších dílčí.</span><span class="sxs-lookup"><span data-stu-id="645a6-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="645a6-223">Tvoří část regulární výraz používaný k ověření e-mailové adresy; Další informace najdete v tématu [jak: Ověřte, zda jsou řetězce ve formátu platné e-mailové](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="645a6-224">Regulární výraz `^[A-Z0-9]([-!#$%&'.*+/=?^` {}| ~ \w])\* (? < = [A-Z0-9]) $' je definován, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="645a6-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="645a6-225">Vzor</span><span class="sxs-lookup"><span data-stu-id="645a6-225">Pattern</span></span>|<span data-ttu-id="645a6-226">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="645a6-227">Zahájí porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="645a6-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="645a6-228">Odpovídá jakémukoli znaku číselné nebo alfanumerické znaky.</span><span class="sxs-lookup"><span data-stu-id="645a6-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="645a6-229">(Při porovnávání se velká a malá písmena.)</span><span class="sxs-lookup"><span data-stu-id="645a6-229">(The comparison is case-insensitive.)</span></span>|  
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])*<code>|Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., *, +, /, =, ?, ^, \`, {, }, &#124;, or ~.|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="645a6-230">Podívá se za předchozí znak, který musí být číselné nebo alfanumerické znaky.</span><span class="sxs-lookup"><span data-stu-id="645a6-230">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="645a6-231">(Při porovnávání se velká a malá písmena.)</span><span class="sxs-lookup"><span data-stu-id="645a6-231">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="645a6-232">Ukončit porovnávání na konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="645a6-232">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="645a6-233">Další informace o kladné a záporné zpětného vyhledávání najdete v tématu [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="645a6-233">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="645a6-234">Související témata</span><span class="sxs-lookup"><span data-stu-id="645a6-234">Related Topics</span></span>  
  
|<span data-ttu-id="645a6-235">Název</span><span class="sxs-lookup"><span data-stu-id="645a6-235">Title</span></span>|<span data-ttu-id="645a6-236">Popis</span><span class="sxs-lookup"><span data-stu-id="645a6-236">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="645a6-237">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="645a6-237">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="645a6-238">Poskytuje informace o způsobu regulárních výrazů mechanismus navracení větví můžete najít alternativní shody.</span><span class="sxs-lookup"><span data-stu-id="645a6-238">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="645a6-239">Kompilace a opětovné používání</span><span class="sxs-lookup"><span data-stu-id="645a6-239">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="645a6-240">Poskytuje informace o kompilaci a opětovné použití regulárních výrazů ke zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="645a6-240">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="645a6-241">Bezpečnost vlákna</span><span class="sxs-lookup"><span data-stu-id="645a6-241">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="645a6-242">Poskytuje informace o zabezpečení vlákna regulárního výrazu a vysvětluje, kdy bude třeba synchronizovat přístup k objektům regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="645a6-242">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="645a6-243">Regulárních výrazech .NET Frameworku</span><span class="sxs-lookup"><span data-stu-id="645a6-243">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="645a6-244">Poskytuje přehled o programovací jazyk aspekt regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="645a6-244">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="645a6-245">Model objektu regulárního výrazu</span><span class="sxs-lookup"><span data-stu-id="645a6-245">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="645a6-246">Poskytuje informace a příklady kódu znázorňující způsob používání tříd regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="645a6-246">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="645a6-247">Příklady regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="645a6-247">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="645a6-248">Obsahuje příklady kódu, které ilustrují použití regulárních výrazů v běžných aplikací.</span><span class="sxs-lookup"><span data-stu-id="645a6-248">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="645a6-249">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="645a6-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="645a6-250">Poskytuje informace o sadě znaků, operátorů a konstrukcí, které můžete použít pro definování regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="645a6-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="645a6-251">Odkaz</span><span class="sxs-lookup"><span data-stu-id="645a6-251">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
