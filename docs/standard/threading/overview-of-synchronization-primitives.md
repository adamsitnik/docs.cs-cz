---
title: Přehled primitiv synchronizace
description: Přečtěte si o primitivech synchronizace vláken .NET používaných k synchronizaci přístupu ke sdílenému vláknu nebo k interakci řídicího vlákna.
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 31d5df6521b7c420943a7d3d0efcf6e4bee2d3a2
ms.sourcegitcommit: cdf67135a98a5a51913dacddb58e004a3c867802
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/21/2019
ms.locfileid: "69666280"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="0c0c3-103">Přehled primitiv synchronizace</span><span class="sxs-lookup"><span data-stu-id="0c0c3-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="0c0c3-104">Rozhraní .NET poskytuje rozsah typů, které můžete použít k synchronizaci přístupu ke sdílenému prostředku nebo k interakci s vlákny pro koordinaci.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0c0c3-105">Pro ochranu přístupu ke sdílenému prostředku použijte stejnou instanci primitiva synchronizace.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="0c0c3-106">Pokud k ochraně stejného prostředku používáte různé primitivní instance synchronizace, obejít ochranu poskytovanou primitivním primitivem.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="0c0c3-107">Třídy WaitHandle a zjednodušené typy synchronizace</span><span class="sxs-lookup"><span data-stu-id="0c0c3-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="0c0c3-108">Několik primitiv synchronizace rozhraní .NET je odvozeno <xref:System.Threading.WaitHandle?displayProperty=nameWithType> od třídy, která zapouzdřuje nativní popisovač synchronizace operačního systému a používá mechanismus signalizace pro interakci s vlákny.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="0c0c3-109">Tyto třídy zahrnují:</span><span class="sxs-lookup"><span data-stu-id="0c0c3-109">Those classes include:</span></span>

- <span data-ttu-id="0c0c3-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, který uděluje exkluzivní přístup ke sdílenému prostředku.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="0c0c3-111">Stav mutex je signalizována, pokud není vlastníkem vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="0c0c3-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, což omezuje počet vláken, která mají souběžný přístup ke sdílenému prostředku nebo fondu prostředků.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="0c0c3-113">Stav semaforu je nastaven na signalizaci, pokud je jeho počet větší než nula a nesignálný, pokud je jeho počet nula.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="0c0c3-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, který představuje událost synchronizace vlákna a může být buď v signalizačním, nebo nesignalizacém stavu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="0c0c3-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, která je odvozena <xref:System.Threading.EventWaitHandle> z a, při signalizaci, je automaticky nastavena na nesignálný stav po uvolnění jediného čekajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="0c0c3-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, která je odvozena <xref:System.Threading.EventWaitHandle> z a, je-li signalizována, zůstane v signalizačním stavu, <xref:System.Threading.EventWaitHandle.Reset%2A> dokud není volána metoda.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="0c0c3-117">V .NET Framework, vzhledem k <xref:System.Threading.WaitHandle> tomu, že <xref:System.MarshalByRefObject?displayProperty=nameWithType>jsou odvozeny z, lze tyto typy použít k synchronizaci aktivit vláken napříč hranicemi aplikační domény.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="0c0c3-118">V .NET Framework a .NET Core mohou některé z těchto typů představovat pojmenované popisovače synchronizace systému, které jsou viditelné v celém operačním systému a lze je použít pro synchronizaci mezi procesy:</span><span class="sxs-lookup"><span data-stu-id="0c0c3-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="0c0c3-119"><xref:System.Threading.Mutex>(.NET Framework a .NET Core),</span><span class="sxs-lookup"><span data-stu-id="0c0c3-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="0c0c3-120"><xref:System.Threading.Semaphore>(.NET Framework a .NET Core ve Windows),</span><span class="sxs-lookup"><span data-stu-id="0c0c3-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="0c0c3-121"><xref:System.Threading.EventWaitHandle>(.NET Framework a .NET Core ve Windows).</span><span class="sxs-lookup"><span data-stu-id="0c0c3-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="0c0c3-122">Další informace najdete v referenčních <xref:System.Threading.WaitHandle> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="0c0c3-123">Odlehčené typy synchronizace nespoléhají na základní obslužné rutiny operačního systému a obvykle poskytují lepší výkon.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="0c0c3-124">Nelze je však použít pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="0c0c3-125">Tyto typy použijte pro synchronizaci vláken v rámci jedné aplikace.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="0c0c3-126">Některé z těchto typů jsou alternativy k typům odvozeným <xref:System.Threading.WaitHandle>z.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0c0c3-127">Například <xref:System.Threading.SemaphoreSlim> je odlehčená alternativa k <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="0c0c3-128">Synchronizace přístupu ke sdílenému prostředku</span><span class="sxs-lookup"><span data-stu-id="0c0c3-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="0c0c3-129">.NET poskytuje řadu synchronizačních primitiv pro řízení přístupu ke sdílenému prostředku více vlákny.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="0c0c3-130">Monitor – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-130">Monitor class</span></span>

<span data-ttu-id="0c0c3-131"><xref:System.Threading.Monitor?displayProperty=nameWithType> Třída uděluje vzájemně exkluzivní přístup ke sdílenému prostředku získáním nebo uvolněním zámku objektu, který identifikuje prostředek.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="0c0c3-132">I když je držen zámek, vlákno, které obsahuje zámek, může znovu načíst a uvolnit zámek.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="0c0c3-133">Jakékoli jiné vlákno zablokovalo získání zámku a <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metoda počká, dokud se zámek neuvolní.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="0c0c3-134"><xref:System.Threading.Monitor.Enter%2A> Metoda získá uvolněný zámek.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="0c0c3-135">Můžete také použít <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> metodu k určení doby, během které se vlákno pokusí získat zámek.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="0c0c3-136">Vzhledem k <xref:System.Threading.Monitor> tomu, že třída má spřažení vláken, vlákno, které získalo zámek, musí uvolnit zámek <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> voláním metody.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="0c0c3-137">Můžete koordinovat interakci vláken, která získají zámek na stejném objektu pomocí <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>metod, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>a <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="0c0c3-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="0c0c3-138">Další informace najdete v referenčních <xref:System.Threading.Monitor> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="0c0c3-139">Použijte příkaz [Lock](../../csharp/language-reference/keywords/lock-statement.md) v C# a příkaz [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) v Visual Basic pro synchronizaci přístupu ke sdílenému <xref:System.Threading.Monitor> prostředku místo přímého použití třídy.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="0c0c3-140">Tyto příkazy jsou implementovány pomocí <xref:System.Threading.Monitor.Enter%2A> metod a <xref:System.Threading.Monitor.Exit%2A> a `try…finally` bloku, aby bylo zajištěno, že se načtený zámek vždy uvolňuje.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="0c0c3-141">Mutex – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-141">Mutex class</span></span>

<span data-ttu-id="0c0c3-142"><xref:System.Threading.Mutex?displayProperty=nameWithType> Třída ,například,udělujeexkluzivnípřístup<xref:System.Threading.Monitor>ke sdílenému prostředku.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="0c0c3-143">Použijte jedno z přetížení metod [mutex. WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) pro vyžádání vlastnictví mutexu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="0c0c3-144">Podobně <xref:System.Threading.Monitor>jako <xref:System.Threading.Mutex> , má spřažení vlákna a vlákno, které získalo mutex, musí <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> uvolnit voláním metody.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="0c0c3-145"><xref:System.Threading.Monitor> Na<xref:System.Threading.Mutex> rozdíl od, třída může být použita pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="0c0c3-146">K tomu použijte pojmenovaný mutex, který je viditelný v celém operačním systému.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="0c0c3-147">Chcete-li vytvořit pojmenovanou instanci mutex, použijte [konstruktor Mutex](<xref:System.Threading.Mutex.%23ctor%2A>) , který určuje název.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="0c0c3-148">Můžete také zavolat <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> metodu a otevřít existující objekt mutex s názvem systému.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="0c0c3-149">Další informace najdete v článku věnovaném [mutexům](mutexes.md) a v <xref:System.Threading.Mutex> referenčních informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="0c0c3-150">Struktura struktuře SpinLock</span><span class="sxs-lookup"><span data-stu-id="0c0c3-150">SpinLock structure</span></span>

<span data-ttu-id="0c0c3-151">Struktura, jako <xref:System.Threading.Monitor>je, uděluje exkluzivní přístup ke sdílenému prostředku na základě dostupnosti zámku. <xref:System.Threading.SpinLock?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0c0c3-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="0c0c3-152">Když <xref:System.Threading.SpinLock> se pokusí získat zámek, který není k dispozici, čeká ve smyčce a opakovaně kontroluje, dokud zámek nebude k dispozici.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="0c0c3-153">Další informace o výhodách a nevýhodách použití zámku získáte v článku [struktuře SpinLock](spinlock.md) a v referenčních informacích k <xref:System.Threading.SpinLock> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="0c0c3-154">ReaderWriterLockSlim – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="0c0c3-155"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> Třída uděluje exkluzivní přístup ke sdílenému prostředku pro zápis a umožňuje více vláknům přistupovat ke zdroji současně pro čtení.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="0c0c3-156">Můžete chtít použít <xref:System.Threading.ReaderWriterLockSlim> pro synchronizaci přístupu ke sdílené datové struktuře, která podporuje operace čtení bezpečné pro přístup z více vláken, ale vyžaduje výhradní přístup k provádění operací zápisu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="0c0c3-157">Když vlákno požaduje výhradní přístup (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> metody), pak další požadavky na čtečku a zapisovač, dokud všichni stávající čtenáři neukončí zámek, a zapisovač zadal a ukončil zámek.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="0c0c3-158">Další informace najdete v referenčních <xref:System.Threading.ReaderWriterLockSlim> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="0c0c3-159">Semafor a třídy SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="0c0c3-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="0c0c3-160">Třídy <xref:System.Threading.Semaphore?displayProperty=nameWithType> a<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> omezují počet vláken, která mají souběžný přístup ke sdílenému prostředku nebo fondu prostředků.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="0c0c3-161">Další vlákna, která vyžádají prostředek, počkejte, dokud jakékoli vlákno neuvolní semafor.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="0c0c3-162">Vzhledem k tomu, že semafor nemá spřažení vláken, vlákno může získat semafor a další ho může uvolnit.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="0c0c3-163"><xref:System.Threading.SemaphoreSlim>je odlehčená alternativa <xref:System.Threading.Semaphore> k a lze ji použít pouze pro synchronizaci v rámci jedné hranice procesu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="0c0c3-164">Ve Windows můžete použít <xref:System.Threading.Semaphore> pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="0c0c3-165">K tomu je třeba vytvořit <xref:System.Threading.Semaphore> instanci, která představuje pojmenovaný systémový semafor pomocí jednoho z konstruktorů [semaforu](<xref:System.Threading.Semaphore.%23ctor%2A>) , který určuje název nebo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0c0c3-166"><xref:System.Threading.SemaphoreSlim>nepodporuje pojmenované systémové semafory.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="0c0c3-167">Další informace najdete v článku [semafor a SemaphoreSlim](semaphore-and-semaphoreslim.md) a v referenčních <xref:System.Threading.Semaphore> informacích k <xref:System.Threading.SemaphoreSlim> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="0c0c3-168">Interakce vlákna nebo signalizace</span><span class="sxs-lookup"><span data-stu-id="0c0c3-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="0c0c3-169">Interakce vlákna (nebo signalizace vlákna) znamená, že vlákno musí čekat na oznámení nebo signál, z jednoho nebo více vláken, aby bylo možné pokračovat.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="0c0c3-170">Například pokud vlákno a volá <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> metodu vlákna B, vlákno a je blokováno, dokud vlákno b nedokončí.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="0c0c3-171">Prvky synchronizace popsané v předchozí části poskytují jiný mechanismus pro signalizaci: uvolněním zámku vlákno upozorní jiné vlákno, že může pokračovat získáním zámku.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="0c0c3-172">Tato část popisuje další konstrukce signalizace poskytované rozhraním .NET.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="0c0c3-173">Třídy EventWaitHandle, AutoResetEvent, ManualResetEvent a ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="0c0c3-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="0c0c3-174"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> Třída představuje událost synchronizace vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="0c0c3-175">Událost synchronizace může být buď v nesignalizacém, nebo ve stavu signalizace.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="0c0c3-176">Při nesignalizaci stavu události je vlákno, které volá <xref:System.Threading.WaitHandle.WaitOne%2A?> přetížení události, blokováno, dokud událost není signalizována.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="0c0c3-177"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Metoda nastaví stav události k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="0c0c3-178">Chování <xref:System.Threading.EventWaitHandle> , které bylo signalizaci, závisí na režimu obnovení:</span><span class="sxs-lookup"><span data-stu-id="0c0c3-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="0c0c3-179"><xref:System.Threading.EventWaitHandle> Vytvořený<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> pomocí příznaku se automaticky obnoví po uvolnění jediného čekajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="0c0c3-180">Vypadá to jako Turnstile, který umožňuje pouze jedno vlákno přes pokaždé, když je signál.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="0c0c3-181">Třída, která je odvozena z <xref:System.Threading.EventWaitHandle>, představuje toto chování. <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0c0c3-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="0c0c3-182">Vytvořená pomocí příznaku zůstane signalizována do chvíle <xref:System.Threading.EventWaitHandle.Reset%2A> , kdy se zavolá jeho metoda. <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> <xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="0c0c3-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="0c0c3-183">Je to jako brána, která je zavřená, dokud není signalizována, a pak zůstane otevřená, dokud ji někdo neuzavře.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="0c0c3-184">Třída, která je odvozena z <xref:System.Threading.EventWaitHandle>, představuje toto chování. <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0c0c3-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="0c0c3-185">Třída je odlehčená alternativa k <xref:System.Threading.ManualResetEvent>. <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0c0c3-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="0c0c3-186">Ve Windows můžete použít <xref:System.Threading.EventWaitHandle> pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="0c0c3-187">K tomu je třeba vytvořit <xref:System.Threading.EventWaitHandle> instanci, která představuje pojmenovanou událost synchronizace systému pomocí jednoho z konstruktorů [EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) , které určují název nebo <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="0c0c3-188">Další informace najdete v článku [EventWaitHandle](eventwaithandle.md) .</span><span class="sxs-lookup"><span data-stu-id="0c0c3-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="0c0c3-189">Referenční informace k rozhraní API naleznete <xref:System.Threading.EventWaitHandle>v <xref:System.Threading.AutoResetEvent>tématech <xref:System.Threading.ManualResetEvent>,, <xref:System.Threading.ManualResetEventSlim>a.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="0c0c3-190">CountdownEvent – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-190">CountdownEvent class</span></span>

<span data-ttu-id="0c0c3-191"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> Třída představuje událost, která se nastaví, když je její počet nula.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="0c0c3-192">Zatímco <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> je větší než nula, vlákno, které volá <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> , je blokované.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="0c0c3-193">Volání <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> k odečtení počtu událostí.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="0c0c3-194">Na rozdíl <xref:System.Threading.ManualResetEvent> od nebo <xref:System.Threading.ManualResetEventSlim>, které lze použít k odblokování více vláken pomocí signálu z jednoho vlákna, můžete použít <xref:System.Threading.CountdownEvent> k odblokování jednoho nebo více podprocesů s signály z více vláken.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="0c0c3-195">Další informace najdete v článku [CountdownEvent](countdownevent.md) a v referenčních <xref:System.Threading.CountdownEvent> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="0c0c3-196">Bariéra – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-196">Barrier class</span></span>

<span data-ttu-id="0c0c3-197"><xref:System.Threading.Barrier?displayProperty=nameWithType> Třída představuje bariéru spuštění vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="0c0c3-198">Vlákno, které volá <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> metodu, signalizuje, že dosáhla bariéry a čeká, dokud ostatní vlákna účastníka dosáhnou bariéry.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="0c0c3-199">Když všechna vlákna účastníka dosáhnou bariéry, budou pokračovat a bariéra se resetuje a dá se použít znovu.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="0c0c3-200">V případě, <xref:System.Threading.Barrier> že jeden nebo více vláken vyžaduje výsledky jiných vláken, než budete pokračovat do další fáze výpočtu, můžete použít.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="0c0c3-201">Další informace najdete v článku o [bariérách](barrier.md) a v <xref:System.Threading.Barrier> referenčních informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="0c0c3-202">Interlocked – třída</span><span class="sxs-lookup"><span data-stu-id="0c0c3-202">Interlocked class</span></span>

<span data-ttu-id="0c0c3-203"><xref:System.Threading.Interlocked?displayProperty=nameWithType> Třída poskytuje statické metody, které provádějí jednoduché atomické operace na proměnné.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="0c0c3-204">Tyto atomické operace zahrnují sčítání, zvýšení a snížení, Exchange a podmíněný Exchange, které závisí na porovnání a operace čtení z 64 celočíselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="0c0c3-205">Další informace najdete v referenčních <xref:System.Threading.Interlocked> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="0c0c3-206">Struktura objektu SpinWait</span><span class="sxs-lookup"><span data-stu-id="0c0c3-206">SpinWait structure</span></span>

<span data-ttu-id="0c0c3-207"><xref:System.Threading.SpinWait?displayProperty=nameWithType> Struktura poskytuje podporu pro čekání na číselník.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="0c0c3-208">Můžete ji chtít použít, když vlákno musí počkat na signalizaci události nebo podmínku, která má být splněna, ale pokud se očekává, že doba čekání bude menší než čekací doba potřebná při použití popisovače čekání nebo jiným způsobem blokování vlákna.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="0c0c3-209">Pomocí <xref:System.Threading.SpinWait>můžete zadat krátkou dobu, kdy se má při čekání čekat, a pak (například čekáním nebo v režimu spánku), a to pouze v případě, že v určeném čase nebyla splněna podmínka.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="0c0c3-210">Další informace najdete v článku [objektu SpinWait](spinwait.md) a v referenčních <xref:System.Threading.SpinWait> informacích k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0c0c3-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="0c0c3-211">Viz také:</span><span class="sxs-lookup"><span data-stu-id="0c0c3-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="0c0c3-212">Kolekce bezpečné pro přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="0c0c3-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="0c0c3-213">Dělení objektů a funkcí</span><span class="sxs-lookup"><span data-stu-id="0c0c3-213">Threading objects and features</span></span>](threading-objects-and-features.md)
