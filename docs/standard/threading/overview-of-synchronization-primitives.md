---
title: Přehled primitiv synchronizace
description: Další informace o .NET vlákno synchronizací primitiv používá k synchronizaci přístupu k sdíleného prostředku nebo vlákna interakce ovládacího prvku
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 9faac620c98362c5f9f650121bb88b207ed4863b
ms.sourcegitcommit: 14355b4b2fe5bcf874cac96d0a9e6376b567e4c7
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/30/2019
ms.locfileid: "55270756"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="c0c11-103">Přehled primitiv synchronizace</span><span class="sxs-lookup"><span data-stu-id="c0c11-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="c0c11-104">.NET poskytuje celou řadu typů, které slouží k synchronizaci přístupu ke sdíleným prostředkům nebo koordinovat interakce vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c0c11-105">Použijte stejnou instanci primitivní synchronizace můžete chránit každý přístup ke sdíleným prostředkům.</span><span class="sxs-lookup"><span data-stu-id="c0c11-105">Use the same synchronization primitive instance to protect every access to a shared resource.</span></span> <span data-ttu-id="c0c11-106">Více vláken může současně přístup k prostředku, pokud používáte jiný synchronizace primitivní instance můžete chránit přístup k prostředku nebo některé části kódu, přímý přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="c0c11-106">Multiple threads can access a resource concurrently if you use different synchronization primitive instances to protect access to a resource or some parts of code access a resource directly.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="c0c11-107">Typy WaitHandle třídy a zjednodušené synchronizace</span><span class="sxs-lookup"><span data-stu-id="c0c11-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="c0c11-108">Více primitiv synchronizace .NET odvozovat <xref:System.Threading.WaitHandle?displayProperty=nameWithType> třídu, která zapouzdřuje popisovač synchronizace nativní operačního systému a používá signalizační mechanismus pro interakci vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="c0c11-109">Tyto třídy zahrnují:</span><span class="sxs-lookup"><span data-stu-id="c0c11-109">Those classes include:</span></span>

- <span data-ttu-id="c0c11-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, který uděluje exkluzivní přístup ke sdíleným prostředkům.</span><span class="sxs-lookup"><span data-stu-id="c0c11-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="c0c11-111">Stav objektu mutex je signál, pokud žádné vlákno jeho vlastníkem.</span><span class="sxs-lookup"><span data-stu-id="c0c11-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="c0c11-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, což omezuje souběžně počet vláken, které můžete přístup ke sdílenému prostředku nebo fond prostředků.</span><span class="sxs-lookup"><span data-stu-id="c0c11-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="c0c11-113">Stav semafor je nastaven do signalizovaného, pokud jeho je počet větší než nula a nonsignaled při její vlastnosti count je nula.</span><span class="sxs-lookup"><span data-stu-id="c0c11-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="c0c11-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, který představuje událost synchronizace vlákno a může být buď v unsignaled nebo signalizovaného stavu.</span><span class="sxs-lookup"><span data-stu-id="c0c11-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="c0c11-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, která je odvozena z <xref:System.Threading.EventWaitHandle> a při signalizován, obnoví automaticky unsignaled stavu po vydání jedním vláknem a čekání.</span><span class="sxs-lookup"><span data-stu-id="c0c11-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="c0c11-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, která je odvozena z <xref:System.Threading.EventWaitHandle> a při signalizován, pořád do signalizovaného stavu, dokud <xref:System.Threading.EventWaitHandle.Reset%2A> metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="c0c11-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="c0c11-117">V rozhraní .NET Framework protože <xref:System.Threading.WaitHandle> je odvozena z <xref:System.MarshalByRefObject?displayProperty=nameWithType>, tyto typy slouží k synchronizaci činností vlákna přes hranice aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="c0c11-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="c0c11-118">V rozhraní .NET Framework a .NET Core některé z těchto typů představují popisovače synchronizace s názvem systému, které jsou viditelné v celém operačním systému a je možné pro synchronizaci mezi procesy:</span><span class="sxs-lookup"><span data-stu-id="c0c11-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="c0c11-119"><xref:System.Threading.Mutex> (Rozhraní .NET framework a .NET Core)</span><span class="sxs-lookup"><span data-stu-id="c0c11-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="c0c11-120"><xref:System.Threading.Semaphore> (Rozhraní .NET framework a .NET Core ve Windows)</span><span class="sxs-lookup"><span data-stu-id="c0c11-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="c0c11-121"><xref:System.Threading.EventWaitHandle> (.NET framework a .NET Core ve Windows).</span><span class="sxs-lookup"><span data-stu-id="c0c11-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="c0c11-122">Další informace najdete v tématu <xref:System.Threading.WaitHandle> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="c0c11-123">Typy zjednodušené synchronizace není využívají podkladového popisovače operačního systému a obvykle poskytují lepší výkon.</span><span class="sxs-lookup"><span data-stu-id="c0c11-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="c0c11-124">Jsou však nelze použít pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="c0c11-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="c0c11-125">Pomocí těchto typů pro synchronizaci vláken v rámci jedné aplikace.</span><span class="sxs-lookup"><span data-stu-id="c0c11-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="c0c11-126">Některé z těchto typů jsou alternativy k typy odvozené od <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c0c11-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c0c11-127">Například <xref:System.Threading.SemaphoreSlim> zjednodušené alternativu, která umožňuje <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="c0c11-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="c0c11-128">Synchronizace přístup ke sdíleným prostředkům</span><span class="sxs-lookup"><span data-stu-id="c0c11-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="c0c11-129">.NET poskytuje celou řadu primitiv synchronizace pro řízení přístupu ke sdíleným prostředkům ve víc vláknech.</span><span class="sxs-lookup"><span data-stu-id="c0c11-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="c0c11-130">Monitor – třída</span><span class="sxs-lookup"><span data-stu-id="c0c11-130">Monitor class</span></span>

<span data-ttu-id="c0c11-131"><xref:System.Threading.Monitor?displayProperty=nameWithType> Třídy uděluje vzájemně vyloučený přístup ke sdíleným prostředkům získávání nebo uvolnění zámku na objektu, který identifikuje prostředek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="c0c11-132">Dokud je držen zámek, vlákna, která je držitelem zámku znovu získat a uvolní zámek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="c0c11-133">Jiné vlákno se blokuje získání zámku a <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metoda čeká na zámek je uvolněn.</span><span class="sxs-lookup"><span data-stu-id="c0c11-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="c0c11-134"><xref:System.Threading.Monitor.Enter%2A> Metoda získá vydané zámek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="c0c11-135">Můžete také použít <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> metody zadejte dobu, během které vlákno pokusy o získání zámku.</span><span class="sxs-lookup"><span data-stu-id="c0c11-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="c0c11-136">Protože <xref:System.Threading.Monitor> třída má spřažení vláken, vlákna, která se získat zámek nutné uvolnit zámek voláním <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="c0c11-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="c0c11-137">Můžete koordinovat interakce vlákna, která se pomocí získat zámek na stejný objekt <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, a <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c0c11-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="c0c11-138">Další informace najdete v tématu <xref:System.Threading.Monitor> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="c0c11-139">Použití [Zámek](../../csharp/language-reference/keywords/lock-statement.md) příkaz v jazyce C# a [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) v sadě Visual Studio k synchronizaci přístupu ke sdíleným prostředkům namísto použití <xref:System.Threading.Monitor> třídy přímo.</span><span class="sxs-lookup"><span data-stu-id="c0c11-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="c0c11-140">Tyto příkazy jsou implementovány pomocí <xref:System.Threading.Monitor.Enter%2A> a <xref:System.Threading.Monitor.Exit%2A> metody a `try…finally` blok k Ujistěte se, že pořízené zámek je uvolněn vždy.</span><span class="sxs-lookup"><span data-stu-id="c0c11-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="c0c11-141">Mutex – třída</span><span class="sxs-lookup"><span data-stu-id="c0c11-141">Mutex class</span></span>

<span data-ttu-id="c0c11-142"><xref:System.Threading.Mutex?displayProperty=nameWithType> Třídy, jako je třeba <xref:System.Threading.Monitor>, udělí se výhradní přístup ke sdíleným prostředkům.</span><span class="sxs-lookup"><span data-stu-id="c0c11-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="c0c11-143">Použijte jednu z [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) přetížení metody pro vlastnictví objektu mutex, na vyžádání.</span><span class="sxs-lookup"><span data-stu-id="c0c11-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="c0c11-144">Stejně jako <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> má spřažení vláken a vlákna, které získali mutex nutné uvolnit voláním <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c0c11-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="c0c11-145">Na rozdíl od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> třídu lze použít pro synchronizaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="c0c11-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="c0c11-146">K tomuto účelu použijte pojmenovaný vzájemně vyloučený přístup, která je viditelná v celém operačním systému.</span><span class="sxs-lookup"><span data-stu-id="c0c11-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="c0c11-147">Chcete-li vytvořit instanci pojmenovaný vzájemně vyloučený přístup, použijte [Mutex konstruktor](<xref:System.Threading.Mutex.%23ctor%2A>) , který určuje název.</span><span class="sxs-lookup"><span data-stu-id="c0c11-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="c0c11-148">Můžete také volat <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> metoda otevřít existující pojmenovaný vzájemně vyloučený přístup systému.</span><span class="sxs-lookup"><span data-stu-id="c0c11-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="c0c11-149">Další informace najdete v tématu [mutexů](mutexes.md) článku a <xref:System.Threading.Mutex> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="c0c11-150">Struktuře SpinLock</span><span class="sxs-lookup"><span data-stu-id="c0c11-150">SpinLock structure</span></span>

<span data-ttu-id="c0c11-151"><xref:System.Threading.SpinLock?displayProperty=nameWithType> Struktury, jako je třeba <xref:System.Threading.Monitor>, udělí se výhradní přístup ke sdíleným prostředkům na základě dostupnosti zámek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="c0c11-152">Když <xref:System.Threading.SpinLock> se pokouší získat zámek, který je k dispozici, počká ve smyčce opakovaně kontrolu, dokud nebude k dispozici zámek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="c0c11-153">Další informace o výhody a nevýhody použití uzamčení, najdete v článku [SpinLock](spinlock.md) článku a <xref:System.Threading.SpinLock> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="c0c11-154">Třída ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="c0c11-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="c0c11-155"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> Třídy udělí se výhradní přístup ke sdíleným prostředkům pro zápis a umožňuje více vláken pro přístup k prostředku současně pro čtení.</span><span class="sxs-lookup"><span data-stu-id="c0c11-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="c0c11-156">Můžete chtít použít <xref:System.Threading.ReaderWriterLockSlim> k synchronizaci přístupu k sdíleným datům strukturu, která podporuje operace čtení bezpečným pro vlákno, ale vyžaduje výhradní přístup k provedení operace zápisu.</span><span class="sxs-lookup"><span data-stu-id="c0c11-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="c0c11-157">Když vlákno vyžaduje výhradní přístup (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> metoda), následné čtečky a zapisovače požadavky bloku až do všech existujících čtenáři odpojili zámek a zapisovač, který má zadaný a byla ukončena, zámek.</span><span class="sxs-lookup"><span data-stu-id="c0c11-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="c0c11-158">Další informace najdete v tématu <xref:System.Threading.ReaderWriterLockSlim> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="c0c11-159">Třídy Semaphore a SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="c0c11-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="c0c11-160"><xref:System.Threading.Semaphore?displayProperty=nameWithType> a <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> třídy současně omezit počet vláken, které můžete přístup ke sdílenému prostředku nebo fond prostředků.</span><span class="sxs-lookup"><span data-stu-id="c0c11-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="c0c11-161">Další vlákna, které příslušný prostředek vyžádejte Počkejte, až uvolní semafor libovolného vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="c0c11-162">Protože semafor nemá spřažení vláken, vlákno může získat semafor a jiný ji uvolnit.</span><span class="sxs-lookup"><span data-stu-id="c0c11-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="c0c11-163"><xref:System.Threading.SemaphoreSlim> zjednodušené alternativu, která umožňuje <xref:System.Threading.Semaphore> a můžou používat jenom pro synchronizaci v rámci jednoho procesu hranice.</span><span class="sxs-lookup"><span data-stu-id="c0c11-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="c0c11-164">Na Windows, můžete použít <xref:System.Threading.Semaphore> synchronizace mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="c0c11-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="c0c11-165">K tomuto účelu vytvořte <xref:System.Threading.Semaphore> instanci, která představuje semafor pojmenované systém pomocí jedné z [semafor konstruktory](<xref:System.Threading.Semaphore.%23ctor%2A>) , který určuje název nebo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c0c11-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0c11-166"><xref:System.Threading.SemaphoreSlim> nepodporuje semafory pojmenované systému.</span><span class="sxs-lookup"><span data-stu-id="c0c11-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="c0c11-167">Další informace najdete v tématu [Semaphore a SemaphoreSlim](semaphore-and-semaphoreslim.md) článku a <xref:System.Threading.Semaphore> nebo <xref:System.Threading.SemaphoreSlim> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="c0c11-168">Vlákno, nebo interakci signalizace</span><span class="sxs-lookup"><span data-stu-id="c0c11-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="c0c11-169">Vlákno (nebo interakci signalizace vlákno) znamená, že vlákno musí čekat oznámení nebo signál z jednoho nebo více vláken, aby bylo možné pokračovat.</span><span class="sxs-lookup"><span data-stu-id="c0c11-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="c0c11-170">Například, pokud vlákna A zavolá <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> vlákna B, vlákna A metoda je blokovaný, dokud vlákno B dokončí.</span><span class="sxs-lookup"><span data-stu-id="c0c11-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="c0c11-171">Synchronizace primitiv je popsáno v předchozí části poskytují různé mechanismus pro signalizaci: podle uvolnění zámku, vlákno upozorní jiného vlákna, který můžete přejít o získání zámku.</span><span class="sxs-lookup"><span data-stu-id="c0c11-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="c0c11-172">Tato část popisuje další signalizační konstrukce poskytované rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="c0c11-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="c0c11-173">Třídy eventwaithandle –, autoresetevent –, ManualResetEvent a ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="c0c11-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="c0c11-174"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> Třída představuje událost synchronizace vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="c0c11-175">Synchronizace událostí může být buď v unsignaled nebo signalizovaného stavu.</span><span class="sxs-lookup"><span data-stu-id="c0c11-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="c0c11-176">Po unsignaled stav události podproces, který volá události <xref:System.Threading.WaitHandle.WaitOne%2A?> přetížení je blokovaný, dokud událost je signalizována.</span><span class="sxs-lookup"><span data-stu-id="c0c11-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="c0c11-177"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Metoda nastaví stav události do signalizovaného.</span><span class="sxs-lookup"><span data-stu-id="c0c11-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="c0c11-178">Chování <xref:System.Threading.EventWaitHandle> , který má byl signalizován, závisí na jeho režimu obnovení:</span><span class="sxs-lookup"><span data-stu-id="c0c11-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="c0c11-179"><xref:System.Threading.EventWaitHandle> Vytvořené pomocí <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> příznak automatické obnovení po uvolnění jedno vlákno čekání.</span><span class="sxs-lookup"><span data-stu-id="c0c11-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="c0c11-180">Je to jako Turniket, který umožňuje pouze jedno vlákno prostřednictvím pokaždé, když to bylo signalizováno.</span><span class="sxs-lookup"><span data-stu-id="c0c11-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="c0c11-181"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> Třída, která je odvozena z <xref:System.Threading.EventWaitHandle>, představuje toto chování.</span><span class="sxs-lookup"><span data-stu-id="c0c11-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="c0c11-182"><xref:System.Threading.EventWaitHandle> Vytvořené pomocí <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> příznak instalace zůstane až do signalizovaného jeho <xref:System.Threading.EventWaitHandle.Reset%2A> metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="c0c11-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="c0c11-183">Je to jako bránu se zavřít, dokud není signalizována a pak zůstane otevřená, dokud uživatel zavře.</span><span class="sxs-lookup"><span data-stu-id="c0c11-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="c0c11-184"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> Třída, která je odvozena z <xref:System.Threading.EventWaitHandle>, představuje toto chování.</span><span class="sxs-lookup"><span data-stu-id="c0c11-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="c0c11-185"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> Třídy je zjednodušené alternativou k <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="c0c11-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="c0c11-186">Na Windows, můžete použít <xref:System.Threading.EventWaitHandle> synchronizace mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="c0c11-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="c0c11-187">K tomuto účelu vytvořte <xref:System.Threading.EventWaitHandle> instanci, která představuje událost synchronizace s názvem systému pomocí jedné z [eventwaithandle – konstruktory](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) , který určuje název nebo <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="c0c11-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="c0c11-188">Další informace najdete v tématu [eventwaithandle –](eventwaithandle.md) a [ManualResetEvent a ManualResetEventSlim](manualresetevent-and-manualreseteventslim.md) článků.</span><span class="sxs-lookup"><span data-stu-id="c0c11-188">For more information, see the [EventWaitHandle](eventwaithandle.md) and [ManualResetEvent and ManualResetEventSlim](manualresetevent-and-manualreseteventslim.md) articles.</span></span> <span data-ttu-id="c0c11-189">Reference k rozhraní API, najdete v části <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, a <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="c0c11-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="c0c11-190">Třída CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="c0c11-190">CountdownEvent class</span></span>

<span data-ttu-id="c0c11-191"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> Třída představuje událost, která se stane nastavit, pokud její vlastnosti count je nula.</span><span class="sxs-lookup"><span data-stu-id="c0c11-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="c0c11-192">Zatímco <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> je větší než nula, vlákna, která volá <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> blokovaný.</span><span class="sxs-lookup"><span data-stu-id="c0c11-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="c0c11-193">Volání <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> se sníží počet události.</span><span class="sxs-lookup"><span data-stu-id="c0c11-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="c0c11-194">Rozdíl od <xref:System.Threading.ManualResetEvent> nebo <xref:System.Threading.ManualResetEventSlim>, který můžete použít k odblokování více vláken s signál z jednoho vlákna, můžete použít <xref:System.Threading.CountdownEvent> odblokujete jedno nebo více vláken s signály z více vláken.</span><span class="sxs-lookup"><span data-stu-id="c0c11-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="c0c11-195">Další informace najdete v tématu [CountdownEvent](countdownevent.md) článku a <xref:System.Threading.CountdownEvent> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="c0c11-196">Třídy Barrier</span><span class="sxs-lookup"><span data-stu-id="c0c11-196">Barrier class</span></span>

<span data-ttu-id="c0c11-197"><xref:System.Threading.Barrier?displayProperty=nameWithType> Třída reprezentuje barrier spuštění vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="c0c11-198">Vlákno, které volá <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> metoda signalizuje, že se dosáhlo odbourejte překážky bránící a počká až do jiných účastníka vláken oslovit odbourejte překážky bránící.</span><span class="sxs-lookup"><span data-stu-id="c0c11-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="c0c11-199">Pokud všechna vlákna účastníka dosáhnou bariéry, jejich pokračovat a odbourejte překážky bránící se resetuje a je možné znovu.</span><span class="sxs-lookup"><span data-stu-id="c0c11-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="c0c11-200">Můžete použít <xref:System.Threading.Barrier> když jeden nebo více vláken, aby výsledky z jiných vláken před pokračováním na další fázi výpočtu.</span><span class="sxs-lookup"><span data-stu-id="c0c11-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="c0c11-201">Další informace najdete v tématu [bariéry](barrier.md) článku a <xref:System.Threading.Barrier> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="c0c11-202">Interlocked – třída</span><span class="sxs-lookup"><span data-stu-id="c0c11-202">Interlocked class</span></span>

<span data-ttu-id="c0c11-203"><xref:System.Threading.Interlocked?displayProperty=nameWithType> Třída poskytuje statické metody, které provádějí jednoduché atomické operace na proměnnou.</span><span class="sxs-lookup"><span data-stu-id="c0c11-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="c0c11-204">Tyto atomické operace zahrnují přidání, Inkrementace a dekrementace, exchange a podmíněné exchange, na kterém závisí porovnání a číst operace 64bitové celočíselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c0c11-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="c0c11-205">Další informace najdete v tématu <xref:System.Threading.Interlocked> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="c0c11-206">Struktura SpinWait</span><span class="sxs-lookup"><span data-stu-id="c0c11-206">SpinWait structure</span></span>

<span data-ttu-id="c0c11-207"><xref:System.Threading.SpinWait?displayProperty=nameWithType> Struktury poskytuje podporu pro čekání na základě typu číselník.</span><span class="sxs-lookup"><span data-stu-id="c0c11-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="c0c11-208">Můžete ho použít, pokud vlákno obsahuje čekání na událost má být signalizován nebo podmínku splnit, ale v případě, že skutečné čekací doba má být menší než doba čekání popisovač čekání pomocí nebo jinak blokování vlákna.</span><span class="sxs-lookup"><span data-stu-id="c0c11-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="c0c11-209">S použitím <xref:System.Threading.SpinWait>, můžete zadat krátké doby k aktivaci při čekání a potom yield (třeba podle čekání nebo v režimu spánku) pouze v případě, že nebyla splněna podmínka v určený čas.</span><span class="sxs-lookup"><span data-stu-id="c0c11-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="c0c11-210">Další informace najdete v tématu [objektu SpinWait](spinwait.md) článku a <xref:System.Threading.SpinWait> reference k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c0c11-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="c0c11-211">Viz také:</span><span class="sxs-lookup"><span data-stu-id="c0c11-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="c0c11-212">Kolekce bezpečné pro vlákna</span><span class="sxs-lookup"><span data-stu-id="c0c11-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="c0c11-213">Práce s vlákny funkce a objekty</span><span class="sxs-lookup"><span data-stu-id="c0c11-213">Threading objects and features</span></span>](threading-objects-and-features.md)
