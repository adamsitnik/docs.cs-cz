---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 80c90254978495a58d228c4302eda84d6165c800
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/30/2019
ms.locfileid: "73138079"
---
# <a name="eventwaithandle"></a><span data-ttu-id="d10fe-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="d10fe-102">EventWaitHandle</span></span>
<span data-ttu-id="d10fe-103">Třída <xref:System.Threading.EventWaitHandle> umožňuje vláknům vzájemně komunikovat pomocí signalizace a čekáním na signály.</span><span class="sxs-lookup"><span data-stu-id="d10fe-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="d10fe-104">Obslužné rutiny čekání na události (také označované jako události) jsou obslužné rutiny čekání, které mohou být vydány k uvolnění jednoho nebo více čekajících vláken.</span><span class="sxs-lookup"><span data-stu-id="d10fe-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="d10fe-105">Po signalizaci je obslužná rutina čekání na událost resetována ručně nebo automaticky.</span><span class="sxs-lookup"><span data-stu-id="d10fe-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="d10fe-106">Třída <xref:System.Threading.EventWaitHandle> může představovat buď obslužná rutina čekání na místní událost (místní událost), nebo pojmenovaný popisovač čekání systémové události (událost nebo systémová událost, která je viditelná pro všechny procesy).</span><span class="sxs-lookup"><span data-stu-id="d10fe-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d10fe-107">Obslužné rutiny čekání událostí nejsou [událostmi](../events/index.md).NET.</span><span class="sxs-lookup"><span data-stu-id="d10fe-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="d10fe-108">Nejsou zapojeni žádní Delegáti nebo obslužné rutiny událostí.</span><span class="sxs-lookup"><span data-stu-id="d10fe-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="d10fe-109">Slovo "Event" se používá k popsání, protože byly tradičně označovány jako události operačního systému a vzhledem k tomu, že poznámení popisovače čekání čeká na čekající vlákna, ke kterým došlo událost.</span><span class="sxs-lookup"><span data-stu-id="d10fe-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="d10fe-110">Místní i pojmenované události čekají na používání objektů synchronizace systému, které jsou chráněny <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obálky, aby bylo zajištěno, že se prostředky uvolní.</span><span class="sxs-lookup"><span data-stu-id="d10fe-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="d10fe-111">Můžete použít metodu <xref:System.Threading.WaitHandle.Dispose%2A> k uvolnění prostředků hned po dokončení používání objektu.</span><span class="sxs-lookup"><span data-stu-id="d10fe-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="d10fe-112">Obslužné rutiny čekání na události, které se automaticky resetují</span><span class="sxs-lookup"><span data-stu-id="d10fe-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="d10fe-113">Událost automatického resetování vytvoříte zadáním <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> při vytváření objektu <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="d10fe-114">Jak je uvedeno, tato událost synchronizace se automaticky obnoví po vyřízení signálu po uvolnění jediného čekajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="d10fe-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="d10fe-115">Vysignálit událost voláním metody <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="d10fe-116">Události automatického resetování se obvykle používají k poskytování výhradního přístupu k prostředku pro jedno vlákno v jednom okamžiku.</span><span class="sxs-lookup"><span data-stu-id="d10fe-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="d10fe-117">Vlákno požaduje prostředek voláním metody <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d10fe-118">Pokud žádné jiné vlákno nedrží popisovač čekání, metoda vrátí `true` a volající vlákno má kontrolu nad prostředkem.</span><span class="sxs-lookup"><span data-stu-id="d10fe-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d10fe-119">Stejně jako u všech synchronizačních mechanismů je nutné zajistit, aby všechny cesty kódu čekaly příslušnému popisovači čekání před přístupem k chráněnému prostředku.</span><span class="sxs-lookup"><span data-stu-id="d10fe-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="d10fe-120">Synchronizace vláken je kooperativní.</span><span class="sxs-lookup"><span data-stu-id="d10fe-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="d10fe-121">Pokud dojde k signalizaci události automatického resetování, když nečekají žádná vlákna, zůstane signál, dokud se vlákno nepokusí o čekání.</span><span class="sxs-lookup"><span data-stu-id="d10fe-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="d10fe-122">Událost uvolní vlákno a okamžitě obnoví a blokuje následná vlákna.</span><span class="sxs-lookup"><span data-stu-id="d10fe-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="d10fe-123">Obslužné rutiny čekání na události, které se resetují ručně</span><span class="sxs-lookup"><span data-stu-id="d10fe-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="d10fe-124">Událost ručního resetování vytvoříte zadáním <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> při vytváření objektu <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="d10fe-125">Vzhledem k tomu, že je tato událost synchronizace nutná, je nutné ji po signalizaci resetovat ručně.</span><span class="sxs-lookup"><span data-stu-id="d10fe-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="d10fe-126">Dokud je obnoveno, voláním své <xref:System.Threading.EventWaitHandle.Reset%2A> metody, vlákna, která čekají na zpracování události, okamžitě bez blokování.</span><span class="sxs-lookup"><span data-stu-id="d10fe-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="d10fe-127">Událost ručního resetování funguje jako brána Corral.</span><span class="sxs-lookup"><span data-stu-id="d10fe-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="d10fe-128">Pokud událost není signalizována, vlákny, které čekají na blok IT, jako jsou koně v Corral.</span><span class="sxs-lookup"><span data-stu-id="d10fe-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="d10fe-129">Je-li událost signalizována voláním metody <xref:System.Threading.EventWaitHandle.Set%2A>, budou pokračovat všechny čekající podprocesy.</span><span class="sxs-lookup"><span data-stu-id="d10fe-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="d10fe-130">Událost zůstává signalizována, dokud nebude volána jeho <xref:System.Threading.EventWaitHandle.Reset%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="d10fe-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="d10fe-131">Tím se vytvoří událost ručního resetování ideální způsob, jak umístit vlákna, která musí čekat, až jeden podproces dokončí úlohu.</span><span class="sxs-lookup"><span data-stu-id="d10fe-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="d10fe-132">Stejně jako koně opouštějící Corral trvá čas vydaných vláken operačním systémem a k pokračování v provádění.</span><span class="sxs-lookup"><span data-stu-id="d10fe-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="d10fe-133">Pokud je metoda <xref:System.Threading.EventWaitHandle.Reset%2A> volána před tím, než všechna vlákna obnovila spuštění, zbývající vlákna znovu zablokují.</span><span class="sxs-lookup"><span data-stu-id="d10fe-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="d10fe-134">Které vlákna obnoví a které blok vlákna závisí na náhodných faktorech, jako je zatížení systému, počet vláken, která čekají na Plánovač, a tak dále.</span><span class="sxs-lookup"><span data-stu-id="d10fe-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="d10fe-135">Nejedná se o problém, pokud vlákno signalizující událost končí po signalizaci, což je nejběžnější vzor použití.</span><span class="sxs-lookup"><span data-stu-id="d10fe-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="d10fe-136">Pokud chcete, aby vlákno, které signalizuje událost, zahájilo novou úlohu po obnovení všech čekajících vláken, je nutné ji zablokovat, dokud nebudou obnovena všechna čekající vlákna.</span><span class="sxs-lookup"><span data-stu-id="d10fe-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="d10fe-137">V opačném případě máte spor a chování vašeho kódu nepředvídatelné.</span><span class="sxs-lookup"><span data-stu-id="d10fe-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="d10fe-138">Funkce společné pro automatické a ruční události</span><span class="sxs-lookup"><span data-stu-id="d10fe-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="d10fe-139">Obvykle jedno nebo více vláken blokuje <xref:System.Threading.EventWaitHandle>, dokud neblokované vlákno zavolá metodu <xref:System.Threading.EventWaitHandle.Set%2A>, která uvolní jeden z čekajících vláken (v případě událostí automatického resetování) nebo všechny (v případě událostí ručního resetování).</span><span class="sxs-lookup"><span data-stu-id="d10fe-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="d10fe-140">Vlákno může signalizovat <xref:System.Threading.EventWaitHandle> a pak ho zablokovat jako atomickou operaci voláním statické <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="d10fe-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d10fe-141"><xref:System.Threading.EventWaitHandle> objekty lze použít se statickými metodami <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> a <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="d10fe-142">Vzhledem k tomu, že třídy <xref:System.Threading.EventWaitHandle> a <xref:System.Threading.Mutex> jsou odvozeny z <xref:System.Threading.WaitHandle>, můžete použít obě třídy s těmito metodami.</span><span class="sxs-lookup"><span data-stu-id="d10fe-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="d10fe-143">Pojmenované události</span><span class="sxs-lookup"><span data-stu-id="d10fe-143">Named Events</span></span>  
 <span data-ttu-id="d10fe-144">Operační systém Windows umožňuje obslužným rutinám čekání na název mít názvy.</span><span class="sxs-lookup"><span data-stu-id="d10fe-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="d10fe-145">Pojmenovaná událost je celá systémová.</span><span class="sxs-lookup"><span data-stu-id="d10fe-145">A named event is system wide.</span></span> <span data-ttu-id="d10fe-146">To znamená, že jakmile je vytvořena pojmenovaná událost, je viditelná pro všechna vlákna ve všech procesech.</span><span class="sxs-lookup"><span data-stu-id="d10fe-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="d10fe-147">Proto lze pomocí pojmenovaných událostí synchronizovat aktivity procesů i vlákna.</span><span class="sxs-lookup"><span data-stu-id="d10fe-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="d10fe-148">Můžete vytvořit objekt <xref:System.Threading.EventWaitHandle>, který představuje pojmenovanou systémovou událost pomocí jednoho z konstruktorů, které určují název události.</span><span class="sxs-lookup"><span data-stu-id="d10fe-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d10fe-149">Vzhledem k tomu, že pojmenované události jsou napříč systémem, je možné mít více <xref:System.Threading.EventWaitHandle> objektů, které představují stejnou pojmenovanou událost.</span><span class="sxs-lookup"><span data-stu-id="d10fe-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="d10fe-150">Pokaždé, když zavoláte konstruktor nebo metodu <xref:System.Threading.EventWaitHandle.OpenExisting%2A>, vytvoří se nový objekt <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="d10fe-151">Zadáním stejného názvu opakovaně vytvoříte více objektů, které reprezentují stejnou pojmenovanou událost.</span><span class="sxs-lookup"><span data-stu-id="d10fe-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="d10fe-152">Při používání pojmenovaných událostí se doporučuje opatrnost.</span><span class="sxs-lookup"><span data-stu-id="d10fe-152">Caution is advised in using named events.</span></span> <span data-ttu-id="d10fe-153">Vzhledem k tomu, že se jedná o systém, může jiný proces, který používá stejný název, blokovat vlákna neočekávaně.</span><span class="sxs-lookup"><span data-stu-id="d10fe-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="d10fe-154">Škodlivý kód spuštěný ve stejném počítači může použít tento způsob útoku DOS (Denial of Service).</span><span class="sxs-lookup"><span data-stu-id="d10fe-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="d10fe-155">Použijte zabezpečení řízení přístupu k ochraně objektu <xref:System.Threading.EventWaitHandle>, který představuje pojmenovanou událost, nejlépe pomocí konstruktoru, který určuje objekt <xref:System.Security.AccessControl.EventWaitHandleSecurity>.</span><span class="sxs-lookup"><span data-stu-id="d10fe-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="d10fe-156">Můžete také použít zabezpečení řízení přístupu pomocí metody <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>, ale to zachová okno ohrožení zabezpečení mezi časem vytvoření popisovače čekání na událost a časem, který je chráněn.</span><span class="sxs-lookup"><span data-stu-id="d10fe-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="d10fe-157">Ochrana událostí pomocí zabezpečení řízení přístupu pomáhá zabránit škodlivým útokům, ale neřeší problém kolizí neúmyslného názvu.</span><span class="sxs-lookup"><span data-stu-id="d10fe-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d10fe-158">Na rozdíl od <xref:System.Threading.EventWaitHandle> třídy mohou odvozené třídy <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> představovat pouze místní čekací obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="d10fe-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="d10fe-159">Nemůžou představovat pojmenované systémové události.</span><span class="sxs-lookup"><span data-stu-id="d10fe-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d10fe-160">Viz také:</span><span class="sxs-lookup"><span data-stu-id="d10fe-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
