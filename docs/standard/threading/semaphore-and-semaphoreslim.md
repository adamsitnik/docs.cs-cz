---
title: Semafor a SemaphoreSlim
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET Framework], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET Framework], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: f20ae0b712a5db5cdfb6d5f6a3786af151820294
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54550484"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="2f0ee-102">Semafor a SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="2f0ee-102">Semaphore and SemaphoreSlim</span></span>
<span data-ttu-id="2f0ee-103"><xref:System.Threading.Semaphore?displayProperty=nameWithType> Třída představuje pojmenované (systémové) nebo místní "Semaphore".</span><span class="sxs-lookup"><span data-stu-id="2f0ee-103">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="2f0ee-104">Je dynamického zajišťování obálku kolem objektu semafor Win32.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-104">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="2f0ee-105">Win32 semafory jsou počítání semaforů, které je možné použít k řízení přístupu k fondu zdrojů.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-105">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="2f0ee-106"><xref:System.Threading.SemaphoreSlim> Třída představuje semafor odlehčený, rychlý, který se dá použít pro čekání v rámci jednoho procesu při velmi krátké očekávané době čekání.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-106">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="2f0ee-107"><xref:System.Threading.SemaphoreSlim> spoléhá na synchronizací primitiv modulem common language runtime (CLR) k dispozici co nejvíc.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-107"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="2f0ee-108">Ale také poskytuje obslužné rutiny čekání laxně inicializovaný, na základě jádra podle potřeby pro podporu čekání na více semafory.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-108">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="2f0ee-109"><xref:System.Threading.SemaphoreSlim> také podporuje použití tokenů zrušení, ale nepodporuje s názvem semafory nebo použijte popisovač čekání synchronizace.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-109"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="2f0ee-110">Správa prostředků omezené</span><span class="sxs-lookup"><span data-stu-id="2f0ee-110">Managing a Limited Resource</span></span>  
 <span data-ttu-id="2f0ee-111">Vlákna zadejte semafor voláním <xref:System.Threading.WaitHandle.WaitOne%2A> metodu, která se dědí z <xref:System.Threading.WaitHandle> třídy, v případě <xref:System.Threading.Semaphore?displayProperty=nameWithType> objektu, nebo <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> nebo <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> metodu v případě <xref:System.Threading.SemaphoreSlim> objektu.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-111">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="2f0ee-112">Při volání se vrátí se odečte počet na semaforu.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-112">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="2f0ee-113">Když vlákno požádá o vstupu a počet je nula, vlákno blokováno.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-113">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="2f0ee-114">Jako vláken verzi semafor voláním <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> nebo <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> metody blokovaná vlákna budou moci zadat.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-114">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="2f0ee-115">Blokovaná vlákna k zadání semafor je zaručeno pořadí, jako je například první dovnitř, první ven (FIFO) nebo poslední dovnitř, první ven (LIFO).</span><span class="sxs-lookup"><span data-stu-id="2f0ee-115">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="2f0ee-116">Vlákno můžete zadat semafor více než jednou voláním <xref:System.Threading.Semaphore?displayProperty=nameWithType> objektu <xref:System.Threading.WaitHandle.WaitOne%2A> metoda nebo <xref:System.Threading.SemaphoreSlim> objektu <xref:System.Threading.SemaphoreSlim.Wait%2A> metoda opakovaně.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-116">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="2f0ee-117">Vydat semafor vlákna můžete buď zavolat <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> nebo <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> metody přetížení stejný počet, kolikrát, nebo volání <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> nebo <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> metoda přetížení a zadat počet položek, které mají být všeobecně dostupné.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-117">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="2f0ee-118">Semaforů a identitu vlákna</span><span class="sxs-lookup"><span data-stu-id="2f0ee-118">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="2f0ee-119">Semafor dva typy Nevynucovat identitu vlákna na volání <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-119">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="2f0ee-120">Například běžný scénář využití pro semafory zahrnuje vlákno výrobce a příjemce vlákna, s jedno vlákno vždy zvyšování počtu pro semafor a druhý vždy dekrementace ho.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-120">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="2f0ee-121">Je programátorovi povinností ujistit se, že vlákno neuvolní semafor příliš mnohokrát.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-121">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="2f0ee-122">Například předpokládejme, že semafor má maximální počet dva a tohoto vlákna A a vlákna B obě zadejte semafor.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-122">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="2f0ee-123">Pokud k chybě programování ve vlákně B způsobí, že jej, aby volalo `Release` dvakrát, obě volání úspěšné.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-123">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="2f0ee-124">Počet na semaforu je plný a pokud vlákno A nakonec volá `Release`, <xref:System.Threading.SemaphoreFullException> je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-124">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="2f0ee-125">Pojmenované semafory</span><span class="sxs-lookup"><span data-stu-id="2f0ee-125">Named Semaphores</span></span>  
 <span data-ttu-id="2f0ee-126">Operační systém Windows umožňuje semafory mít názvy.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-126">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="2f0ee-127">Pojmenované semafor je v systému.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-127">A named semaphore is system wide.</span></span> <span data-ttu-id="2f0ee-128">To znamená že po vytvoření pojmenovaných semafor je viditelný na všechna vlákna ve všech procesech.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-128">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="2f0ee-129">Proto pojmenované semafor slouží k synchronizaci činností procesy a vlákna.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-129">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="2f0ee-130">Můžete vytvořit <xref:System.Threading.Semaphore> objekt, který představuje semafor pojmenované systému pomocí jednoho z konstruktorů, které určuje název.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-130">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2f0ee-131">Vzhledem k tomu pojmenované semafory v systému, je možné mít více <xref:System.Threading.Semaphore> objekty, které představují stejný název pro spolupráci.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-131">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="2f0ee-132">Pokaždé, když volat konstruktor nebo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> metodu, nové <xref:System.Threading.Semaphore> je vytvořen objekt.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-132">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="2f0ee-133">Zadání se stejným názvem opakovaně vytvoří více objektů, které představují stejné pojmenované semafor.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-133">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="2f0ee-134">Buďte opatrní při použití pojmenované semafory.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-134">Be careful when you use named semaphores.</span></span> <span data-ttu-id="2f0ee-135">Protože jsou v systému, jiný proces, který používá stejný název můžete zadat vaše semafor neočekávaně.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-135">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="2f0ee-136">Škodlivý kód, spouští ve stejném počítači může použít jako základ útok s cílem odepření služby.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-136">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="2f0ee-137">Použití řízení přístupu k ochraně <xref:System.Threading.Semaphore> objekt, který představuje pojmenované semafor nejlépe pomocí konstruktoru, který určuje <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> objektu.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-137">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="2f0ee-138">Můžete také použít pomocí zabezpečení řízení přístupu <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metody, ale ponechá okno na ohrožení zabezpečení mezi časem semafor se vytvoří a čas, který je chráněn.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-138">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="2f0ee-139">Ochrana semafory pomocí řízení přístupu pomáhá zabránit útoky se zlými úmysly, ale problém kolize názvů neúmyslnému nevyřeší.</span><span class="sxs-lookup"><span data-stu-id="2f0ee-139">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2f0ee-140">Viz také:</span><span class="sxs-lookup"><span data-stu-id="2f0ee-140">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="2f0ee-141">Funkce a objekty dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="2f0ee-141">Threading Objects and Features</span></span>](../../../docs/standard/threading/threading-objects-and-features.md)
