---
title: Zásady architektury
description: Navrhování moderních webových aplikací pomocí ASP.NET Core a Azure | Zásady architektury
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: b7edfc8d0cb3460bb33fb4e54cc93dd18ce2f385
ms.sourcegitcommit: 3500c4845f96a91a438a02ef2c6b4eef45a5e2af
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/07/2019
ms.locfileid: "55828095"
---
# <a name="architectural-principles"></a><span data-ttu-id="a9bbb-103">Zásady architektury</span><span class="sxs-lookup"><span data-stu-id="a9bbb-103">Architectural principles</span></span>

> <span data-ttu-id="a9bbb-104">"Pokud budov sestavili tvůrci programátoři způsob napsal programy a první woodpecker, který po něm přišel by zničit civilizace."</span><span class="sxs-lookup"><span data-stu-id="a9bbb-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="a9bbb-105">_\- Weinberg Lucie_</span><span class="sxs-lookup"><span data-stu-id="a9bbb-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="a9bbb-106">By měla navrhovat a navrhněte softwarová řešení s udržovatelnosti v úvahu.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="a9bbb-107">Zásady uvedené v této části vám pomůže směrem k rozhodnutí o architektuře, výsledkem bude čistý, údržby aplikace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="a9bbb-108">Obecně tyto zásady se dozvíte, k vytváření aplikací ze samostatné součásti, které nejsou pevně ostatních částech aplikace, ale spíše komunikovat prostřednictvím explicitního rozhraní nebo systémů pro zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="a9bbb-109">Běžné zásady návrhu</span><span class="sxs-lookup"><span data-stu-id="a9bbb-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="a9bbb-110">Oddělení oblastí zájmu</span><span class="sxs-lookup"><span data-stu-id="a9bbb-110">Separation of concerns</span></span>

<span data-ttu-id="a9bbb-111">Je základní princip při vývoji **oddělení se týká**.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="a9bbb-112">Této zásady vyhodnotí, že by měla být oddělena software podle druhy práce, kterou provádí.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="a9bbb-113">Zvažte například aplikaci, která obsahuje logiku pro identifikaci zajímavosti položek se budou zobrazovat uživateli, a který zformátuje tyto položky tak, aby byly snadněji postřehnutelné určitým způsobem.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="a9bbb-114">Odpovědnost za výběr položek k formátování chování by měl být udržovány odděleně od chování za formátování položek, protože jde o samostatné otázky, které se vztahují pouze shodou mezi sebou.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="a9bbb-115">Architektonicky aplikace se dají logicky vytvářet postupovat podle této zásady tak, že oddělíte core obchodní chování od logiky infrastruktury a uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="a9bbb-116">V ideálním případě obchodní pravidla a logiky by měl nacházet v samostatný projekt, který by neměl závisí na jiné projekty v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="a9bbb-117">To pomáhá zajistit, že je obchodní model usnadňuje testování a můžete rozvíjet bez jsou úzce spojeny s podrobnosti nízké úrovně implementace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-117">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="a9bbb-118">Oddělení oblastí zájmu je důležitým aspektem za použití vrstev v aplikačních architektur.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="a9bbb-119">Zapouzdření</span><span class="sxs-lookup"><span data-stu-id="a9bbb-119">Encapsulation</span></span>

<span data-ttu-id="a9bbb-120">Používejte různé části aplikace **zapouzdření** chcete izolovat je z jiných částí aplikace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="a9bbb-121">Mezi součástmi aplikace a vrstvy by měl být moci upravit jejich vnitřní implementace bez porušení jejich spolupracovníky tak dlouho, dokud nejsou došlo k porušení smlouvy externí.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="a9bbb-122">Správné použití operátoru zapouzdření pomáhá dosahovat volné párování a modularitu při návrhy aplikací, protože objekty a balíčky je možné nahradit alternativní implementace tak dlouho, dokud se udržuje stejné rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="a9bbb-123">Ve třídách zapouzdření se dosahuje tím, že omezíte mimo přístup ke vnitřní stav třídy.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="a9bbb-124">Pokud prvek "actor" vnější chce, aby se k manipulaci s stavu objektu, je to měl dělat implementovaný prostřednictvím dobře definovaných – funkce (nebo vlastnost setter), namísto nutnosti přímý přístup k privátním stavu objektu.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="a9bbb-125">Mezi součástmi aplikace a samotnými aplikacemi, by měly vystavit dobře definovaných rozhraní pro své spolupracovníky k používání a nepovolí svůj stav na přímo upravovat.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="a9bbb-126">Tím se uvolní interní návrhu aplikace až po v průběhu času vyvíjejí bez obav, že to uděláte tak přeruší spolupracovníkům, tak dlouho, dokud se zachovají veřejné smluv.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-126">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="a9bbb-127">Inverze závislostí</span><span class="sxs-lookup"><span data-stu-id="a9bbb-127">Dependency inversion</span></span>

<span data-ttu-id="a9bbb-128">Směr závislosti v rámci aplikace musí být ve směru abstrakce, ne podrobnosti implementace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="a9bbb-129">Většina aplikací jsou napsané tak, aby závislostí kompilace toky ve směru spuštění modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="a9bbb-130">Tímto se vytvoří graf závislosti s přímým přístupem.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-130">This produces a direct dependency graph.</span></span> <span data-ttu-id="a9bbb-131">To znamená pokud modul A volá funkci v modulu B, které volá funkci v modulu jazyka C a pak podle času A kompilace závisí na B, který bude záviset na C, jak ukazuje obrázek 4-1.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-131">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="a9bbb-132">**Obrázek 4-1.**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-132">**Figure 4-1.**</span></span> <span data-ttu-id="a9bbb-133">Graf závislosti s přímým přístupem.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-133">Direct dependency graph.</span></span>

<span data-ttu-id="a9bbb-134">Použití zásady čistého inverzi závislost umožňuje A volání metod na abstrakce, která implementuje B, aby bylo možné pro A volání B za běhu, ale pro B závisí na rozhraní řídí A v době kompilace (tedy *převrácení* Typické kompilace závislosti).</span><span class="sxs-lookup"><span data-stu-id="a9bbb-134">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="a9bbb-135">V době běhu průběh provádění programu nezmění, ale po zavedení služby rozhraní znamená, že jedná o rozdílné implementace těchto rozhraní můžete snadno být zapojené do elektrické zásuvky.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-135">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="a9bbb-136">**Obrázek 4-2.**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-136">**Figure 4-2.**</span></span> <span data-ttu-id="a9bbb-137">Graf závislosti obrácený.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-137">Inverted dependency graph.</span></span>

<span data-ttu-id="a9bbb-138">**Závislost inverzi** je klíčovou součástí vytvoření volně spárované aplikace, protože podrobnosti implementace lze zapsat a závisí na implementaci vyšší úroveň abstrakce, spíše než naopak.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-138">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="a9bbb-139">Výsledná aplikace jsou v důsledku možností intenzivního testování, modulární a udržovatelný.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-139">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="a9bbb-140">Postup, kdy se *injektáž závislostí* je možné podle principu inverzi závislostí.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-140">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="a9bbb-141">Explicitní závislosti.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-141">Explicit dependencies</span></span>

<span data-ttu-id="a9bbb-142">**Metody a třídy explicitně vyžadují žádné spolupracující objekty, které potřebují, aby bylo možné správně fungovat.**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-142">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="a9bbb-143">Konstruktor třídy poskytují příležitost pro třídy k identifikaci věci, které musí být v platném stavu a správně fungovat.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-143">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="a9bbb-144">Při definování třídy, která vytvořen a názvem, ale která bude pouze fungovat správně, pokud některé součásti globální nebo infrastruktury jsou na místě, se tyto třídy *nepoctivý* s klienty.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-144">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="a9bbb-145">Kontrakt konstruktor sděluje, že klienta, který potřebuje pouze věci zadané (pravděpodobně nic, pokud třída používá pouze výchozí konstruktor), ale pak za běhu, který ukazuje objekt opravdu potřebujete něco jiného.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-145">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="a9bbb-146">Podle principu explicitní závislosti jsou ještě upřímná s klienty o to, co chtějí, aby bylo možné funkci třídy a metody.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-146">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="a9bbb-147">Díky tomu váš kód více samoobslužných dokumentace a smlouvy přívětivější, psaní kódu, protože uživatelé budou přicházet do vztahu důvěryhodnosti, který tak dlouho, dokud poskytují toho, co vyžaduje ve formě – metoda nebo parametry konstruktoru, objekty, které pracují se bude chovat. správně za běhu.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-147">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="a9bbb-148">Jednotnou zodpovědnost</span><span class="sxs-lookup"><span data-stu-id="a9bbb-148">Single responsibility</span></span>

<span data-ttu-id="a9bbb-149">Princip jednotnou zodpovědnost se vztahuje k objektově orientovaný návrh, ale můžete také považují za architektury Princip podobný oddělení oblastí zájmu.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-149">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="a9bbb-150">Uvádí, že objekty by měl mít pouze jednu zodpovědnost a že by měly mít pouze jeden důvod, proč změnit.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-150">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="a9bbb-151">Konkrétně pouze situace, ve kterém by měl změnit objekt je, pokud se musí aktualizovat způsob, ve které provádí její odpovědnosti jeden.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-151">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="a9bbb-152">Podle této zásady umožňuje vytvořit více volně spojené a modulární systémy, od mnoha různých nové chování je možné implementovat jako nové třídy, nikoli přidáním další odpovědnost na existující třídy.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-152">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="a9bbb-153">Přidání nové třídy je vždy bezpečnější než změna existujících tříd, protože žádný kód, ale závisí na nové třídy.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-153">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="a9bbb-154">V monolitické aplikaci jsme do vrstvy v aplikaci použít principu jednotnou zodpovědnost na vysoké úrovni.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-154">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="a9bbb-155">Prezentace odpovědnost by měla zůstat v projektu uživatelského rozhraní, při přístupu k datům v rámci projektu aplikace infrastruktury by měly být neustále odpovědnost.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-155">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="a9bbb-156">Obchodní logika ukládat v základní projekt aplikace, ve kterém lze snadno testovat a můžete rozvíjet nezávisle z další úkoly.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-156">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="a9bbb-157">Tato zásada je použita na architektuře aplikací a přesunete na jeho logický koncový bod, získáte mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-157">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="a9bbb-158">Daný mikroslužba by měl mít jednotnou zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-158">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="a9bbb-159">Pokud potřebujete rozšířit chování systému, je obvykle vhodnější to udělat tak, že přidáte další mikroslužeb, nikoli přidáním zodpovědností některý z existujících.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-159">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="a9bbb-160">Další informace o architektuře mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="a9bbb-160">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="a9bbb-161">Neopakovat sami (zkušební)</span><span class="sxs-lookup"><span data-stu-id="a9bbb-161">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="a9bbb-162">Aplikace se měli vyhnout určení chování je to časté příčiny chyby související s konkrétní pojem na více místech.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-162">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="a9bbb-163">V určitém okamžiku bude vyžadovat změny v požadavcích změna toto chování a pravděpodobnost, že nejméně jedna instance chování selže aktualizovat bude mít za následek nekonzistentní chování systému.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-163">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="a9bbb-164">Namísto duplikování logiky zapouzdření v programovací konstrukce.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-164">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="a9bbb-165">Vytvořit sestavit jeden autority přes toto chování a mají jiné části aplikace, která potřebuje toto chování použít novou konstrukci.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-165">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="a9bbb-166">Vyhněte se chování, které se shodou opakované vazby společně.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-166">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="a9bbb-167">Například pouze z důvodu dvě různé konstanty obě mají stejnou hodnotu, neznamená, že byste měli mít jenom jednu konstantu, koncepčně jste odkazující na různé věci.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-167">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="a9bbb-168">Trvalost neznalosti</span><span class="sxs-lookup"><span data-stu-id="a9bbb-168">Persistence ignorance</span></span>

<span data-ttu-id="a9bbb-169">**Trvalost neznalosti** (PÍ) odkazuje na typy, které je potřeba nastavit jako trvalý, ale jejíž kód není ovlivněn řadu technologií trvalosti.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-169">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="a9bbb-170">Tyto typy v rozhraní .NET jsou někdy označovány jako obyčejný starší objekty CLR (POCOs), protože není nutné dědí určité základní třídy nebo implementovat konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-170">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="a9bbb-171">Trvalost neznalosti je užitečné, protože umožňuje stejný model business natrvalo několika různými způsoby, nabízí větší flexibilitu pro aplikace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-171">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="a9bbb-172">Možnosti trvalého může změnit v čase od technologie jednu databázi na jiný, nebo může být vyžadováno kromě cokoli, co je aplikace spuštěna s další formy trvalost (například použití mezipaměti redis cache nebo Azure DocumentDb kromě relační databáze).</span><span class="sxs-lookup"><span data-stu-id="a9bbb-172">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="a9bbb-173">Mezi příklady narušení této zásady patří:</span><span class="sxs-lookup"><span data-stu-id="a9bbb-173">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="a9bbb-174">Vyžaduje základní třídy.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-174">A required base class.</span></span>

- <span data-ttu-id="a9bbb-175">Provádění požadované rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-175">A required interface implementation.</span></span>

- <span data-ttu-id="a9bbb-176">Třídy za samotné ukládání (například záznam Active vzor).</span><span class="sxs-lookup"><span data-stu-id="a9bbb-176">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="a9bbb-177">Vyžaduje výchozí konstruktor.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-177">Required default constructor.</span></span>

- <span data-ttu-id="a9bbb-178">Vlastnosti vyžadující virtual – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-178">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="a9bbb-179">Vyžadované atributy specifické pro trvalost.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-179">Persistence-specific required attributes.</span></span>

<span data-ttu-id="a9bbb-180">Požadavek třídy mají některé z výše uvedené funkce nebo chování přidá párování mezi typy natrvalo a volbu technologie trvalost znesnadňuje přijmout nové strategie přístup data v budoucnosti.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-180">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="a9bbb-181">Ohraničené kontexty</span><span class="sxs-lookup"><span data-stu-id="a9bbb-181">Bounded contexts</span></span>

<span data-ttu-id="a9bbb-182">**Ohraničených kontextech** jsou centrální model v Domain-Driven Design.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-182">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="a9bbb-183">Když ho rozdělíte do samostatných koncepční modulů poskytují způsob složitosti řešení pro velké aplikace nebo organizace.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-183">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="a9bbb-184">Každý koncepční modul představuje kontext, který je oddělená od ostatních kontextech (tedy ohraničeny) a můžete rozvíjet nezávisle na sobě.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-184">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="a9bbb-185">Jednotlivých ohraničených kontextech v ideálním případě měli zvolit vlastní názvy konceptů v rámci něj a má výhradní přístup k vlastním úložišti pro trvalé uložení.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-185">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="a9bbb-186">Minimálně přiklonit jednotlivých webových aplikací na jejich vlastní ohraničený kontext s své vlastní úložiště trvalosti pro svůj obchodní model, nikoli databázi pro sdílení obsahu s jinými aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-186">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="a9bbb-187">Probíhá komunikace mezi ohraničené kontexty prostřednictvím programových rozhraní, a nikoli prostřednictvím sdílenou databázi, která umožňuje obchodní logiky a události se umístit v reakci na změny, které se provedou.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-187">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="a9bbb-188">Ohraničených kontextech mapy úzce do mikroslužeb, která také se v ideálním případě implementují jako vlastní jednotlivých ohraničené kontexty.</span><span class="sxs-lookup"><span data-stu-id="a9bbb-188">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="a9bbb-189">Odkazy – moderních webových aplikací</span><span class="sxs-lookup"><span data-stu-id="a9bbb-189">References – Modern Web Applications</span></span>
> - <span data-ttu-id="a9bbb-190">**Oddělení oblastí zájmu**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-190">**Separation of Concerns**</span></span>  
> <https://deviq.com/separation-of-concerns/>
> - <span data-ttu-id="a9bbb-191">**Encapsulation**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-191">**Encapsulation**</span></span>  
> <https://deviq.com/encapsulation/>
> - <span data-ttu-id="a9bbb-192">**Princip inverzi závislostí**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-192">**Dependency Inversion Principle**</span></span>  
> <https://deviq.com/dependency-inversion-principle/>
> - <span data-ttu-id="a9bbb-193">**Princip explicitních závislostí**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-193">**Explicit Dependencies Principle**</span></span>  
> <https://deviq.com/explicit-dependencies-principle/>
> - <span data-ttu-id="a9bbb-194">**Neopakovat sami**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-194">**Don't Repeat Yourself**</span></span>  
> <https://deviq.com/don-t-repeat-yourself/>
> - <span data-ttu-id="a9bbb-195">**Trvalost neznalosti**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-195">**Persistence Ignorance**</span></span>  
> <https://deviq.com/persistence-ignorance/>
> - <span data-ttu-id="a9bbb-196">**Ohraničený kontext**</span><span class="sxs-lookup"><span data-stu-id="a9bbb-196">**Bounded Context**</span></span>  
> <https://martinfowler.com/bliki/BoundedContext.html>

>[!div class="step-by-step"]
><span data-ttu-id="a9bbb-197">[Předchozí](choose-between-traditional-web-and-single-page-apps.md)
>[další](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="a9bbb-197">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>
