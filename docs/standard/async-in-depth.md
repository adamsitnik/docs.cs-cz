---
title: Asynchronní v hloubkě
description: Přečtěte si, jak je možné zapisovat do vstupně-výstupních operací a asynchronního kódu vázaného na procesor, pomocí asynchronního modelu založeného na úlohách .NET.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 6f1900eaabafe2931d88959bf79bf4ca1f5bc98b
ms.sourcegitcommit: cdf67135a98a5a51913dacddb58e004a3c867802
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/21/2019
ms.locfileid: "69666583"
---
# <a name="async-in-depth"></a><span data-ttu-id="5f307-103">Asynchronní v hloubkě</span><span class="sxs-lookup"><span data-stu-id="5f307-103">Async in depth</span></span>

<span data-ttu-id="5f307-104">Zápisy do vstupně-výstupních operací a asynchronního kódu vázaného na procesor jsou jednoduché pomocí asynchronního modelu založeného na úlohách .NET.</span><span class="sxs-lookup"><span data-stu-id="5f307-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="5f307-105">Model je `Task` zveřejněn typy a `async` `Task<T>` a klíčovými slovy `await` C# a a Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="5f307-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="5f307-106">(Prostředky specifické pro jazyk najdete v části [Viz také](#see-also) .) Tento článek vysvětluje, jak použít .NET Async a poskytuje přehled o asynchronním rozhraní, které se používá v rámci pokrývání.</span><span class="sxs-lookup"><span data-stu-id="5f307-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="5f307-107">Úloha a úloha\<T ></span><span class="sxs-lookup"><span data-stu-id="5f307-107">Task and Task\<T></span></span>

<span data-ttu-id="5f307-108">Úkoly jsou konstrukce používané k implementaci toho, co je známo jako [model příslib souběžnosti](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="5f307-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="5f307-109">V krátkém případě vám nabídne "příslib", který se v pozdější fázi dokončí, takže budete mít k dispozici příslib s čistým rozhraním API.</span><span class="sxs-lookup"><span data-stu-id="5f307-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

* <span data-ttu-id="5f307-110">`Task`představuje jednu operaci, která nevrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5f307-110">`Task` represents a single operation which does not return a value.</span></span>
* <span data-ttu-id="5f307-111">`Task<T>`představuje jednu operaci, která vrací hodnotu typu `T`.</span><span class="sxs-lookup"><span data-stu-id="5f307-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="5f307-112">Je důležité mít důvod na úlohy, jako abstrakce práce, které provádí asynchronně, a *ne* abstrakce nad vlákny.</span><span class="sxs-lookup"><span data-stu-id="5f307-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="5f307-113">Ve výchozím nastavení se úlohy spouštějí v aktuálním vlákně a podle potřeby deleguje práci s operačním systémem.</span><span class="sxs-lookup"><span data-stu-id="5f307-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="5f307-114">Volitelně je možné úlohy explicitně požadovat, aby se spouštěly na samostatném vlákně přes `Task.Run` rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5f307-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="5f307-115">Úlohy zpřístupňují protokol rozhraní API pro monitorování, čeká na něj a přistupuje k výsledné hodnotě (v případě `Task<T>`) úkolu.</span><span class="sxs-lookup"><span data-stu-id="5f307-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="5f307-116">Jazyková integrace s `await` klíčovým slovem poskytuje abstrakci vyšší úrovně pro používání úkolů.</span><span class="sxs-lookup"><span data-stu-id="5f307-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="5f307-117">Pomocí `await` nástroje umožňuje vaše aplikace nebo služba provádět užitečnou práci, zatímco je úloha spuštěná, a to tak, že je řízení volajícího, dokud se úkol nedokončí.</span><span class="sxs-lookup"><span data-stu-id="5f307-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="5f307-118">Váš kód nemusí spoléhat na zpětná volání nebo události, aby bylo možné pokračovat v provádění po dokončení úkolu.</span><span class="sxs-lookup"><span data-stu-id="5f307-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="5f307-119">Integrace rozhraní API jazyka a úloh to dělá za vás.</span><span class="sxs-lookup"><span data-stu-id="5f307-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="5f307-120">Pokud používáte `Task<T>` `await` , klíčové slovo dále "rozbalení" vrátí hodnotu vrácenou po dokončení úkolu.</span><span class="sxs-lookup"><span data-stu-id="5f307-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="5f307-121">Podrobnosti o tom, jak tyto funkce jsou vysvětleny níže.</span><span class="sxs-lookup"><span data-stu-id="5f307-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="5f307-122">Další informace o úlohách a různých způsobech, jak s nimi pracovat, najdete v tématu [asynchronního vzoru založeného na úlohách (klepnutím)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) .</span><span class="sxs-lookup"><span data-stu-id="5f307-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="5f307-123">Hlubší podrobně v úlohách operace vázané na vstup a výstup</span><span class="sxs-lookup"><span data-stu-id="5f307-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="5f307-124">Následující část popisuje pohled 10 000 na to, co se stane s typickým asynchronním vstupně-výstupním voláním.</span><span class="sxs-lookup"><span data-stu-id="5f307-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="5f307-125">Pojďme začít několika příklady.</span><span class="sxs-lookup"><span data-stu-id="5f307-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="5f307-126">První příklad volá asynchronní metodu a vrátí aktivní úlohu, která se nejspíš ještě dokončila.</span><span class="sxs-lookup"><span data-stu-id="5f307-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="5f307-127">Druhý příklad přidá použití `async` klíčového slova a `await` pro práci na úkolu.</span><span class="sxs-lookup"><span data-stu-id="5f307-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="5f307-128">Volání `GetStringAsync()` volání prostřednictvím knihoven rozhraní .NET nižší úrovně (případně volání jiných asynchronních metod), dokud nedosáhne volání Interop volání nespravovaného kódu do nativní síťové knihovny.</span><span class="sxs-lookup"><span data-stu-id="5f307-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="5f307-129">Nativní knihovna může následně volat volání rozhraní API systému (například `write()` k soketu na platformě Linux).</span><span class="sxs-lookup"><span data-stu-id="5f307-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="5f307-130">Objekt úlohy bude vytvořen v nativní/spravované hranici, případně pomocí [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="5f307-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="5f307-131">Objekt Task se předává přes vrstvy, případně spuštěný nebo přímo vracený, nakonec vráceného počátečnímu volajícímu.</span><span class="sxs-lookup"><span data-stu-id="5f307-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="5f307-132">V druhém příkladu výše `Task<T>` se vrátí objekt z. `GetStringAsync`</span><span class="sxs-lookup"><span data-stu-id="5f307-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="5f307-133">Použití `await` klíčového slova způsobí, že metoda vrátí nově vytvořený objekt Task.</span><span class="sxs-lookup"><span data-stu-id="5f307-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="5f307-134">Řízení se vrátí volajícímu z tohoto umístění v `GetFirstCharactersCountAsync` metodě.</span><span class="sxs-lookup"><span data-stu-id="5f307-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="5f307-135">Metody a vlastnosti objektu [Task&lt;T&gt; ](xref:System.Threading.Tasks.Task%601) umožňují volajícím monitorovat průběh úkolu, který bude dokončen, když zbývající kód v GetFirstCharactersCountAsync proveden.</span><span class="sxs-lookup"><span data-stu-id="5f307-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="5f307-136">Po volání rozhraní API systému je požadavek teď v prostoru jádra a díky němu se bude jednat o Síťový subsystém operačního systému (například `/net` v jádru Linux).</span><span class="sxs-lookup"><span data-stu-id="5f307-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="5f307-137">V tomto případě bude operační systém zpracovávat požadavky sítě *asynchronně*.</span><span class="sxs-lookup"><span data-stu-id="5f307-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="5f307-138">Podrobnosti se můžou lišit v závislosti na použitém operačním systému (může být volání ovladače zařízení naplánované jako signál, který se zpátky do modulu runtime), nebo může být provedeno volání ovladače zařízení, které se *pak* pošle zpátky. za běhu se ale bude informovat, že se jedná o síť. žádost probíhá.</span><span class="sxs-lookup"><span data-stu-id="5f307-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="5f307-139">V tuto chvíli bude práce pro ovladač zařízení buď naplánována, probíhá, nebo již dokončena (žádost již je přenášena po síti "), ale vzhledem k tomu, že k této situaci dojde asynchronně, ovladač zařízení bude moci okamžitě zvládnout něco jiného.</span><span class="sxs-lookup"><span data-stu-id="5f307-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="5f307-140">Například ve Windows vlákno operačního systému zavolá ovladač síťového zařízení a požádá ho, aby provedl síťové operace prostřednictvím paketu požadavku přerušení (IRP), který představuje operaci.</span><span class="sxs-lookup"><span data-stu-id="5f307-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="5f307-141">Ovladač zařízení přijme požadavek IRP, provede volání do sítě, označí požadavek IRP jako "pending" a vrátí se zpět do operačního systému.</span><span class="sxs-lookup"><span data-stu-id="5f307-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="5f307-142">Vzhledem k tomu, že vlákno operačního systému nyní ví, že je IRP "čeká", nemá další práci pro tuto úlohu a "vrátí" zpět, aby je bylo možné použít k provedení jiné práce.</span><span class="sxs-lookup"><span data-stu-id="5f307-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="5f307-143">Když je žádost splněná a data se vrátí přes ovladač zařízení, upozorní procesor nových dat přijatých prostřednictvím přerušení.</span><span class="sxs-lookup"><span data-stu-id="5f307-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="5f307-144">Způsob zpracování tohoto přerušení se bude lišit v závislosti na operačním systému, ale data budou předána operačním systémem, dokud nedosáhne volání interoperability systému (například v systému Linux obslužná rutina přerušení naplánuje poslední polovinu IRQ, aby předávala data v operačním systému.  asynchronně).</span><span class="sxs-lookup"><span data-stu-id="5f307-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="5f307-145">Všimněte si, že se k tomu *taky* dochází asynchronně.</span><span class="sxs-lookup"><span data-stu-id="5f307-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="5f307-146">Výsledek je zařazen do fronty, dokud další dostupné vlákno nebude moci spustit asynchronní metodu a "rozbalení" výsledku dokončeného úkolu.</span><span class="sxs-lookup"><span data-stu-id="5f307-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="5f307-147">V celém rámci celého procesu Key poznatkem je, že **pro spuštění úlohy není žádné vlákno vyhrazené**.</span><span class="sxs-lookup"><span data-stu-id="5f307-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="5f307-148">I když se práce provádí v nějakém kontextu (to znamená, že operační systém musí předávat data do ovladače zařízení a reagovat na přerušení), neexistuje žádné vlákno vyhrazené k *čekání* na to, aby se data od žádosti vrátila zpět.</span><span class="sxs-lookup"><span data-stu-id="5f307-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="5f307-149">Díky tomu může systém zpracovávat mnohem větší objem práce, a ne čekat na dokončení některých vstupně-výstupních volání.</span><span class="sxs-lookup"><span data-stu-id="5f307-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="5f307-150">I když výše se může zdát, že je třeba udělat spoustu práce, která se měří z pohledu na hodinový čas, je miniscule v porovnání s časem potřebným ke skutečnému vstupně-výstupní práci.</span><span class="sxs-lookup"><span data-stu-id="5f307-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="5f307-151">I když to není zcela přesné, potenciální časová osa pro takové volání by vypadala takto:</span><span class="sxs-lookup"><span data-stu-id="5f307-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="5f307-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="5f307-152">0-1————————————————————————————————————————————————–2-3</span></span>

* <span data-ttu-id="5f307-153">Čas strávený z `0` bodů `1` na je vše až do chvíle, kdy asynchronní metoda neposkytne řízení volajícímu.</span><span class="sxs-lookup"><span data-stu-id="5f307-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
* <span data-ttu-id="5f307-154">Čas strávený z `1` bodů `2` na je čas strávený na vstupu a výstupu bez nákladů na procesor.</span><span class="sxs-lookup"><span data-stu-id="5f307-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
* <span data-ttu-id="5f307-155">Nakonec čas strávený z bodů `2` na `3` je předání řízení zpět (a potenciálně hodnoty) asynchronní metodě, při které je prováděna znovu.</span><span class="sxs-lookup"><span data-stu-id="5f307-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="5f307-156">Co to znamená pro serverový scénář?</span><span class="sxs-lookup"><span data-stu-id="5f307-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="5f307-157">Tento model funguje dobře s typickou úlohou serverového scénáře.</span><span class="sxs-lookup"><span data-stu-id="5f307-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="5f307-158">Vzhledem k tomu, že nejsou k dispozici žádná vlákna vyhrazená pro blokování nedokončených úloh, může služba nečinnosti serveru dosloužit mnohem větší objem webových požadavků.</span><span class="sxs-lookup"><span data-stu-id="5f307-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="5f307-159">Vezměte v úvahu dva servery: jeden, který spouští asynchronní kód, a druhý, který ne.</span><span class="sxs-lookup"><span data-stu-id="5f307-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="5f307-160">Pro účely tohoto příkladu má každý server pouze 5 vláken dostupných pro žádosti o služby.</span><span class="sxs-lookup"><span data-stu-id="5f307-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="5f307-161">Všimněte si, že tato čísla jsou imaginarily malá a slouží pouze jako provedený kontext.</span><span class="sxs-lookup"><span data-stu-id="5f307-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="5f307-162">Předpokládat, že oba servery obdrží 6 souběžných požadavků.</span><span class="sxs-lookup"><span data-stu-id="5f307-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="5f307-163">Každý požadavek provede vstupně-výstupní operaci.</span><span class="sxs-lookup"><span data-stu-id="5f307-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="5f307-164">Server *bez* asynchronního kódu musí zařadit šest požadavků do fronty, dokud jedna z 5 vláken nedokončí práci v/v vázané na vstup/výstup a napsala odpověď.</span><span class="sxs-lookup"><span data-stu-id="5f307-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="5f307-165">V okamžiku, kdy dojde k dvacáté žádosti, může server začít zpomalovat, protože fronta je příliš dlouhá.</span><span class="sxs-lookup"><span data-stu-id="5f307-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="5f307-166">Server *s* asynchronním kódem, který je v něm spuštěný, stále zařadí do fronty šestý `await`požadavek, ale protože používá `async` a, každé z jeho vláken se uvolní při zahájení práce na vstupu/výstupu, a ne po jeho dokončení.</span><span class="sxs-lookup"><span data-stu-id="5f307-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="5f307-167">V době, kdy se 20 žádostí dostanou, bude fronta pro příchozí požadavky mnohem menší (Pokud má vůbec vše) a server nebude pomalý.</span><span class="sxs-lookup"><span data-stu-id="5f307-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="5f307-168">I když se jedná o contrived příklad, funguje v reálném světě velmi podobným způsobem.</span><span class="sxs-lookup"><span data-stu-id="5f307-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="5f307-169">Ve skutečnosti můžete očekávat, že server bude schopen zpracovat pořadí většího počtu požadavků pomocí `async` a, `await` než kdyby vyhradí vlákno pro každý požadavek, který obdrží.</span><span class="sxs-lookup"><span data-stu-id="5f307-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="5f307-170">Co to znamená pro klientský scénář?</span><span class="sxs-lookup"><span data-stu-id="5f307-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="5f307-171">Největším ziskem při `async` používání `await` a pro klientské aplikace je zvýšení rychlosti odezvy.</span><span class="sxs-lookup"><span data-stu-id="5f307-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="5f307-172">I když lze aplikaci nastavit jako odezvu ručním vytvářením vláken, je operace vytvoření vlákna náročná na to, že právě používá `async` a. `await`</span><span class="sxs-lookup"><span data-stu-id="5f307-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="5f307-173">Zvláště pro něco podobného mobilní hře, což ovlivňuje co nejmenší stav vlákna uživatelského rozhraní, kde je důležité vstup/výstup.</span><span class="sxs-lookup"><span data-stu-id="5f307-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="5f307-174">Důležitější je, vzhledem k tomu, že práce vázané na vstupně-výstupní operace tráví prakticky bez času na procesoru, což vyhradí celé PROCESORové vlákno, aby fungovalo zlomek, by mohlo být špatné využití prostředků.</span><span class="sxs-lookup"><span data-stu-id="5f307-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="5f307-175">Kromě toho odesílání práce do vlákna uživatelského rozhraní (například aktualizace uživatelského rozhraní) je velmi jednoduché s `async` metodami a nevyžaduje další práci (například volání delegáta bezpečného pro přístup z více vláken).</span><span class="sxs-lookup"><span data-stu-id="5f307-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="5f307-176">Hlubší podrobně do úlohy a úlohy\<T > pro operace vázané na procesor</span><span class="sxs-lookup"><span data-stu-id="5f307-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="5f307-177">Kód vázaný `async` na procesor je trochu jiný než kód vázaný `async` na vstupně-výstupní operace.</span><span class="sxs-lookup"><span data-stu-id="5f307-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="5f307-178">Vzhledem k tomu, že práce se provádí na procesoru, neexistuje žádný způsob, jak se vyhnout vyhradit vlákno pro výpočet.</span><span class="sxs-lookup"><span data-stu-id="5f307-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="5f307-179">Použití `async` a`await` poskytuje čistě způsob, jak pracovat s vláknem na pozadí a udržet volající asynchronní metody reagovat.</span><span class="sxs-lookup"><span data-stu-id="5f307-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="5f307-180">Všimněte si, že to neposkytuje žádnou ochranu pro sdílená data.</span><span class="sxs-lookup"><span data-stu-id="5f307-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="5f307-181">Pokud používáte sdílená data, budete stále muset použít vhodnou strategii synchronizace.</span><span class="sxs-lookup"><span data-stu-id="5f307-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="5f307-182">Zde je zobrazení asynchronního volání vázané na procesor 10 000:</span><span class="sxs-lookup"><span data-stu-id="5f307-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="5f307-183">`CalculateResult()`provede se ve vlákně, ve kterém byla volána.</span><span class="sxs-lookup"><span data-stu-id="5f307-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="5f307-184">Při volání `Task.Run`do fronty zařadí nákladné operace vázané na procesor, `DoExpensiveCalculation()`ve fondu `Task<int>` vláken a získá popisovač.</span><span class="sxs-lookup"><span data-stu-id="5f307-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="5f307-185">`DoExpensiveCalculation()`je nakonec spouštěn souběžně v dalším dostupném vlákně, což je pravděpodobný jiný procesor.</span><span class="sxs-lookup"><span data-stu-id="5f307-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="5f307-186">Je možné provést souběžnou práci, zatímco `DoExpensiveCalculation()` je zaneprázdněna jiným vláknem, protože vlákno, které `CalculateResult()` se volá, je stále spuštěno.</span><span class="sxs-lookup"><span data-stu-id="5f307-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="5f307-187">Po `await` zjištění, že `CalculateResult()` spuštění je vráceno volajícímu, což umožňuje, aby se v průběhu `DoExpensiveCalculation()` provádění jiné práce s aktuálním vláknem prováděla výsledek.</span><span class="sxs-lookup"><span data-stu-id="5f307-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="5f307-188">Po dokončení je výsledek zařazen do fronty pro spuštění v hlavním vlákně.</span><span class="sxs-lookup"><span data-stu-id="5f307-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="5f307-189">Nakonec se hlavní vlákno vrátí ke spuštění `CalculateResult()`a v tomto okamžiku bude mít `DoExpensiveCalculation()`výsledek.</span><span class="sxs-lookup"><span data-stu-id="5f307-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="5f307-190">Proč tady funguje asynchronní pomoc?</span><span class="sxs-lookup"><span data-stu-id="5f307-190">Why does async help here?</span></span>

<span data-ttu-id="5f307-191">`async`a `await` jsou osvědčenými postupy pro správu práce vázané na procesor, když potřebujete reagovat.</span><span class="sxs-lookup"><span data-stu-id="5f307-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="5f307-192">Je k dispozici několik vzorů pro použití asynchronních v práci vázané na procesor.</span><span class="sxs-lookup"><span data-stu-id="5f307-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="5f307-193">Je důležité si uvědomit, že pro použití asynchronního přenosu a pro těsné smyčky se nedoporučuje používat asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="5f307-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="5f307-194">Je to až na to, abyste zjistili, jak píšete kód kolem této nové funkce.</span><span class="sxs-lookup"><span data-stu-id="5f307-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="5f307-195">Viz také:</span><span class="sxs-lookup"><span data-stu-id="5f307-195">See also</span></span>

- [<span data-ttu-id="5f307-196">Asynchronní programování vC#</span><span class="sxs-lookup"><span data-stu-id="5f307-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="5f307-197">Asynchronní programování s modifikátorem Async aC#operátoru Await ()</span><span class="sxs-lookup"><span data-stu-id="5f307-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="5f307-198">Asynchronní programování vF#</span><span class="sxs-lookup"><span data-stu-id="5f307-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="5f307-199">Asynchronní programování s modifikátorem Async a operátoru Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f307-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
