---
title: Implementace metody Dispose
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 964c788c5fc1ac791ed3ddd20c9c5c972d07b2c1
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/28/2019
ms.locfileid: "70106879"
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="ae5e1-102">Implementace metody Dispose</span><span class="sxs-lookup"><span data-stu-id="ae5e1-102">Implementing a Dispose method</span></span>

<span data-ttu-id="ae5e1-103">Implementujete <xref:System.IDisposable.Dispose%2A> metodu pro uvolnění nespravovaných prostředků používaných vaší aplikací.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="ae5e1-104">Systém uvolňování paměti .NET nepřiřazuje ani neuvolní nespravovanou paměť.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="ae5e1-105">Vzor pro likvidaci objektu, na který se říká [vzor Dispose](../../../docs/standard/design-guidelines/dispose-pattern.md), ukládá pořadí životnosti objektu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-105">The pattern for disposing an object, referred to as a [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="ae5e1-106">Vzor Dispose se používá pouze pro objekty, které mají přístup k nespravovaným prostředkům, jako jsou popisovače souboru a popisovače kanálu, popisovače registru, popisovače čekání nebo ukazatele na blok nespravované paměti.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="ae5e1-107">Důvodem je skutečnost, že systém uvolňování paměti je velmi efektivní při zpětném získávání nepoužitých spravovaných objektů, nedokáže však získat zpět nespravované objekty.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="ae5e1-108">Vzor Dispose má dvě varianty:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-108">The dispose pattern has two variations:</span></span>  
  
- <span data-ttu-id="ae5e1-109">Zabalíte každý nespravovaný prostředek, který typ používá v bezpečném popisovači (to znamená ve třídě odvozené <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>z).</span><span class="sxs-lookup"><span data-stu-id="ae5e1-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ae5e1-110">V tomto případě implementujete <xref:System.IDisposable> rozhraní a další `Dispose(Boolean)` metodu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="ae5e1-111">Toto je doporučená varianta a nevyžaduje přepsání <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="ae5e1-112">Obor názvů poskytuje sadu tříd odvozených z <xref:System.Runtime.InteropServices.SafeHandle>, které jsou uvedeny v části [použití bezpečných popisovačů](#SafeHandles) . <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ae5e1-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="ae5e1-113">Pokud nemůžete najít třídu, která je vhodná pro uvolnění nespravovaného prostředku, můžete implementovat vlastní podtřídu <xref:System.Runtime.InteropServices.SafeHandle>třídy.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
- <span data-ttu-id="ae5e1-114">Implementujete <xref:System.IDisposable> rozhraní a další `Dispose(Boolean)` metodu <xref:System.Object.Finalize%2A?displayProperty=nameWithType> a také přepíšete metodu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ae5e1-115">Je nutné přepsat <xref:System.Object.Finalize%2A> , aby bylo zajištěno, že nespravované prostředky budou <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> odstraněny, pokud vaše implementace není volána příjemcem vašeho typu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="ae5e1-116">Použijete-li doporučený postup popsaný v předchozí odrážce <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> , třída to provede vaším jménem.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="ae5e1-117">Aby bylo možné zajistit, aby se prostředky vždy vyčistily <xref:System.IDisposable.Dispose%2A> , je třeba volat metodu vícekrát, aniž by došlo k vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="ae5e1-118">Příklad kódu, který je k <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> dispozici pro metodu, ukazuje, jak agresivní uvolňování paměti může způsobit spuštění finalizační metody v době, kdy je stále prováděn člen uvolněného objektu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</span></span> <span data-ttu-id="ae5e1-119">Je vhodné zavolat <xref:System.GC.KeepAlive%2A> metodu na konci <xref:System.IDisposable.Dispose%2A> zdlouhavé metody.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-119">It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="ae5e1-120">Dispose() a Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="ae5e1-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="ae5e1-121">Rozhraní vyžaduje implementaci jediné metody bez parametrů, <xref:System.IDisposable.Dispose%2A>. <xref:System.IDisposable></span><span class="sxs-lookup"><span data-stu-id="ae5e1-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="ae5e1-122">Nicméně vzor Dispose vyžaduje, aby `Dispose` byly implementovány dvě metody:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
- <span data-ttu-id="ae5e1-123">Veřejná nevirtuální (`NonInheritable` v Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementace, která nemá žádné parametry.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
- <span data-ttu-id="ae5e1-124">Chráněná virtuální (`Overridable` v Visual Basic) `Dispose` metoda, jejíž signatura je:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="ae5e1-125">Přetížení metody Dispose ()</span><span class="sxs-lookup"><span data-stu-id="ae5e1-125">The Dispose() overload</span></span>

<span data-ttu-id="ae5e1-126">Vzhledem k tomu, že veřejná, nevirtuální (`NonInheritable` v Visual Basic), `Dispose` Metoda bez parametrů je volána příjemcem typu, jeho účelem je uvolnit nespravované prostředky a označit, že finalizační metoda, je-li k dispozici, nemusí být spuštěna.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="ae5e1-127">Z tohoto důvodu má standardní implementaci:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="ae5e1-128">Metoda provádí vyčištění všech objektů, takže systém uvolňování paměti již nemusí volat <xref:System.Object.Finalize%2A?displayProperty=nameWithType> přepis objektů. `Dispose`</span><span class="sxs-lookup"><span data-stu-id="ae5e1-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="ae5e1-129">Proto volání <xref:System.GC.SuppressFinalize%2A> metody zabrání systému uvolňování paměti ve spuštění finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="ae5e1-130">Pokud typ nemá finalizační metodu, volání <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="ae5e1-131">Všimněte si, že skutečná práce uvolnění nespravovaných prostředků je prováděna druhým přetížením `Dispose` metody.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="ae5e1-132">Přetížení Dispose (Boolean)</span><span class="sxs-lookup"><span data-stu-id="ae5e1-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="ae5e1-133">Ve druhém přetížení je <xref:System.Boolean> parametr *disposing* , který označuje, zda <xref:System.IDisposable.Dispose%2A> volání metody pochází z metody (její hodnota je `true`) nebo z finalizační metody (její hodnota je `false`).</span><span class="sxs-lookup"><span data-stu-id="ae5e1-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="ae5e1-134">Tělo metody sestává ze dvou bloků kódu:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-134">The body of the method consists of two blocks of code:</span></span>  
  
- <span data-ttu-id="ae5e1-135">Blok, který uvolní nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="ae5e1-136">Tento blok se provede bez ohledu na hodnotu `disposing` parametru.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
- <span data-ttu-id="ae5e1-137">Podmíněný blok, který uvolní spravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="ae5e1-138">Tento blok `disposing` se spustí, pokud je `true`hodnota.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="ae5e1-139">Mezi uvolněné spravované prostředky patří:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="ae5e1-140">**Spravované objekty, které <xref:System.IDisposable>implementují.**</span><span class="sxs-lookup"><span data-stu-id="ae5e1-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="ae5e1-141">Podmíněný blok lze použít k volání jejich <xref:System.IDisposable.Dispose%2A> implementace.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="ae5e1-142">Pokud jste použili bezpečný popisovač k zabalení nespravovaného prostředku, měli byste zavolat <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementaci zde.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="ae5e1-143">**Spravované objekty, které využívají velké množství paměti nebo využívají omezených prostředky.**</span><span class="sxs-lookup"><span data-stu-id="ae5e1-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="ae5e1-144">Uvolnění těchto objektů explicitně v `Dispose` metodě je uvolňuje rychleji, než kdyby byly uvolněny nedeterministické systémem uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="ae5e1-145">Pokud volání metody pochází z finalizační metody (tj. Pokud je určena `false`pro řazení), je spuštěn pouze kód, který uvolní nespravované prostředky.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="ae5e1-146">Protože pořadí, ve kterém uvolňování paměti zničí spravované objekty během finalizace není definováno, volání tohoto `Dispose` přetížení s `false` hodnotou brání finalizační metodě v pokusu o vydání spravovaných prostředků, které mohou mít již bylo uvolněno.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="ae5e1-147">Implementace vzoru Dispose pro základní třídu</span><span class="sxs-lookup"><span data-stu-id="ae5e1-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="ae5e1-148">Pokud implementujete vzor Dispose pro základní třídu, musíte poskytnout následující:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="ae5e1-149">Tento model byste měli implementovat pro všechny základní třídy, které <xref:System.IDisposable.Dispose> implementují a `sealed` nejsou`NotInheritable` (v Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ae5e1-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
- <span data-ttu-id="ae5e1-150">Implementace, která `Dispose(Boolean)` volá metodu. <xref:System.IDisposable.Dispose%2A></span><span class="sxs-lookup"><span data-stu-id="ae5e1-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
- <span data-ttu-id="ae5e1-151">`Dispose(Boolean)` Metoda, která provádí skutečnou práci uvolnění prostředků.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
- <span data-ttu-id="ae5e1-152">Buď třída odvozená z <xref:System.Runtime.InteropServices.SafeHandle> , která zabalí váš nespravovaný prostředek (doporučeno), nebo přepíše <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ae5e1-153"><xref:System.Runtime.InteropServices.SafeHandle> Třída poskytuje finalizační metodu, která vám uvolní, abyste ji nemuseli nakódovat.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="ae5e1-154">Zde je obecný vzor pro implementaci vzoru dispose pro základní třídu, která používá bezpečný popisovač.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="ae5e1-155">Předchozí příklad používá <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objekt k ilustraci vzoru; namísto toho lze použít libovolný objekt odvozený od <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="ae5e1-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="ae5e1-156">Všimněte si, že v příkladu není správně vytvořena instance <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="ae5e1-157">Zde je obecný vzor pro implementaci vzoru dispose pro základní třídu, která přepisuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="ae5e1-158">V C#můžete přepsat <xref:System.Object.Finalize%2A?displayProperty=nameWithType> definováním destruktoru [](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="ae5e1-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="ae5e1-159">Implementace vzoru Dispose pro odvozenou třídu</span><span class="sxs-lookup"><span data-stu-id="ae5e1-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="ae5e1-160">Třída odvozená od třídy, která implementuje <xref:System.IDisposable> rozhraní, by neměla implementovat <xref:System.IDisposable>, protože implementace <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> základní třídy je zděděna svými odvozenými třídami.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="ae5e1-161">Pokud chcete namísto toho implementovat pro odvozenou třídu vzor Dispose, musíte poskytnout následující:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-161">Instead, to implement the dispose pattern for a derived class, you provide the following:</span></span>  
  
- <span data-ttu-id="ae5e1-162">`protected Dispose(Boolean)` Metoda, která přepíše metodu základní třídy a provede skutečnou práci uvolnění prostředků odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="ae5e1-163">Tato metoda by měla také volat `Dispose(Boolean)` metodu základní třídy a předat její stav disposing argumentu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-163">This method should also call the `Dispose(Boolean)` method of the base class and pass its disposing status for the argument.</span></span>  
  
- <span data-ttu-id="ae5e1-164">Buď třída odvozená z <xref:System.Runtime.InteropServices.SafeHandle> , která zabalí váš nespravovaný prostředek (doporučeno), nebo přepíše <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ae5e1-165"><xref:System.Runtime.InteropServices.SafeHandle> Třída poskytuje finalizační metodu, která vám uvolní, abyste ji nemuseli nakódovat.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="ae5e1-166">Pokud zadáte finalizační metodu, měla by volat `Dispose(Boolean)` přetížení s argumentem `false`disposing.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="ae5e1-167">Toto je obecný vzor implementace vzoru Dispose pro odvozenou třídu, která používá bezpečný popisovač:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="ae5e1-168">Předchozí příklad používá <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objekt k ilustraci vzoru; namísto toho lze použít libovolný objekt odvozený od <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="ae5e1-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="ae5e1-169">Všimněte si, že v příkladu není správně vytvořena instance <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="ae5e1-170">Zde je obecný vzor pro implementaci vzoru dispose pro odvozenou třídu, která přepisuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="ae5e1-171">V C#můžete přepsat <xref:System.Object.Finalize%2A?displayProperty=nameWithType> definováním destruktoru [](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="ae5e1-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>   
## <a name="using-safe-handles"></a><span data-ttu-id="ae5e1-172">Používání bezpečných popisovačů</span><span class="sxs-lookup"><span data-stu-id="ae5e1-172">Using safe handles</span></span>

<span data-ttu-id="ae5e1-173">Psaní kódu pro finalizační metodu objektu je složitý úkol, který může způsobit problémy, není-li prováděn správně.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="ae5e1-174">Proto doporučujeme místo implementace finalizační metody vytvořit <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objekty.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="ae5e1-175">Třídy odvozené od <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> třídy zjednodušují problémy životního cyklu objektů přiřazením a uvolněním popisovačů bez přerušení.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="ae5e1-176">Obsahují důležitou finalizační metodu, která se zaručeně spustí během uvolňování domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="ae5e1-177">Další informace o výhodách používání bezpečného popisovače najdete v tématu <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae5e1-178">Následující odvozené třídy v <xref:Microsoft.Win32.SafeHandles> oboru názvů poskytují bezpečné popisovače:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
- <span data-ttu-id="ae5e1-179">Třídy, a<xref:Microsoft.Win32.SafeHandles.SafePipeHandle> pro soubory, soubory mapované paměti a kanály. <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle></span><span class="sxs-lookup"><span data-stu-id="ae5e1-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
- <span data-ttu-id="ae5e1-180"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> Třída pro zobrazení paměti.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
- <span data-ttu-id="ae5e1-181">Třídy, a<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>prokonstrukcekryptografie. <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle> <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle></span><span class="sxs-lookup"><span data-stu-id="ae5e1-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
- <span data-ttu-id="ae5e1-182"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Třída pro klíče registru.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
- <span data-ttu-id="ae5e1-183"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Třída pro obslužné rutiny čekání.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="ae5e1-184">Používání bezpečného popisovače pro implementaci vzoru Dispose pro základní třídu</span><span class="sxs-lookup"><span data-stu-id="ae5e1-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="ae5e1-185">Následující příklad znázorňuje vzor Dispose pro základní třídu `DisposableStreamResource`,, který používá bezpečný popisovač k zapouzdření nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="ae5e1-186">Definuje `DisposableResource` třídu, která <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> používá k zabalení <xref:System.IO.Stream> objektu, který představuje otevřený soubor.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="ae5e1-187">Metoda také obsahuje jedinou `Size`vlastnost, která vrátí celkový počet bajtů v datovém proudu souboru. `DisposableResource`</span><span class="sxs-lookup"><span data-stu-id="ae5e1-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="ae5e1-188">Používání bezpečného popisovače pro implementaci vzoru Dispose pro odvozenou třídu</span><span class="sxs-lookup"><span data-stu-id="ae5e1-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="ae5e1-189">Následující příklad znázorňuje vzor Dispose pro odvozenou třídu `DisposableStreamResource2`,, která dědí `DisposableStreamResource` z třídy uvedené v předchozím příkladu.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="ae5e1-190">Třída přidá další metodu, `WriteFileInfo`a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> pomocí objektu zabalí popisovač zapisovatelného souboru.</span><span class="sxs-lookup"><span data-stu-id="ae5e1-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="ae5e1-191">Viz také:</span><span class="sxs-lookup"><span data-stu-id="ae5e1-191">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="ae5e1-192">Postupy: Definice a používání tříd a struktur (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="ae5e1-192">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
- [<span data-ttu-id="ae5e1-193">Vzor pro metodu Dispose</span><span class="sxs-lookup"><span data-stu-id="ae5e1-193">Dispose Pattern</span></span>](../../../docs/standard/design-guidelines/dispose-pattern.md)
