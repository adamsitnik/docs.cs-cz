---
title: Připojené a odpojené podřízené úlohy
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, child tasks
ms.assetid: c95788bf-90a6-4e96-b7bc-58e36a228cc5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 29383d0b7f125111071ac131d8a822dba811032e
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/23/2019
ms.locfileid: "54603310"
---
# <a name="attached-and-detached-child-tasks"></a><span data-ttu-id="91e3a-102">Připojené a odpojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-102">Attached and Detached Child Tasks</span></span>
<span data-ttu-id="91e3a-103">A *podřízená úloha* (nebo *vnořená úloha*) je <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instanci, která je vytvořena v uživatelském delegátu jiného úkolu, který se označuje jako *nadřazená úloha*.</span><span class="sxs-lookup"><span data-stu-id="91e3a-103">A *child task* (or *nested task*) is a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instance that is created in the user delegate of another task, which is known as the *parent task*.</span></span> <span data-ttu-id="91e3a-104">Podřízená úloha může odpojit nebo připojen.</span><span class="sxs-lookup"><span data-stu-id="91e3a-104">A child task can be either detached or attached.</span></span> <span data-ttu-id="91e3a-105">A *odpojenou podřízenou úlohu* je úkol, který se spustí bez ohledu na jejich svého nadřazeného objektu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-105">A *detached child task* is a task that executes independently of its parent.</span></span> <span data-ttu-id="91e3a-106">*Připojená podřízená úloha* je vnořená úloha, která se vytvoří s <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> možnost, jejíž nadřazený prvek není explicitně nebo implicitně zakazují, aby ho z přímého připojení.</span><span class="sxs-lookup"><span data-stu-id="91e3a-106">An *attached child task* is a nested task that is created with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option whose parent does not explicitly or by default prohibit it from being attached.</span></span> <span data-ttu-id="91e3a-107">Úkol může vytvořit libovolný počet připojené a odpojené podřízené úlohy, omezen pouze systémovými prostředky.</span><span class="sxs-lookup"><span data-stu-id="91e3a-107">A task may create any number of attached and detached child tasks, limited only by system resources.</span></span>  
  
 <span data-ttu-id="91e3a-108">V následující tabulce jsou uvedeny základní rozdíly mezi dvěma druhy podřízených úkolů.</span><span class="sxs-lookup"><span data-stu-id="91e3a-108">The following table lists the basic differences between the two kinds of child tasks.</span></span>  
  
|<span data-ttu-id="91e3a-109">Kategorie</span><span class="sxs-lookup"><span data-stu-id="91e3a-109">Category</span></span>|<span data-ttu-id="91e3a-110">Odpojených podřízených úloh</span><span class="sxs-lookup"><span data-stu-id="91e3a-110">Detached child tasks</span></span>|<span data-ttu-id="91e3a-111">Připojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-111">Attached child tasks</span></span>|  
|--------------|--------------------------|--------------------------|  
|<span data-ttu-id="91e3a-112">Nadřazený prvek čeká na dokončení podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="91e3a-112">Parent waits for child tasks to complete.</span></span>|<span data-ttu-id="91e3a-113">Ne</span><span class="sxs-lookup"><span data-stu-id="91e3a-113">No</span></span>|<span data-ttu-id="91e3a-114">Ano</span><span class="sxs-lookup"><span data-stu-id="91e3a-114">Yes</span></span>|  
|<span data-ttu-id="91e3a-115">Nadřazená úloha šíří výjimek vyvolaných podřízenými úlohami.</span><span class="sxs-lookup"><span data-stu-id="91e3a-115">Parent propagates exceptions thrown by child tasks.</span></span>|<span data-ttu-id="91e3a-116">Ne</span><span class="sxs-lookup"><span data-stu-id="91e3a-116">No</span></span>|<span data-ttu-id="91e3a-117">Ano</span><span class="sxs-lookup"><span data-stu-id="91e3a-117">Yes</span></span>|  
|<span data-ttu-id="91e3a-118">Stav nadřazeného objektu závisí na stavu objektu podřízeného.</span><span class="sxs-lookup"><span data-stu-id="91e3a-118">Status of parent depends on status of child.</span></span>|<span data-ttu-id="91e3a-119">Ne</span><span class="sxs-lookup"><span data-stu-id="91e3a-119">No</span></span>|<span data-ttu-id="91e3a-120">Ano</span><span class="sxs-lookup"><span data-stu-id="91e3a-120">Yes</span></span>|  
  
 <span data-ttu-id="91e3a-121">Ve většině scénářů doporučujeme použití odpojených podřízených úloh, protože mají méně složité jejich vztahy s ostatními úlohami.</span><span class="sxs-lookup"><span data-stu-id="91e3a-121">In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</span></span> <span data-ttu-id="91e3a-122">To znamená, proč jsou úlohy vytvářené uvnitř nadřízených úloh odpojeny ve výchozím nastavení, a je nutné explicitně zadat <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> možnost vytvořit připojenou podřízenou úlohu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-122">That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option to create an attached child task.</span></span>  
  
## <a name="detached-child-tasks"></a><span data-ttu-id="91e3a-123">Odpojených podřízených úloh</span><span class="sxs-lookup"><span data-stu-id="91e3a-123">Detached child tasks</span></span>  
 <span data-ttu-id="91e3a-124">I když podřízená úloha vytvořena nadřazenou úlohou, ve výchozím nastavení je nezávislá na nadřazené úloze.</span><span class="sxs-lookup"><span data-stu-id="91e3a-124">Although a child task is created by a parent task, by default it is independent of the parent task.</span></span> <span data-ttu-id="91e3a-125">V následujícím příkladu nadřazená úloha vytvoří jednoduchou podřízenou úlohu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-125">In the following example, a parent task creates one simple child task.</span></span> <span data-ttu-id="91e3a-126">Pokud ukázkový kód spustíte vícekrát, můžete si všimnout, že výstup z příkladu se liší od zobrazení a také, že výstup se může změnit pokaždé, když spustíte kód.</span><span class="sxs-lookup"><span data-stu-id="91e3a-126">If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</span></span> <span data-ttu-id="91e3a-127">K tomu dojde, protože nadřazené a podřízené úlohy se provádějí nezávisle na sobě navzájem; podřízená je odpojená úloha.</span><span class="sxs-lookup"><span data-stu-id="91e3a-127">This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</span></span> <span data-ttu-id="91e3a-128">V příkladu pouze čeká na dokončení nadřazených úloh a podřízená úloha pravděpodobně nebude spuštěna nebo dokončena před konzolovou aplikaci ukončí.</span><span class="sxs-lookup"><span data-stu-id="91e3a-128">The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/nested1.cs#1)]
 [!code-vb[TPL_ChildTasks#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/nested1.vb#1)]  
  
 <span data-ttu-id="91e3a-129">Pokud podřízená úloha je reprezentována <xref:System.Threading.Tasks.Task%601> objekt spíše než <xref:System.Threading.Tasks.Task> objektu, můžete zajistit, že nadřazená úloha bude čekat na podřízenou k dokončení přístupu k <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost podřízené, i pokud se jedná odpojená podřízená úloha.</span><span class="sxs-lookup"><span data-stu-id="91e3a-129">If the child task is represented by a <xref:System.Threading.Tasks.Task%601> object rather than a <xref:System.Threading.Tasks.Task> object, you can ensure that the parent task will wait for the child to complete by accessing the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the child even if it is a detached child task.</span></span> <span data-ttu-id="91e3a-130"><xref:System.Threading.Tasks.Task%601.Result%2A> Vlastnost blokuje až do dokončení svých úkolů, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="91e3a-130">The <xref:System.Threading.Tasks.Task%601.Result%2A> property blocks until its task completes, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/childtasks.cs#4)]
 [!code-vb[TPL_ChildTasks#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/tpl_childtasks.vb#4)]  
  
## <a name="attached-child-tasks"></a><span data-ttu-id="91e3a-131">Připojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-131">Attached child tasks</span></span>  
 <span data-ttu-id="91e3a-132">Na rozdíl od odpojených podřízených úloh jsou připojené podřízené úlohy úzce synchronizovány s nadřazenými.</span><span class="sxs-lookup"><span data-stu-id="91e3a-132">Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</span></span> <span data-ttu-id="91e3a-133">Odpojenou podřízenou úlohu z předchozího příkladu na připojenou podřízenou úlohu můžete změnit pomocí <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> možnost v příkazu vytvoření úlohy, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-133">You can change the detached child task in the previous example to an attached child task by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option in the task creation statement, as shown in the following example.</span></span> <span data-ttu-id="91e3a-134">V tomto kódu se připojené podřízené úlohy dokončí před nadřazenými.</span><span class="sxs-lookup"><span data-stu-id="91e3a-134">In this code, the attached child task completes before its parent.</span></span> <span data-ttu-id="91e3a-135">V důsledku toho výstup z příkladu je stejný při každém spuštění kódu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-135">As a result, the output from the example is the same each time you run the code.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1.cs#2)]
 [!code-vb[TPL_ChildTasks#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1.vb#2)]  
  
 <span data-ttu-id="91e3a-136">Připojené podřízené úlohy můžete použít k vytvoření úzce synchronizovaných grafů asynchronních operací.</span><span class="sxs-lookup"><span data-stu-id="91e3a-136">You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</span></span>  
  
 <span data-ttu-id="91e3a-137">Podřízená úloha však můžete připojit k nadřazené úloze pouze v případě, že jeho nadřazený objekt nevylučuje připojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="91e3a-137">However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</span></span> <span data-ttu-id="91e3a-138">Nadřízené úlohy můžete explicitně zabránění podřízené úkoly připojení k nim zadáním <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> možnost v konstruktoru třídy nadřazené úloze nebo <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="91e3a-138">Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option in the parent task's class constructor or the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="91e3a-139">Nadřazené úlohy implicitně zabránit podřízené úlohy k nim připojí, když jsou vytvořeny pomocí volání <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="91e3a-139">Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="91e3a-140">Toto dokládá následující příklad.</span><span class="sxs-lookup"><span data-stu-id="91e3a-140">The following example illustrates this.</span></span> <span data-ttu-id="91e3a-141">Je stejný jako předchozí příklad, s tím rozdílem, že nadřazená úloha je vytvořen zavoláním <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> metoda místo <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="91e3a-141">It is identical to the previous example, except that the parent task is created by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> method rather than the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="91e3a-142">Vzhledem k tomu, že podřízená úloha není možné se připojit k nadřazené úloze, výstup z příkladu nepředvídatelné.</span><span class="sxs-lookup"><span data-stu-id="91e3a-142">Because the child task is not able to attach to its parent, the output from the example is unpredictable.</span></span> <span data-ttu-id="91e3a-143">Protože úloha vytváření výchozí možnosti pro <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> zahrnout přetížení <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, tento příklad je funkčně srovnatelný s první příklad v části "Odpojené podřízené úlohy".</span><span class="sxs-lookup"><span data-stu-id="91e3a-143">Because the default task creation options for the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> overloads include <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1a.cs#3)]
 [!code-vb[TPL_ChildTasks#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1a.vb#3)]  
  
## <a name="exceptions-in-child-tasks"></a><span data-ttu-id="91e3a-144">Výjimky v podřízených úkolech</span><span class="sxs-lookup"><span data-stu-id="91e3a-144">Exceptions in child tasks</span></span>  
 <span data-ttu-id="91e3a-145">Pokud odpojená podřízená úloha vyvolá výjimku, musí být tato výjimka zjištěnými nebo zpracovávána přímo v nadřazené úloze, stejně jako u jakékoli úlohy bez vnoření.</span><span class="sxs-lookup"><span data-stu-id="91e3a-145">If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</span></span> <span data-ttu-id="91e3a-146">Pokud připojená podřízená úloha vyvolá výjimku, výjimka se automaticky šíří do nadřazené úlohy a zpět k vláknu, které čeká nebo se pokusí o přístup k úkolu <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="91e3a-146">If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="91e3a-147">Proto pomocí připojené podřízené úlohy můžete zpracovávat všechny výjimky v jednom místě ve volání <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> na volajícím vlákně.</span><span class="sxs-lookup"><span data-stu-id="91e3a-147">Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> on the calling thread.</span></span> <span data-ttu-id="91e3a-148">Další informace najdete v tématu [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="91e3a-148">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="cancellation-and-child-tasks"></a><span data-ttu-id="91e3a-149">Zrušení a podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-149">Cancellation and child tasks</span></span>  
 <span data-ttu-id="91e3a-150">Zrušení úlohy je kooperativní.</span><span class="sxs-lookup"><span data-stu-id="91e3a-150">Task cancellation is cooperative.</span></span> <span data-ttu-id="91e3a-151">To znamená aby se úloha zrušila, každá připojená nebo odpojená podřízená úloha musí sledovat stav token zrušení.</span><span class="sxs-lookup"><span data-stu-id="91e3a-151">That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</span></span> <span data-ttu-id="91e3a-152">Pokud chcete zrušit nadřazenou položku a všechny jeho podřízené objekty s použitím pouze jedné žádosti, předejte stejný token jako argument pro všechny úlohy a poskytují v jednotlivých úkolech logiku odpovědi na žádost v každé úloze.</span><span class="sxs-lookup"><span data-stu-id="91e3a-152">If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</span></span> <span data-ttu-id="91e3a-153">Další informace najdete v tématu [zrušení úlohy](../../../docs/standard/parallel-programming/task-cancellation.md) a [jak: Zrušení úlohy a jejích potomků](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="91e3a-153">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
### <a name="when-the-parent-cancels"></a><span data-ttu-id="91e3a-154">Při zrušení nadřazeného</span><span class="sxs-lookup"><span data-stu-id="91e3a-154">When the parent cancels</span></span>  
 <span data-ttu-id="91e3a-155">Pokud nadřazená úloha zruší sama sebe, před spuštěním jeho podřízené úloze, nikdy spouštěna.</span><span class="sxs-lookup"><span data-stu-id="91e3a-155">If a parent cancels itself before its child task is started, the child never starts.</span></span> <span data-ttu-id="91e3a-156">Pokud nadřazená úloha zruší sama sebe, po její podřízená úloha je již spuštěna, podřízená úloha poběží do konce ledaže má svojí vlastní logiku zrušení.</span><span class="sxs-lookup"><span data-stu-id="91e3a-156">If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</span></span> <span data-ttu-id="91e3a-157">Další informace najdete v tématu [zrušení úlohy](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="91e3a-157">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="when-a-detached-child-task-cancels"></a><span data-ttu-id="91e3a-158">Při zrušení odpojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-158">When a detached child task cancels</span></span>  
 <span data-ttu-id="91e3a-159">Pokud odpojená podřízená úloha zruší sama pomocí stejného tokenu, který byl předán nadřazenému prvku a nadřazeného nečeká podřízenou úlohu, nejsou šířeny žádné výjimky, protože všechny výjimky jsou považovány za neškodné kooperativní zrušení.</span><span class="sxs-lookup"><span data-stu-id="91e3a-159">If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</span></span> <span data-ttu-id="91e3a-160">Toto chování je stejné jako u libovolných úloh nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="91e3a-160">This behavior is the same as that of any top-level task.</span></span>  
  
### <a name="when-an-attached-child-task-cancels"></a><span data-ttu-id="91e3a-161">Při zrušení připojené podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="91e3a-161">When an attached child task cancels</span></span>  
 <span data-ttu-id="91e3a-162">Pokud připojená podřízená úloha zruší sama pomocí stejného tokenu, který byl předán nadřízené úloze, <xref:System.Threading.Tasks.TaskCanceledException> je postoupena do spojovacího vlákna uvnitř <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="91e3a-162">When an attached child task cancels itself by using the same token that was passed to its parent task, a <xref:System.Threading.Tasks.TaskCanceledException> is propagated to the joining thread inside an <xref:System.AggregateException>.</span></span> <span data-ttu-id="91e3a-163">Je nutné počkat nadřazené úloze, aby bylo možné zpracovat všechny neškodné výjimky kromě všechny neškodné výjimky, které byly postoupeny nahoru grafem připojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="91e3a-163">You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</span></span>  
  
 <span data-ttu-id="91e3a-164">Další informace najdete v tématu [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="91e3a-164">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="preventing-a-child-task-from-attaching-to-its-parent"></a><span data-ttu-id="91e3a-165">Zabránění podřízené úloze, mohla připojit k nadřazené</span><span class="sxs-lookup"><span data-stu-id="91e3a-165">Preventing a child task from attaching to its parent</span></span>  
 <span data-ttu-id="91e3a-166">Neošetřená výjimka, která je vyvolána podřízenou úlohou se šíří do nadřazené úlohy.</span><span class="sxs-lookup"><span data-stu-id="91e3a-166">An unhandled exception that is thrown by a child task is propagated to the parent task.</span></span> <span data-ttu-id="91e3a-167">Toto chování můžete sledovat všech výjimek podřízené úlohy z jednoho kořene místo procházení stromu úloh.</span><span class="sxs-lookup"><span data-stu-id="91e3a-167">You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</span></span> <span data-ttu-id="91e3a-168">Šíření výjimek však může být problematické, pokud nadřazená úloha neočekává přílohu z jiného kódu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-168">However, exception propagation can be problematic when a parent task does not expect attachment from other code.</span></span> <span data-ttu-id="91e3a-169">Představte si třeba aplikaci, která volá komponenty knihovny třetí strany z <xref:System.Threading.Tasks.Task> objektu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-169">For example, consider an app that calls a third-party library component from a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="91e3a-170">Pokud součást knihovny třetích stran také vytvoří <xref:System.Threading.Tasks.Task> objektu a určuje <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> připojit k nadřazené úloze, všechny neošetřené výjimky, ke kterým dochází v podřízené úloze se promítnou do nadřazené.</span><span class="sxs-lookup"><span data-stu-id="91e3a-170">If the third-party library component also creates a <xref:System.Threading.Tasks.Task> object and specifies <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</span></span> <span data-ttu-id="91e3a-171">To může vést k neočekávanému chování v hlavní aplikaci.</span><span class="sxs-lookup"><span data-stu-id="91e3a-171">This could lead to unexpected behavior in the main app.</span></span>  
  
 <span data-ttu-id="91e3a-172">Chcete-li zabránit podřízené úloze v připojení k nadřazené úloze, zadejte <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> při vytváření nadřazeného možnost <xref:System.Threading.Tasks.Task> nebo <xref:System.Threading.Tasks.Task%601> objektu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-172">To prevent a child task from attaching to its parent task, specify the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option when you create the parent <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="91e3a-173">Při pokusí připojit k nadřazenému úkolu a ten specifikuje <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> možnost, podřízená úloha nebude možné se připojit k nadřazené a spustí stejně jako <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> nebyla zadána možnost.</span><span class="sxs-lookup"><span data-stu-id="91e3a-173">When a task tries to attach to its parent and the parent specifies the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option, the child task will not be able to attach to a parent and will execute just as if the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option was not specified.</span></span>  
  
 <span data-ttu-id="91e3a-174">Můžete také chtít zabránit podřízené úloze v připojení k nadřazené úloze, pokud podřízená úloha neskončí v časovém limitu.</span><span class="sxs-lookup"><span data-stu-id="91e3a-174">You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</span></span> <span data-ttu-id="91e3a-175">Protože nadřazenou úlohu nedokončí až do dokončení všech podřízených úloh, může způsobit dlouhotrvající podřízená úloha celkový nízký výkon aplikace.</span><span class="sxs-lookup"><span data-stu-id="91e3a-175">Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</span></span> <span data-ttu-id="91e3a-176">Příklad, který ukazuje, jak zlepšit výkon aplikace zabráněním úlohu se připojuje k nadřazené úloze, naleznete v tématu [jak: Zabránění podřízené úloze připojení k nadřazené úloze](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span><span class="sxs-lookup"><span data-stu-id="91e3a-176">For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see [How to: Prevent a Child Task from Attaching to its Parent](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="91e3a-177">Viz také:</span><span class="sxs-lookup"><span data-stu-id="91e3a-177">See also</span></span>

- [<span data-ttu-id="91e3a-178">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="91e3a-178">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="91e3a-179">Datový paralelismus</span><span class="sxs-lookup"><span data-stu-id="91e3a-179">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)
