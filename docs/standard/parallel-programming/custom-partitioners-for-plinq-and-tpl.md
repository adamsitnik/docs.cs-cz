---
title: Vlastní dělicí metody pro PLINQ a TPL
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 42df511857d367859fc68e2d881dd5b5e2e0bfbc
ms.sourcegitcommit: d6e27023aeaffc4b5a3cb4b88685018d6284ada4
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/09/2019
ms.locfileid: "67662565"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="abe22-102">Vlastní dělicí metody pro PLINQ a TPL</span><span class="sxs-lookup"><span data-stu-id="abe22-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="abe22-103">Pro paralelní zpracování operace na zdroji dat, jedním ze základních kroků je *oddílu* zdroje do několika oddílů, které může přistupovat souběžně více vláken.</span><span class="sxs-lookup"><span data-stu-id="abe22-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="abe22-104">PLINQ a Task Parallel Library (TPL) poskytují výchozí rozdělovače, které pracují transparentně při psaní paralelního dotazu nebo <xref:System.Threading.Tasks.Parallel.ForEach%2A> smyčky.</span><span class="sxs-lookup"><span data-stu-id="abe22-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="abe22-105">Pro pokročilejší scénáře můžete zařadit vlastní dělicí metody.</span><span class="sxs-lookup"><span data-stu-id="abe22-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="abe22-106">Druhy dělení</span><span class="sxs-lookup"><span data-stu-id="abe22-106">Kinds of Partitioning</span></span>

<span data-ttu-id="abe22-107">Při vytváření oddílů zdroji dat mnoha způsoby.</span><span class="sxs-lookup"><span data-stu-id="abe22-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="abe22-108">V nejúčinnější přístupy více vláken spolupracují s cílem procesu původní zdrojové sekvence, nikoli fyzické oddělení zdroje do více dílčích sekvencí.</span><span class="sxs-lookup"><span data-stu-id="abe22-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="abe22-109">Pro pole a další indexovat zdroje <xref:System.Collections.IList> kolekce, kde délka je znám předem, *dělení rozsah* je nejjednodušší druh dělení.</span><span class="sxs-lookup"><span data-stu-id="abe22-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="abe22-110">Každé vlákno přijímá jedinečný počáteční a koncové indexy, tak, aby jeho rozsah zdroje může zpracovat bez přepsání nebo přepsání z žádného vlákna.</span><span class="sxs-lookup"><span data-stu-id="abe22-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="abe22-111">Pouze režie spojená s rozsah dělení je počáteční pracovní vytváření rozsahů; Po tomto není nutná žádná další synchronizace.</span><span class="sxs-lookup"><span data-stu-id="abe22-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="abe22-112">Tak dlouho, dokud zatížení je rozděleno rovnoměrně, je proto poskytují dobrý výkon.</span><span class="sxs-lookup"><span data-stu-id="abe22-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="abe22-113">Nevýhodou rozsah dělení je, že pokud se jedno vlákno brzy dokončí, nemůže pomoct ostatní vlákna dokončí svou práci.</span><span class="sxs-lookup"><span data-stu-id="abe22-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="abe22-114">Propojené seznamy nebo další kolekce, jejichž délka není znám, můžete použít *dělení bloků*.</span><span class="sxs-lookup"><span data-stu-id="abe22-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="abe22-115">Při dělení bloků dat, každý vlákna nebo úlohy v paralelní smyčce nebo dotaz využívá některé zdrojové prvky v jednom bloku, zpracovává je a potom se vrátí zpět k načtení dalších prvků.</span><span class="sxs-lookup"><span data-stu-id="abe22-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="abe22-116">Dělicí zajistí, že všechny prvky mají distribuovat a, že neexistují žádné duplicity.</span><span class="sxs-lookup"><span data-stu-id="abe22-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="abe22-117">Blok může být libovolné velikosti.</span><span class="sxs-lookup"><span data-stu-id="abe22-117">A chunk may be any size.</span></span> <span data-ttu-id="abe22-118">Například dělicí metodou, která je znázorněna v [jak: Implementace dynamických oddílů](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) vytvoří bloky dat, které obsahují pouze jeden element.</span><span class="sxs-lookup"><span data-stu-id="abe22-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="abe22-119">Za předpokladu, bloky dat nejsou příliš velké, tento druh dělení je ze své podstaty Vyrovnávání zatížení protože přiřazení prvky na vláknech není předem určit.</span><span class="sxs-lookup"><span data-stu-id="abe22-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="abe22-120">Dělicí ale účtovat režii synchronizace pokaždé, když vlákno je potřeba získat jiného bloku.</span><span class="sxs-lookup"><span data-stu-id="abe22-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="abe22-121">Množství synchronizace vzniklé v těchto případech je nepřímo úměrná velikosti bloky dat.</span><span class="sxs-lookup"><span data-stu-id="abe22-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="abe22-122">Obecně platí rozsah dělení probíhá pouze rychleji, pokud čas spuštění delegáta je malé a střední, zdroj má velký počet prvků a celkovou práci každý oddíl je zhruba ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="abe22-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="abe22-123">Vytváření oddílů datových dávek tedy obecně rychlejší ve většině případů.</span><span class="sxs-lookup"><span data-stu-id="abe22-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="abe22-124">U zdrojů s malý počet elementů nebo delší dobu provádění pro delegáta pak výkon bloků dat a vytváření oddílů rozsah je o stejné.</span><span class="sxs-lookup"><span data-stu-id="abe22-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="abe22-125">Dělicí metody TPL také podporují dynamické počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="abe22-126">To znamená, že můžete například vytvořit oddíly v běhu, když <xref:System.Threading.Tasks.Parallel.ForEach%2A> smyčky vytvoří nový úkol.</span><span class="sxs-lookup"><span data-stu-id="abe22-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="abe22-127">Tato funkce umožňuje rozdělovač škálovat společně s smyčky, samotného.</span><span class="sxs-lookup"><span data-stu-id="abe22-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="abe22-128">Dynamické dělicí metody jsou také ze své podstaty Vyrovnávání zatížení.</span><span class="sxs-lookup"><span data-stu-id="abe22-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="abe22-129">Při vytváření vlastního rozdělovače, musí podporovat dynamické dělení, abyste se lze použít z <xref:System.Threading.Tasks.Parallel.ForEach%2A> smyčky.</span><span class="sxs-lookup"><span data-stu-id="abe22-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="abe22-130">Konfigurace rozložení zátěže dělicí metody pro PLINQ</span><span class="sxs-lookup"><span data-stu-id="abe22-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="abe22-131">Některá přetížení <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> metody umožňují vytvořit dělicí metody pro pole nebo <xref:System.Collections.IList> zdroje a určit, zda by měl pokusit o vyrovnávat zatížení mezi vlákna.</span><span class="sxs-lookup"><span data-stu-id="abe22-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="abe22-132">Když dělicí je konfigurován pro vyrovnávání zatížení, dělení bloků dat se používá, a jsou prvky předávána do jednotlivých oddílů v menších dávkách jsou požadované.</span><span class="sxs-lookup"><span data-stu-id="abe22-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="abe22-133">Tento přístup pomáhá zajistit, že všechny oddíly mají prvky ke zpracování celé smyčka until nebo dokončení dotazu.</span><span class="sxs-lookup"><span data-stu-id="abe22-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="abe22-134">Další přetížení je možné poskytovat žádné služby Vyrovnávání zatížení dělení <xref:System.Collections.IEnumerable> zdroje.</span><span class="sxs-lookup"><span data-stu-id="abe22-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="abe22-135">Obecně platí Vyrovnávání zatížení vyžaduje oddíly pro žádosti o prvky poměrně často dělicí.</span><span class="sxs-lookup"><span data-stu-id="abe22-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="abe22-136">Naopak dělicí metodou, která nepodporuje statické dělení můžete přiřadit elementy každý rozdělovač najednou pomocí rozsah nebo blok dělení.</span><span class="sxs-lookup"><span data-stu-id="abe22-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="abe22-137">To vyžaduje, aby menší nároky na než Vyrovnávání zatížení, ale může trvat delší dobu spuštění, pokud jedno vlákno končí mnohem více práce než ostatní.</span><span class="sxs-lookup"><span data-stu-id="abe22-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="abe22-138">Ve výchozím nastavení je předána IList nebo pole, PLINQ vždy používá rozsah dělení bez vyrovnávání zatížení.</span><span class="sxs-lookup"><span data-stu-id="abe22-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="abe22-139">Chcete-li povolit Vyrovnávání zatížení pro PLINQ, použijte `Partitioner.Create` způsob, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="abe22-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="abe22-140">Nejlepší způsob, jak zjistit, jestli použít zatížení vyrovnávání v jakékoli situaci je můžete experimentovat a změřit, jak dlouho trvá, než operace dokončete podle reprezentativní zatížením a konfigurací počítače.</span><span class="sxs-lookup"><span data-stu-id="abe22-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="abe22-141">Například statické dělení může poskytnout výrazné zrychlení v počítači více jader, který má pouze několik jader, ale může způsobit zpomalení na počítačích, které mají relativně mnoha jádrech.</span><span class="sxs-lookup"><span data-stu-id="abe22-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="abe22-142">V následující tabulce jsou uvedeny dostupné přetížení <xref:System.Collections.Concurrent.Partitioner.Create%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="abe22-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="abe22-143">Tato dělicí metody nejsou omezeny na použití pouze pomocí jazyka PLINQ nebo <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="abe22-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="abe22-144">Můžete také používají se všechny vlastní paralelní konstrukce.</span><span class="sxs-lookup"><span data-stu-id="abe22-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="abe22-145">přetížení</span><span class="sxs-lookup"><span data-stu-id="abe22-145">Overload</span></span>|<span data-ttu-id="abe22-146">Použití vyrovnávání zatížení</span><span class="sxs-lookup"><span data-stu-id="abe22-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="abe22-147">Vždy</span><span class="sxs-lookup"><span data-stu-id="abe22-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="abe22-148">Když je zadaný logický argument jako true</span><span class="sxs-lookup"><span data-stu-id="abe22-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="abe22-149">Když je zadaný logický argument jako true</span><span class="sxs-lookup"><span data-stu-id="abe22-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="abe22-150">Nikdy</span><span class="sxs-lookup"><span data-stu-id="abe22-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="abe22-151">Nikdy</span><span class="sxs-lookup"><span data-stu-id="abe22-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="abe22-152">Nikdy</span><span class="sxs-lookup"><span data-stu-id="abe22-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="abe22-153">Nikdy</span><span class="sxs-lookup"><span data-stu-id="abe22-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="abe22-154">Konfigurace statický rozsah dělicí metody pro paralelní ForEach</span><span class="sxs-lookup"><span data-stu-id="abe22-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="abe22-155">V <xref:System.Threading.Tasks.Parallel.For%2A> smyčky, tělo smyčky je k dispozici na metodu jako delegát.</span><span class="sxs-lookup"><span data-stu-id="abe22-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="abe22-156">Náklady na vyvolání tohoto delegáta je stejné jako volání virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="abe22-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="abe22-157">V některých případech může být dostatečně malá, že náklady na volání delegáta při každé iteraci smyčky stane významné tělo paralelní smyčky.</span><span class="sxs-lookup"><span data-stu-id="abe22-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="abe22-158">V takových případech můžete použít jednu z <xref:System.Collections.Concurrent.Partitioner.Create%2A> přetížení k vytvoření <xref:System.Collections.Generic.IEnumerable%601> rozsah oddílů přes zdrojové elementy.</span><span class="sxs-lookup"><span data-stu-id="abe22-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="abe22-159">Pak můžete předat tuto kolekci rozsahy <xref:System.Threading.Tasks.Parallel.ForEach%2A> metoda, jehož subjekt se skládá z běžný `for` smyčky.</span><span class="sxs-lookup"><span data-stu-id="abe22-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="abe22-160">Výhodou tohoto přístupu je, že náklady na volání delegáta vzniknou pouze jednou na rozsah, nikoli po jeden element.</span><span class="sxs-lookup"><span data-stu-id="abe22-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="abe22-161">Následující příklad ukazuje základní vzor.</span><span class="sxs-lookup"><span data-stu-id="abe22-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="abe22-162">Každé vlákno ve smyčce obdrží vlastní <xref:System.Tuple%602> , která obsahuje počáteční a koncové hodnoty indexu v zadaném rozsahu dílčí.</span><span class="sxs-lookup"><span data-stu-id="abe22-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="abe22-163">Vnitřní `for` smyčky používá `fromInclusive` a `toExclusive` hodnoty pole ve smyčce nebo <xref:System.Collections.IList> přímo.</span><span class="sxs-lookup"><span data-stu-id="abe22-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="abe22-164">Jeden z <xref:System.Collections.Concurrent.Partitioner.Create%2A> přetížení umožňuje zadat velikost oddíly a počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="abe22-165">Toto přetížení lze použít ve scénářích, kde je tak malý, dokonce i jediný virtuální metodu volání na prvek má znatelnému dopadu na výkon, práce na prvek.</span><span class="sxs-lookup"><span data-stu-id="abe22-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="abe22-166">Vlastní dělicí metody</span><span class="sxs-lookup"><span data-stu-id="abe22-166">Custom Partitioners</span></span>

<span data-ttu-id="abe22-167">V některých případech může být vhodné nebo dokonce musí implementovat vlastní dělicí metody.</span><span class="sxs-lookup"><span data-stu-id="abe22-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="abe22-168">Například může mít vlastní třídu kolekce, která můžete dělit efektivnější než výchozí rozdělovače můžete na základě vašich znalostí interní struktury třídy.</span><span class="sxs-lookup"><span data-stu-id="abe22-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="abe22-169">Nebo můžete chtít vytvořit rozsah oddíly na základě vašich znalostí o jak dlouho bude trvat prvky procesu na různých místech ve zdrojové kolekci různých velikostí.</span><span class="sxs-lookup"><span data-stu-id="abe22-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="abe22-170">Chcete-li vytvořit základní vlastního rozdělovače, odvoďte třídu z <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> a přepsat virtuální metody, jak je popsáno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="abe22-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="abe22-171">Tato metoda se volá jednou pomocí hlavního vlákna a vrátí IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="abe22-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="abe22-172">Každý pracovní podproces smyčky nebo dotazu můžete volat `GetEnumerator` v seznamu můžete načíst <xref:System.Collections.Generic.IEnumerator%601> prostřednictvím samostatného oddílu.</span><span class="sxs-lookup"><span data-stu-id="abe22-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="abe22-173">Vrátí `true` Pokud implementujete <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, v opačném případě `false`.</span><span class="sxs-lookup"><span data-stu-id="abe22-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="abe22-174">Pokud <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> je `true`, tuto metodu lze volat volitelně místo <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="abe22-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="abe22-175">Pokud musí být výsledky řazení nebo vyžadujete indexovaný přístup do prvků, pak jsou odvozeny z <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> a přepsat její virtuální metody, jak je popsáno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="abe22-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="abe22-176">Tato metoda se volá jednou pomocí hlavního vlákna a vrátí `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="abe22-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="abe22-177">Každý pracovní podproces smyčky nebo dotazu můžete volat `GetEnumerator` v seznamu můžete načíst <xref:System.Collections.Generic.IEnumerator%601> prostřednictvím samostatného oddílu.</span><span class="sxs-lookup"><span data-stu-id="abe22-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="abe22-178">Vrátí `true` Pokud implementujete <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; jinak hodnota false.</span><span class="sxs-lookup"><span data-stu-id="abe22-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="abe22-179">Obvykle to jen volá <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="abe22-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="abe22-180">Pokud <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> je `true`, tuto metodu lze volat volitelně místo <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="abe22-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="abe22-181">Následující tabulka obsahuje další podrobnosti o tři druhy implementace dělicí metody vyrovnávání zatížení <xref:System.Collections.Concurrent.OrderablePartitioner%601> třídy.</span><span class="sxs-lookup"><span data-stu-id="abe22-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="abe22-182">Metoda/vlastnost</span><span class="sxs-lookup"><span data-stu-id="abe22-182">Method/Property</span></span>|<span data-ttu-id="abe22-183">IList / pole bez vyrovnávání zatížení</span><span class="sxs-lookup"><span data-stu-id="abe22-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="abe22-184">IList nebo pole s vyrovnáváním zatížení</span><span class="sxs-lookup"><span data-stu-id="abe22-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="abe22-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="abe22-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="abe22-186">Používá rozsah dělení</span><span class="sxs-lookup"><span data-stu-id="abe22-186">Uses range partitioning</span></span>|<span data-ttu-id="abe22-187">Používá blok dělení optimalizovaná pro seznamy pro partitionCount zadaný</span><span class="sxs-lookup"><span data-stu-id="abe22-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="abe22-188">Používá blok dělení vytvořením statického počtu oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="abe22-189">Nepodporované vyvolá výjimka</span><span class="sxs-lookup"><span data-stu-id="abe22-189">Throws not-supported exception</span></span>|<span data-ttu-id="abe22-190">Používá blok dělení optimalizované pro seznamy a dynamických oddílů</span><span class="sxs-lookup"><span data-stu-id="abe22-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="abe22-191">Používá blok dělení tak, že vytvoříte dynamické počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="abe22-192">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-192">Returns `true`</span></span>|<span data-ttu-id="abe22-193">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-193">Returns `true`</span></span>|<span data-ttu-id="abe22-194">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="abe22-195">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-195">Returns `true`</span></span>|<span data-ttu-id="abe22-196">Vrátí `false`</span><span class="sxs-lookup"><span data-stu-id="abe22-196">Returns `false`</span></span>|<span data-ttu-id="abe22-197">Vrátí `false`</span><span class="sxs-lookup"><span data-stu-id="abe22-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="abe22-198">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-198">Returns `true`</span></span>|<span data-ttu-id="abe22-199">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-199">Returns `true`</span></span>|<span data-ttu-id="abe22-200">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="abe22-201">Vrátí `false`</span><span class="sxs-lookup"><span data-stu-id="abe22-201">Returns `false`</span></span>|<span data-ttu-id="abe22-202">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-202">Returns `true`</span></span>|<span data-ttu-id="abe22-203">Vrátí `true`</span><span class="sxs-lookup"><span data-stu-id="abe22-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="abe22-204">Dynamických oddílů</span><span class="sxs-lookup"><span data-stu-id="abe22-204">Dynamic Partitions</span></span>

<span data-ttu-id="abe22-205">Pokud máte v úmyslu dělicí metody pro použití v <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodu, musí být schopni vracet dynamické počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="abe22-206">To znamená, že dělicí můžete zadat enumerátor pro nového oddílu na vyžádání kdykoli během provádění smyčky.</span><span class="sxs-lookup"><span data-stu-id="abe22-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="abe22-207">V podstatě pokaždé, když smyčky přidá nový paralelních úkolů, požadavků nový oddíl pro tuto úlohu.</span><span class="sxs-lookup"><span data-stu-id="abe22-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="abe22-208">Pokud potřebujete data, která mají být uspořádatelná, pak jsou odvozeny z <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> tak, aby každá položka v každém oddílu je přiřazen jedinečný index.</span><span class="sxs-lookup"><span data-stu-id="abe22-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="abe22-209">Další informace a příklad najdete v tématu [jak: Implementace dynamických oddílů](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="abe22-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="abe22-210">Kontrakt pro dělicí metody</span><span class="sxs-lookup"><span data-stu-id="abe22-210">Contract for Partitioners</span></span>

<span data-ttu-id="abe22-211">Při implementaci vlastního rozdělovače, postupujte podle následujících pokynů k zajištění správné interakci s PLINQ a <xref:System.Threading.Tasks.Parallel.ForEach%2A> v TPL:</span><span class="sxs-lookup"><span data-stu-id="abe22-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="abe22-212">Pokud <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> je volána s argumentem nula nebo pro `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="abe22-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="abe22-213">I když PLINQ a TPL se nikdy předat `partitionCount` rovná 0, přesto doporučujeme, aby je pomáhalo chránit před možnost.</span><span class="sxs-lookup"><span data-stu-id="abe22-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="abe22-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> a <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> by měla vždy vrátit `partitionsCount` počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="abe22-215">Pokud dělicí vyčerpá data a nelze vytvořit libovolný počet oddílů, jak si vyžádal, metoda by měla vrátit prázdný výčet pro každý zbývající oddílů.</span><span class="sxs-lookup"><span data-stu-id="abe22-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="abe22-216">V opačném případě se vyvolá PLINQ a TPL <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="abe22-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="abe22-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, a <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> nikdy by měla vrátit `null` (`Nothing` v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="abe22-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="abe22-218">V takovém případě PLINQ / TPL vyvolá výjimku <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="abe22-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="abe22-219">Metody, které vracejí oddíly by měla vždy vrátit oddíly, které můžete plně a jednoznačně zobrazit výčet zdroj dat.</span><span class="sxs-lookup"><span data-stu-id="abe22-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="abe22-220">Měla by existovat žádné duplicity ve zdroji dat nebo přeskočené položky není-li konkrétně vyžadováno záměrné dělicí.</span><span class="sxs-lookup"><span data-stu-id="abe22-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="abe22-221">Pokud se toto pravidlo nedodrží, může zamíchal pořadí výstupu.</span><span class="sxs-lookup"><span data-stu-id="abe22-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="abe22-222">Následující metody getter logická musí vždy přesně vrátit následující hodnoty tak, aby není zamíchal pořadí výstupu:</span><span class="sxs-lookup"><span data-stu-id="abe22-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="abe22-223">`KeysOrderedInEachPartition`: Každý oddíl vrátí elementy rostoucími klíče indexy.</span><span class="sxs-lookup"><span data-stu-id="abe22-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="abe22-224">`KeysOrderedAcrossPartitions`: Pro všechny oddíly, které jsou vráceny klíče indexy v oddílu *můžu* jsou vyšší než klíče indexy v oddílu *můžu*-1.</span><span class="sxs-lookup"><span data-stu-id="abe22-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="abe22-225">`KeysNormalized`: Všechny klíče indexy monotónně roste bez mezer, od nuly.</span><span class="sxs-lookup"><span data-stu-id="abe22-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="abe22-226">Všechny indexy musí být jedinečný.</span><span class="sxs-lookup"><span data-stu-id="abe22-226">All indices must be unique.</span></span> <span data-ttu-id="abe22-227">Možná duplicitní indexy.</span><span class="sxs-lookup"><span data-stu-id="abe22-227">There may not be duplicate indices.</span></span> <span data-ttu-id="abe22-228">Pokud se toto pravidlo nedodrží, může zamíchal pořadí výstupu.</span><span class="sxs-lookup"><span data-stu-id="abe22-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="abe22-229">Všechny indexy musí být nezáporná.</span><span class="sxs-lookup"><span data-stu-id="abe22-229">All indices must be nonnegative.</span></span> <span data-ttu-id="abe22-230">Pokud se toto pravidlo nedodrží, PLINQ a TPL může vyvolat výjimky.</span><span class="sxs-lookup"><span data-stu-id="abe22-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="abe22-231">Viz také:</span><span class="sxs-lookup"><span data-stu-id="abe22-231">See also</span></span>

- [<span data-ttu-id="abe22-232">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="abe22-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="abe22-233">Postupy: Implementace dynamických oddílů</span><span class="sxs-lookup"><span data-stu-id="abe22-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="abe22-234">Postupy: Implementace rozdělovače pro statické dělení</span><span class="sxs-lookup"><span data-stu-id="abe22-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
