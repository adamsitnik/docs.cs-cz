---
title: Zprávy Protobuf – gRPC pro vývojáře WCF
description: Přečtěte si, jak jsou Protobuf zprávy definovány v IDL a C#vygenerované v.
author: markrendle
ms.date: 09/09/2019
ms.openlocfilehash: f6bb67fe3bc37fcb49c0e69b7960a00d584307b8
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/23/2019
ms.locfileid: "71184202"
---
# <a name="protobuf-messages"></a><span data-ttu-id="c7b84-103">Protobuf zprávy</span><span class="sxs-lookup"><span data-stu-id="c7b84-103">Protobuf messages</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="c7b84-104">V této části se dozvíte, jak deklarovat `.proto` Protobuf zprávy v souborech, vysvětluje základní koncepty čísel polí a typů a vyhledává C# kód, který `protoc` je generován kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="c7b84-104">This section covers how to declare Protobuf messages in `.proto` files, explains the fundamental concepts of field numbers and types, and looks at the C# code that is generated by the `protoc` compiler.</span></span> <span data-ttu-id="c7b84-105">Zbytek kapitoly se podrobněji podívá na to, jak se v Protobuf reprezentují různé typy dat.</span><span class="sxs-lookup"><span data-stu-id="c7b84-105">The rest of the chapter will look in more detail at how different types of data are represented in Protobuf.</span></span>

## <a name="declaring-a-message"></a><span data-ttu-id="c7b84-106">Deklarace zprávy</span><span class="sxs-lookup"><span data-stu-id="c7b84-106">Declaring a message</span></span>

<span data-ttu-id="c7b84-107">Ve službě WCF je `Stock` možné definovat třídu pro obchodní aplikace na burze trhu, jako je například následující příklad:</span><span class="sxs-lookup"><span data-stu-id="c7b84-107">In WCF, a `Stock` class for a stock market trading application might be defined like the following example:</span></span>

```csharp
namespace TraderSys
{
    [DataContract]
    public class Stock
    {
        [DataMember]
        public int Id { get; set;}
        [DataMember]
        public string Symbol { get; set;}
        [DataMember]
        public string DisplayName { get; set;}
        [DataMember]
        public int MarketId { get; set; }
    }
}
```

<span data-ttu-id="c7b84-108">Chcete-li implementovat ekvivalentní třídu v Protobuf, musí být deklarována v `.proto` souboru.</span><span class="sxs-lookup"><span data-stu-id="c7b84-108">To implement the equivalent class in Protobuf, it must be declared in the `.proto` file.</span></span> <span data-ttu-id="c7b84-109">`protoc` Kompilátor poté vytvoří třídu .NET jako součást procesu sestavení.</span><span class="sxs-lookup"><span data-stu-id="c7b84-109">The `protoc` compiler will then generate the .NET class as part of the build process.</span></span>

```protobuf
syntax "proto3";

option csharp_namespace = "TraderSys";

message Stock {

    int32 id = 1;
    string symbol = 2;
    string displayName = 3;
    int32 marketId = 4;

}  
```

<span data-ttu-id="c7b84-110">První řádek deklaruje použitou verzi syntaxe.</span><span class="sxs-lookup"><span data-stu-id="c7b84-110">The first line declares the syntax version being used.</span></span> <span data-ttu-id="c7b84-111">Verze 3 jazyka byla vydána v 2016 a jedná se o doporučenou verzi pro služby gRPC Services.</span><span class="sxs-lookup"><span data-stu-id="c7b84-111">Version 3 of the language was released in 2016 and is the recommended version for gRPC services.</span></span>

<span data-ttu-id="c7b84-112">Řádek určuje obor názvů, který má být použit pro vygenerované C# typy. `option csharp_namespace`</span><span class="sxs-lookup"><span data-stu-id="c7b84-112">The `option csharp_namespace` line specifies the namespace to be used for the generated C# types.</span></span> <span data-ttu-id="c7b84-113">Tato možnost bude ignorována, `.proto` Pokud je soubor zkompilován pro jiné jazyky.</span><span class="sxs-lookup"><span data-stu-id="c7b84-113">This option will be ignored when the `.proto` file is compiled for other languages.</span></span> <span data-ttu-id="c7b84-114">Pro soubory Protobuf je běžné, že obsahují možnosti specifické pro jazyk pro několik jazyků.</span><span class="sxs-lookup"><span data-stu-id="c7b84-114">It is common for Protobuf files to contain language-specific options for several languages.</span></span>

<span data-ttu-id="c7b84-115">Definice `Stock` zprávy určuje čtyři pole, každý s typem, název a číslo pole.</span><span class="sxs-lookup"><span data-stu-id="c7b84-115">The `Stock` message definition specifies four fields, each with a type, a name, and a field number.</span></span>

## <a name="field-numbers"></a><span data-ttu-id="c7b84-116">Čísla polí</span><span class="sxs-lookup"><span data-stu-id="c7b84-116">Field numbers</span></span>

<span data-ttu-id="c7b84-117">Čísla polí jsou důležitou součástí Protobufu.</span><span class="sxs-lookup"><span data-stu-id="c7b84-117">Field numbers are an important part of Protobuf.</span></span> <span data-ttu-id="c7b84-118">Používají se k identifikaci polí v binárních kódovaných datech, což znamená, že se nemůžou změnit z verze na verzi vaší služby.</span><span class="sxs-lookup"><span data-stu-id="c7b84-118">They're used to identify fields in the binary encoded data, which means they can't change from version to version of your service.</span></span> <span data-ttu-id="c7b84-119">Výhodou je to, že zpětná a dopředná kompatibilita je možná.</span><span class="sxs-lookup"><span data-stu-id="c7b84-119">The advantage is that backward and forward compatibility is possible.</span></span> <span data-ttu-id="c7b84-120">Klienti a služby budou jednoduše ignorovat čísla polí, která neznají, pokud je zpracována možnost chybějící hodnoty.</span><span class="sxs-lookup"><span data-stu-id="c7b84-120">Clients and services will simply ignore field numbers they don't know about, as long as the possibility of missing values is handled.</span></span>

<span data-ttu-id="c7b84-121">V binárním formátu je číslo pole kombinováno s identifikátorem typu.</span><span class="sxs-lookup"><span data-stu-id="c7b84-121">In the binary format, the field number is combined with a type identifier.</span></span> <span data-ttu-id="c7b84-122">Čísla polí od 1 do 15 je možné kódovat s jejich typem jako jeden bajt. čísla od 16 do 2047 pobírají 2 bajty.</span><span class="sxs-lookup"><span data-stu-id="c7b84-122">Field numbers from 1 to 15 can be encoded with their type as a single byte; numbers from 16 to 2047 take 2 bytes.</span></span> <span data-ttu-id="c7b84-123">Pokud z jakéhokoli důvodu potřebujete více než 2047 polí, můžete přejít na vyšší.</span><span class="sxs-lookup"><span data-stu-id="c7b84-123">You can go higher if you need more than 2047 fields on a message for any reason.</span></span> <span data-ttu-id="c7b84-124">Identifikátory jednoho bajtu pro čísla polí 1 až 15 nabízejí lepší výkon, takže je byste měli použít pro většinu základních, často používaných polí.</span><span class="sxs-lookup"><span data-stu-id="c7b84-124">The single byte identifiers for field numbers 1 to 15 offer better performance, so you should use them for the most basic, frequently used fields.</span></span>

## <a name="types"></a><span data-ttu-id="c7b84-125">Typy</span><span class="sxs-lookup"><span data-stu-id="c7b84-125">Types</span></span>

<span data-ttu-id="c7b84-126">Deklarace typu používají nativní skalární datové typy Protobuf, které jsou podrobněji popsány v [následující části](protobuf-data-types.md).</span><span class="sxs-lookup"><span data-stu-id="c7b84-126">The type declarations are using Protobuf's native scalar data types, which are discussed in more detail in [the next section](protobuf-data-types.md).</span></span> <span data-ttu-id="c7b84-127">Zbytek této kapitoly se zabývá vestavěnými typy Protobuf a ukazuje, jak se vztahují na běžné typy .NET.</span><span class="sxs-lookup"><span data-stu-id="c7b84-127">The rest of this chapter will cover Protobuf's built-in types and show how they relate to common .NET types.</span></span>

> [!NOTE]
> <span data-ttu-id="c7b84-128">Protobuf nedokáže nativně podporovat `decimal` typ, takže se místo toho použije Double.</span><span class="sxs-lookup"><span data-stu-id="c7b84-128">Protobuf doesn't natively support a `decimal` type, so double is used instead.</span></span> <span data-ttu-id="c7b84-129">Pro aplikace, které vyžadují plnou desítkovou přesnost, se podívejte na [část na desetinných číslech](protobuf-data-types.md#decimals) v další části této kapitoly.</span><span class="sxs-lookup"><span data-stu-id="c7b84-129">For applications that require full decimal precision, refer to the [section on Decimals](protobuf-data-types.md#decimals) in the next part of this chapter.</span></span>

## <a name="the-generated-code"></a><span data-ttu-id="c7b84-130">Generovaný kód</span><span class="sxs-lookup"><span data-stu-id="c7b84-130">The generated code</span></span>

<span data-ttu-id="c7b84-131">Při sestavování aplikace Protobuf vytvoří třídy pro každou vaši zprávu a namapuje jejich nativní typy na C# typy.</span><span class="sxs-lookup"><span data-stu-id="c7b84-131">When you build your application, Protobuf creates classes for each of your messages, mapping its native types to C# types.</span></span> <span data-ttu-id="c7b84-132">Vygenerovaný `Stock` typ by měl následující signaturu:</span><span class="sxs-lookup"><span data-stu-id="c7b84-132">The generated `Stock` type would have the following signature:</span></span>

```csharp
public class Stock
{
    public int Id { get; set; }
    public string Symbol { get; set; }
    public string DisplayName { get; set; }
    public int MarketId { get; set; }
}
```

<span data-ttu-id="c7b84-133">Skutečný kód, který je generován, je mnohem složitější než to, protože každá třída obsahuje veškerý kód potřebný k serializaci a deserializaci do binárního formátu.</span><span class="sxs-lookup"><span data-stu-id="c7b84-133">The actual code that is generated is far more complicated than this, because each class contains all the code necessary to serialize and deserialize itself to the binary wire format.</span></span>

### <a name="property-names"></a><span data-ttu-id="c7b84-134">Názvy vlastností</span><span class="sxs-lookup"><span data-stu-id="c7b84-134">Property names</span></span>

<span data-ttu-id="c7b84-135">Všimněte si, že kompilátor Protobuf `PascalCase` aplikovaný na názvy vlastností, i když `camelCase` byly v `.proto` souboru.</span><span class="sxs-lookup"><span data-stu-id="c7b84-135">Note that the Protobuf compiler applied `PascalCase` to the property names although they were `camelCase` in the `.proto` file.</span></span> <span data-ttu-id="c7b84-136">Je nejvhodnější použít `camelCase` v definici zprávy tak, aby generování kódu pro jiné platformy vytvořilo očekávaný případ pro jejich konvence.</span><span class="sxs-lookup"><span data-stu-id="c7b84-136">It's best to use `camelCase` in the message definition so that the code generation for other platforms produces the expected case for their conventions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="c7b84-137">[Předchozí](protocol-buffers.md)
>[Další](protobuf-data-types.md)</span><span class="sxs-lookup"><span data-stu-id="c7b84-137">[Previous](protocol-buffers.md)
[Next](protobuf-data-types.md)</span></span>
